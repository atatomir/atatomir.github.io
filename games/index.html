<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Games • TATOMIR N. ALEX</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg-dark:#0b0d10;
  --bg-deep:#0f172a;
  --panel: rgba(255,255,255,0.06);
  --ink:#f5f7fa;
  --muted:#9aa3b2;
  --accent:#4f8cff;
}
*{margin:0;padding:0;box-sizing:border-box}
html{scroll-behavior:smooth}
body{
  font-family: 'Inter', sans-serif;
  color: var(--ink);
  line-height:1.7;
  background: linear-gradient(180deg, #0b0d10 0%, #0f172a 100%);
  background-attachment: fixed;
  background-size: cover;
}

/* NAV */
nav{
  position: fixed;
  top:20px;
  left:50%;
  transform: translateX(-50%);
  z-index:100;
  backdrop-filter: blur(16px);
  background: var(--panel);
  border:1px solid rgba(255,255,255,0.08);
  border-radius:999px;
  padding:10px 22px;
  display:flex;
  gap:16px;
  align-items:center;
}
nav a{
  color: var(--muted);
  text-decoration: none;
  font-weight:500;
  margin:0 10px;
  font-size:14px;
}
nav a:hover{color: var(--accent);}
#lang-toggle{
  margin-left:12px;
  cursor:pointer;
  background: var(--accent);
  border:none;
  border-radius:999px;
  padding:6px 12px;
  font-weight:600;
  color:white;
  font-size:13px;
  transition:0.2s;
}
#lang-toggle:hover{background:#3570d1;}

/* SECTIONS */
section{
  max-width:1100px;
  margin:0 auto;
  padding:120px 24px 60px;
}
.section-title{
  font-size:12px;
  text-transform:uppercase;
  letter-spacing:0.18em;
  color:var(--muted);
  margin-bottom:18px;
}
.section-heading{
  font-size: clamp(2rem, 4vw, 2.8rem);
  font-weight:700;
  letter-spacing:-0.02em;
  margin-bottom:28px;
}

/* REVEAL ANIMATION */
.reveal{
  opacity:0;
  transform: translateY(24px);
  transition:0.8s ease;
}
.reveal.visible{
  opacity:1;
  transform:none;
}

/* FOOTER */
footer{
  text-align:center;
  padding:60px 24px 40px;
  color:var(--muted);
  font-size:13px;
  border-top:1px solid rgba(255,255,255,0.06);
}

/* GAMES LAYOUT */
#games{text-align:center;}
/* GAME TABS */
.nav-sep{
  width:1px;height:16px;background:rgba(255,255,255,0.12);flex-shrink:0;
}
.game-tab{
  padding:6px 12px;border-radius:999px;border:none;
  background:transparent;color:var(--muted);font-size:13px;
  font-family:inherit;font-weight:500;cursor:pointer;
  transition:all 0.2s;white-space:nowrap;
}
.game-tab:hover{color:var(--ink);}
.game-tab.active{color:var(--ink);background:rgba(255,255,255,0.1);}
.game-slider{
  overflow:hidden;position:relative;
}
.game-track{
  display:flex;transition:transform 0.4s cubic-bezier(0.4,0,0.2,1);
  will-change:transform;
}
.game-pane{
  flex:0 0 100%;min-width:0;
  display:flex;justify-content:center;align-items:flex-start;
}
.games-row{
  display:flex;
  gap:32px;
  justify-content:center;
  align-items:flex-start;
  flex-wrap:wrap;
}
.game-col{
  flex:0 1 440px;
  min-width:0;
}

/* GAME TOOLBAR */
.game-toolbar{
  display:flex;justify-content:space-between;align-items:center;
  margin-bottom:12px;padding:0 4px;
}
.game-toolbar-btns{display:flex;gap:4px;}
.game-toolbar-btn{
  background:none;border:none;color:var(--muted);font-size:16px;
  cursor:pointer;padding:4px 6px;border-radius:6px;transition:0.2s;
  display:flex;align-items:center;justify-content:center;
}
.game-toolbar-btn:hover{color:var(--ink);background:rgba(255,255,255,0.08);}

/* SNAKE GAME */
.snake-score-bar{
  display:flex;
  gap:32px;
  font-size:14px;
  color:var(--muted);
}
.snake-score-bar span{color:var(--accent);font-weight:600;}
.snake-canvas-wrap{
  position:relative;
  display:inline-block;
  border-radius:14px;
  overflow:hidden;
  border:2px solid rgba(79,140,255,0.35);
  box-shadow:0 0 30px rgba(79,140,255,0.1);
}
#snake-canvas{display:block;background:#0b0d10;max-width:100%;height:auto;}
.snake-overlay{
  position:absolute;inset:0;
  display:flex;flex-direction:column;
  align-items:center;justify-content:center;
  background:rgba(11,13,16,0.82);
  backdrop-filter:blur(6px);
  z-index:2;
  transition:opacity 0.3s;
}
.snake-overlay.hidden{opacity:0;pointer-events:none;}
.snake-overlay h3{font-size:1.6rem;margin-bottom:8px;}
.snake-overlay p{color:var(--muted);margin-bottom:18px;font-size:0.95rem;}
.snake-overlay .snake-final-score{font-size:2rem;font-weight:700;color:var(--accent);margin-bottom:6px;}
.snake-btn{
  padding:12px 28px;border:none;border-radius:999px;
  background:var(--accent);color:#fff;font-weight:600;font-size:14px;
  cursor:pointer;transition:0.2s;margin:4px;
}
.snake-btn:hover{background:#3570d1;transform:translateY(-1px);}
.snake-btn.secondary-btn{
  background:transparent;border:1px solid rgba(255,255,255,0.15);color:var(--ink);
}
.snake-btn.secondary-btn:hover{background:rgba(255,255,255,0.05);}
.snake-initials-input{
  background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);
  border-radius:8px;padding:8px 12px;color:var(--ink);font-size:1rem;
  text-align:center;width:80px;text-transform:uppercase;font-weight:600;
  margin-bottom:10px;outline:none;
}
.snake-initials-input:focus{border-color:var(--accent);}
.snake-leaderboard{
  margin:28px auto 0;max-width:340px;
  backdrop-filter:blur(16px);background:var(--panel);
  border:1px solid rgba(255,255,255,0.08);border-radius:14px;
  padding:20px 24px;
}
.snake-leaderboard h4{font-size:13px;text-transform:uppercase;letter-spacing:0.14em;color:var(--muted);margin-bottom:12px;}
.snake-leaderboard table{width:100%;border-collapse:collapse;font-size:14px;}
.snake-leaderboard th{color:var(--muted);font-weight:500;text-align:left;padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.06);}
.snake-leaderboard td{padding:6px 0;}
.snake-leaderboard td:last-child{text-align:right;color:var(--accent);font-weight:600;}
.snake-dpad{
  display:none;
  margin:18px auto 0;
  width:160px;height:160px;
  position:relative;
}
.snake-dpad button{
  position:absolute;width:50px;height:50px;
  border:none;border-radius:10px;
  background:var(--panel);backdrop-filter:blur(8px);
  border:1px solid rgba(255,255,255,0.1);
  color:var(--ink);font-size:20px;cursor:pointer;
  display:flex;align-items:center;justify-content:center;
  transition:0.15s;-webkit-tap-highlight-color:transparent;
  user-select:none;
}
.snake-dpad button:active{background:rgba(79,140,255,0.25);}
.snake-dpad .d-up{top:0;left:55px;}
.snake-dpad .d-down{bottom:0;left:55px;}
.snake-dpad .d-left{top:55px;left:0;}
.snake-dpad .d-right{top:55px;right:0;}

/* TRADING GAME */
.trade-panel{
  position:relative;
  backdrop-filter:blur(16px);background:var(--panel);
  border:1px solid rgba(255,255,255,0.08);border-radius:14px;
  padding:20px;text-align:center;
}
.trade-panel h3{font-size:1.1rem;font-weight:600;margin-bottom:12px;}
.trade-info{
  display:flex;justify-content:center;margin-bottom:14px;font-size:13px;color:var(--muted);
}
.trade-info > div{flex:1 1 0;min-width:0;text-align:center;}
.trade-info span{display:block;font-size:1.05rem;font-weight:600;color:var(--ink);margin-top:2px;font-variant-numeric:tabular-nums;}
.trade-info .pnl-pos{color:#34d399;}
.trade-info .pnl-neg{color:#ef4444;}
.trade-canvas-wrap{
  position:relative;border-radius:10px;overflow:hidden;
  border:1px solid rgba(255,255,255,0.08);margin-bottom:14px;
}
#trade-canvas{display:block;width:100%;height:auto;}
.trade-overlay{
  position:absolute;inset:0;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  background:rgba(11,13,16,0.82);backdrop-filter:blur(6px);z-index:2;transition:opacity 0.3s;
}
.trade-overlay.hidden{opacity:0;pointer-events:none;}
.trade-overlay h3{font-size:1.4rem;margin-bottom:0;}
.trade-overlay p{color:var(--muted);margin-bottom:1px;font-size:0.9rem;}
.trade-result{font-size:1.6rem;font-weight:700;margin-bottom:0;}
.trade-btns{display:flex;gap:8px;justify-content:center;}
.trade-btn{
  padding:10px 22px;border:none;border-radius:999px;
  font-weight:600;font-size:14px;cursor:pointer;transition:0.2s;
}
.trade-btn:hover{transform:translateY(-1px);}
.trade-btn.buy{background:#34d399;color:#0b0d10;}
.trade-btn.buy:hover{background:#2ab884;}
.trade-btn.sell{background:#ef4444;color:#fff;}
.trade-btn.sell:hover{background:#d63535;}
.trade-btn.start{background:var(--accent);color:#fff;}
.trade-btn.start:hover{background:#3570d1;}
.trade-position-bar{
  display:flex;align-items:center;justify-content:center;gap:6px;
  margin-bottom:14px;font-size:13px;color:var(--muted);
}
.trade-pos-dots{display:flex;gap:2px;align-items:center;}
.trade-pos-dot{
  width:7px;height:7px;border-radius:50%;
  background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);
  transition:0.15s;
}
.trade-pos-dot.zero{width:9px;height:9px;border-color:rgba(255,255,255,0.25);}
.trade-pos-dot.long{background:#34d399;border-color:#34d399;}
.trade-pos-dot.short{background:#ef4444;border-color:#ef4444;}
.trade-timer{
  height:3px;background:rgba(255,255,255,0.06);border-radius:2px;margin-bottom:14px;overflow:hidden;
}
.trade-timer-fill{height:100%;background:var(--accent);transition:width 0.1s linear;width:0%;}
.trade-btn.end{background:transparent;border:1px solid rgba(255,255,255,0.15);color:var(--ink);}
.trade-btn.end:hover{background:rgba(255,255,255,0.05);}
.trade-hint{margin-top:10px;font-size:11px;color:var(--muted);line-height:1.6;}
.trade-hint kbd{
  display:inline-block;padding:1px 6px;border-radius:4px;font-size:10px;font-family:inherit;
  background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);
  color:var(--ink);vertical-align:1px;
}
.trade-paused-badge{
  display:none;align-items:center;justify-content:center;gap:6px;
  margin-bottom:10px;font-size:13px;font-weight:600;color:#fbbf24;
}
.trade-paused-badge.visible{display:flex;}
.trade-log{margin-top:16px;}
.trade-log h4{font-size:13px;text-transform:uppercase;letter-spacing:0.14em;color:var(--muted);margin-bottom:10px;}
.trade-log-scroll{max-height:150px;overflow-y:auto;scrollbar-width:thin;scrollbar-color:rgba(255,255,255,0.1) transparent;}
.trade-log table{width:100%;border-collapse:collapse;font-size:12px;font-variant-numeric:tabular-nums;}
.trade-log th{color:var(--muted);font-weight:500;text-align:left;padding:3px 4px;border-bottom:1px solid rgba(255,255,255,0.06);font-size:11px;position:sticky;top:0;background:rgba(15,23,42,0.95);}
.trade-log td{padding:4px;white-space:nowrap;}
.trade-log td:last-child{text-align:right;font-weight:600;}
.lb-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;}
.lb-header h4{margin:0;}
.lb-clear-btn{
  background:none;border:none;color:var(--muted);font-size:14px;
  cursor:pointer;padding:2px 4px;border-radius:4px;transition:0.2s;line-height:1;
}
.lb-clear-btn:hover{color:#ef4444;background:rgba(239,68,68,0.1);}
.trade-lb{margin-top:16px;}
.trade-lb h4{font-size:13px;text-transform:uppercase;letter-spacing:0.14em;color:var(--muted);margin-bottom:10px;}
.trade-lb table{width:100%;border-collapse:collapse;font-size:14px;}
.trade-lb th{color:var(--muted);font-weight:500;text-align:left;padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.06);}
.trade-lb td{padding:6px 0;}
.trade-lb td:last-child{text-align:right;font-weight:600;}

/* GAME SETTINGS (shared) */
.game-settings-modal{
  position:absolute;inset:0;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  background:rgba(11,13,16,0.88);backdrop-filter:blur(8px);z-index:10;
  transition:opacity 0.3s;
}
.game-settings-modal.hidden{opacity:0;pointer-events:none;}
.game-settings-inner{width:85%;max-width:300px;text-align:left;}
.game-settings-inner h4{font-size:13px;text-transform:uppercase;letter-spacing:0.14em;color:var(--muted);margin-bottom:14px;text-align:center;}
.game-settings-row{
  display:flex;justify-content:space-between;align-items:center;
  margin-bottom:10px;font-size:13px;color:var(--ink);
}
.game-settings-row label{color:var(--muted);}
.game-settings-select{
  background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);
  border-radius:6px;padding:4px 8px;color:var(--ink);font-size:12px;
  font-family:inherit;outline:none;cursor:pointer;
}
.game-settings-select:focus{border-color:var(--accent);}
.game-settings-close{
  margin-top:10px;width:100%;padding:8px;border:none;border-radius:8px;
  background:rgba(255,255,255,0.08);color:var(--ink);font-weight:600;font-size:12px;
  cursor:pointer;transition:0.2s;font-family:inherit;
}
.game-settings-close:hover{background:rgba(255,255,255,0.15);}

/* WHITEBOARD */
.wb-wrap{
  width:100%;
  backdrop-filter:blur(16px);background:var(--panel);
  border:1px solid rgba(255,255,255,0.08);border-radius:14px;
  padding:0;overflow:hidden;position:relative;
}
.wb-toolbar{
  display:flex;align-items:center;gap:6px;padding:10px 14px;
  border-bottom:1px solid rgba(255,255,255,0.08);
  flex-wrap:wrap;background:rgba(0,0,0,0.15);
}
.wb-toolbar-group{display:flex;align-items:center;gap:3px;}
.wb-sep{width:1px;height:22px;background:rgba(255,255,255,0.1);margin:0 6px;}
.wb-btn{
  background:none;border:1px solid transparent;color:var(--muted);
  cursor:pointer;padding:5px 7px;border-radius:6px;transition:0.15s;
  display:flex;align-items:center;justify-content:center;font-size:14px;
  min-width:30px;height:30px;
}
.wb-btn:hover{color:var(--ink);background:rgba(255,255,255,0.08);}
.wb-btn.active{color:var(--accent);background:rgba(79,140,255,0.15);border-color:rgba(79,140,255,0.3);}
.wb-btn svg{pointer-events:none;}
.wb-color-btn{
  width:22px;height:22px;border-radius:50%;border:2px solid rgba(255,255,255,0.15);
  cursor:pointer;transition:0.15s;padding:0;flex-shrink:0;
}
.wb-color-btn:hover,.wb-color-btn.active{border-color:var(--accent);transform:scale(1.15);}
.wb-size-slider{
  -webkit-appearance:none;appearance:none;width:70px;height:4px;
  background:rgba(255,255,255,0.15);border-radius:2px;outline:none;cursor:pointer;
}
.wb-size-slider::-webkit-slider-thumb{
  -webkit-appearance:none;width:14px;height:14px;border-radius:50%;
  background:var(--accent);cursor:pointer;border:none;
}
.wb-size-slider::-moz-range-thumb{
  width:14px;height:14px;border-radius:50%;
  background:var(--accent);cursor:pointer;border:none;
}
.wb-size-label{font-size:11px;color:var(--muted);min-width:22px;text-align:center;}
.wb-canvas-area{
  position:relative;cursor:crosshair;background:#181b22;
  touch-action:none;overflow:hidden;
}
.wb-sidebar{
  position:absolute;left:10px;top:50%;transform:translateY(-50%);z-index:6;
  display:flex;flex-direction:column;align-items:center;gap:2px;padding:6px;
  background:rgba(12,14,20,0.75);backdrop-filter:blur(10px);
  border:1px solid rgba(255,255,255,0.08);border-radius:12px;
}
.wb-sidebar .wb-toolbar-group{display:flex;flex-direction:column;align-items:center;gap:2px;}
.wb-sidebar .wb-btn{min-width:32px;height:32px;padding:4px;}
.wb-sidebar .wb-sep{width:100%;height:1px;margin:2px 0;}
#wb-canvas{display:block;width:100%;height:auto;}
.wb-wrap:fullscreen{
  display:flex;flex-direction:column;background:#0b0d10;width:100%;height:100%;
}
.wb-wrap:fullscreen .wb-canvas-area{flex:1;min-height:0;}
.wb-wrap:fullscreen #wb-canvas{width:100%;height:100%;max-width:none;}
.wb-toolbar-right{margin-left:auto;display:flex;align-items:center;gap:3px;}
.wb-color-picker{
  width:22px;height:22px;border-radius:50%;border:2px solid rgba(255,255,255,0.15);
  cursor:pointer;padding:0;-webkit-appearance:none;appearance:none;background:none;
  overflow:hidden;flex-shrink:0;
}
.wb-color-picker::-webkit-color-swatch-wrapper{padding:0;}
.wb-color-picker::-webkit-color-swatch{border:none;border-radius:50%;}
.wb-color-picker::-moz-color-swatch{border:none;border-radius:50%;}
.wb-color-picker:hover{border-color:var(--accent);transform:scale(1.15);}
.wb-opacity-slider{
  -webkit-appearance:none;appearance:none;width:50px;height:4px;
  background:linear-gradient(to right,transparent,var(--ink));border-radius:2px;outline:none;cursor:pointer;
}
.wb-opacity-slider::-webkit-slider-thumb{
  -webkit-appearance:none;width:12px;height:12px;border-radius:50%;
  background:var(--ink);cursor:pointer;border:2px solid var(--accent);
}
.wb-opacity-slider::-moz-range-thumb{
  width:12px;height:12px;border-radius:50%;
  background:var(--ink);cursor:pointer;border:2px solid var(--accent);
}
.wb-text-input{
  position:absolute;background:transparent;border:1px dashed rgba(79,140,255,0.6);
  color:inherit;font-family:'Inter',sans-serif;outline:none;padding:4px 6px;
  z-index:5;min-width:40px;resize:none;overflow:hidden;line-height:1.3;
  word-wrap:break-word;white-space:pre-wrap;box-sizing:border-box;
}
.wb-grid-canvas{
  position:absolute;top:0;left:0;width:100%;height:100%;
  pointer-events:none;opacity:0;transition:opacity 0.2s;
}
.wb-grid-canvas.visible{opacity:1;}
.wb-canvas-area.panning{cursor:grab !important;}
.wb-canvas-area.panning-active{cursor:grabbing !important;}
/* AI Guess */
.wb-ai-btn.active{color:#facc15;background:rgba(250,204,21,0.15);border-color:rgba(250,204,21,0.3);}
.wb-ai-popover{
  position:absolute;top:100%;right:0;margin-top:6px;z-index:20;
  background:#1e2130;border:1px solid rgba(255,255,255,0.12);border-radius:10px;
  padding:12px 14px;min-width:260px;box-shadow:0 8px 32px rgba(0,0,0,0.5);
  display:none;
}
.wb-ai-popover.visible{display:block;}
.wb-ai-popover label{font-size:11px;color:var(--muted);display:block;margin-bottom:4px;}
.wb-ai-popover input[type="password"]{
  width:100%;box-sizing:border-box;padding:6px 8px;border-radius:6px;
  border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.3);
  color:var(--ink);font-size:12px;font-family:inherit;outline:none;
}
.wb-ai-popover input[type="password"]:focus{border-color:var(--accent);}
.wb-ai-popover .wb-ai-row{display:flex;align-items:center;gap:6px;margin-top:8px;}
.wb-ai-popover .wb-ai-save{
  padding:4px 12px;border-radius:6px;border:none;
  background:var(--accent);color:#fff;font-size:12px;cursor:pointer;font-family:inherit;
}
.wb-ai-popover .wb-ai-save:hover{opacity:0.85;}
.wb-ai-popover .wb-ai-status{font-size:10px;color:var(--muted);}
.wb-ai-draw-popover{
  position:absolute;top:100%;right:0;margin-top:6px;z-index:20;
  background:#1e2130;border:1px solid rgba(255,255,255,0.12);border-radius:10px;
  padding:12px 14px;min-width:300px;box-shadow:0 8px 32px rgba(0,0,0,0.5);
  display:none;
}
.wb-ai-draw-popover.visible{display:block;}
.wb-ai-draw-popover label{font-size:11px;color:var(--muted);display:block;margin-bottom:4px;}
.wb-ai-draw-popover input[type="text"]{
  width:100%;box-sizing:border-box;padding:6px 8px;border-radius:6px;
  border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.3);
  color:var(--ink);font-size:12px;font-family:inherit;outline:none;
}
.wb-ai-draw-popover input[type="text"]:focus{border-color:var(--accent);}
.wb-ai-draw-popover .wb-ai-draw-row{display:flex;align-items:center;gap:6px;margin-top:8px;}
.wb-ai-draw-popover .wb-ai-draw-go{
  padding:4px 12px;border-radius:6px;border:none;
  background:var(--accent);color:#fff;font-size:12px;cursor:pointer;font-family:inherit;
}
.wb-ai-draw-popover .wb-ai-draw-go:hover{opacity:0.85;}
.wb-ai-draw-popover .wb-ai-draw-status{font-size:10px;color:var(--muted);}
.wb-ai-guess{
  position:absolute;bottom:12px;left:50%;transform:translateX(-50%);
  background:rgba(20,22,30,0.88);backdrop-filter:blur(10px);
  border:1px solid rgba(255,255,255,0.1);border-radius:20px;
  padding:6px 16px;font-size:13px;color:var(--ink);
  pointer-events:none;opacity:0;transition:opacity 0.3s;
  white-space:nowrap;z-index:10;
}
.wb-ai-guess.visible{opacity:1;pointer-events:auto;}
.wb-ai-guess .wb-ai-icon{margin-right:6px;}
@keyframes wb-pulse{0%,100%{opacity:0.4;}50%{opacity:1;}}
.wb-ai-guess.loading .wb-ai-icon{animation:wb-pulse 1s infinite;}

/* More popover */
.wb-more-popover{
  position:absolute;top:100%;right:0;margin-top:6px;z-index:20;
  background:#1e2130;border:1px solid rgba(255,255,255,0.12);border-radius:10px;
  padding:6px 0;min-width:150px;box-shadow:0 8px 32px rgba(0,0,0,0.5);
  display:none;
}
.wb-more-popover.visible{display:block;}
.wb-more-item{
  display:flex;align-items:center;gap:8px;padding:7px 14px;
  font-size:12px;color:var(--ink);cursor:pointer;white-space:nowrap;
  background:none;border:none;width:100%;font-family:inherit;
}
.wb-more-item:hover{background:rgba(255,255,255,0.06);}
.wb-more-item input[type="checkbox"]{accent-color:var(--accent);cursor:pointer;}
.wb-more-sep{height:1px;background:rgba(255,255,255,0.08);margin:4px 0;}

/* Remote cursors */
.wb-remote-cursor{
  position:absolute;pointer-events:none;z-index:7;
  transition:left 0.08s linear, top 0.08s linear;
}
.wb-remote-cursor svg{display:block;}
.wb-remote-cursor-label{
  position:absolute;left:14px;top:12px;
  font-size:9px;font-weight:600;white-space:nowrap;
  padding:1px 5px;border-radius:4px;color:#fff;
  line-height:1.4;letter-spacing:0.2px;
}

/* Collaboration */
.wb-collab{display:flex;align-items:center;gap:4px;margin-left:2px;}
.wb-collab .wb-btn{font-size:11px;padding:2px 8px;gap:3px;display:inline-flex;align-items:center;}
.wb-collab-input{width:90px;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.3);color:var(--ink);font-size:11px;font-family:'SF Mono',monospace;outline:none;}
.wb-collab-input:focus{border-color:var(--accent);}
.wb-collab-input::placeholder{color:rgba(255,255,255,0.25);}
.wb-collab-status{display:inline-flex;align-items:center;gap:4px;font-size:10px;color:var(--muted);}
.wb-collab-dot{width:6px;height:6px;border-radius:50%;background:#ef4444;display:inline-block;}
.wb-collab-dot.on{background:#34d399;}
.wb-collab-peers{font-size:10px;color:var(--muted);margin-left:2px;}

/* Chat */
.wb-chat-row{position:relative;}
.wb-chat{
  position:absolute;right:0;top:0;bottom:0;width:240px;z-index:8;
  display:flex;flex-direction:column;
  border-left:1px solid rgba(255,255,255,0.06);
  background:rgba(12,14,20,0.35);backdrop-filter:blur(6px);
  transition:transform 0.25s ease;
}
.wb-chat.collapsed{transform:translateX(100%);}
.wb-chat-toggle{
  position:absolute;right:0;top:50%;transform:translateY(-50%);z-index:9;
  width:22px;height:44px;border:none;cursor:pointer;
  background:rgba(12,14,20,0.85);backdrop-filter:blur(8px);
  border-radius:6px 0 0 6px;border:1px solid rgba(255,255,255,0.08);border-right:none;
  color:var(--muted);display:flex;align-items:center;justify-content:center;
  transition:right 0.25s ease, color 0.15s;
}
.wb-chat-toggle:hover{color:var(--ink);}
.wb-chat-toggle.shifted{right:240px;}
.wb-chat-header{
  padding:8px 12px;font-size:11px;font-weight:600;color:var(--muted);
  border-bottom:1px solid rgba(255,255,255,0.06);display:flex;align-items:center;gap:6px;
}
.wb-chat-nick{
  padding:2px 6px;border-radius:4px;border:1px solid rgba(255,255,255,0.1);
  background:rgba(0,0,0,0.3);color:var(--ink);font-size:11px;outline:none;
  width:80px;font-family:inherit;
}
.wb-chat-nick:focus{border-color:var(--accent);}
.wb-chat-msgs{
  flex:1;overflow-y:auto;padding:10px 10px;
  display:flex;flex-direction:column;gap:6px;
  align-items:flex-start;
}
.wb-chat-bubble{
  max-width:82%;padding:7px 11px;border-radius:16px;
  font-size:11px;line-height:1.45;word-break:break-word;
  position:relative;
}
.wb-chat-bubble.mine{
  align-self:flex-end;
  background:var(--accent);color:#fff;
  border-bottom-right-radius:4px;
}
.wb-chat-bubble.theirs{
  align-self:flex-start;
  background:rgba(255,255,255,0.1);color:var(--ink);
  border-bottom-left-radius:4px;
}
.wb-chat-bubble .wb-chat-nick-label{
  display:block;font-size:9px;font-weight:700;margin-bottom:2px;
  opacity:0.7;letter-spacing:0.3px;
}
.wb-chat-bubble.mine .wb-chat-nick-label{color:rgba(255,255,255,0.7);text-align:right;}
.wb-chat-bubble.theirs .wb-chat-nick-label{color:var(--accent);text-align:left;}
.wb-chat-sys{
  text-align:center;font-size:10px;color:var(--muted);
  font-style:italic;padding:2px 0;align-self:center;
}
.wb-chat-input-row{
  display:flex;border-top:1px solid rgba(255,255,255,0.06);
  align-items:center;gap:0;
}
.wb-chat-input{
  flex:1;padding:9px 12px;border:none;background:transparent;
  color:var(--ink);font-size:12px;font-family:inherit;outline:none;
}
.wb-chat-input::placeholder{color:rgba(255,255,255,0.2);}
.wb-chat-send{
  padding:6px 8px;margin-right:4px;background:none;border:none;color:var(--accent);
  cursor:pointer;display:flex;align-items:center;justify-content:center;
  border-radius:50%;transition:0.15s;
}
.wb-chat-send:hover{background:rgba(79,140,255,0.15);}

/* WHITEBOARD MOBILE */
@media(max-width:768px){
  .wb-toolbar{
    gap:4px;padding:6px 8px;
    overflow-x:auto;overflow-y:hidden;
    flex-wrap:nowrap;-webkit-overflow-scrolling:touch;
    scrollbar-width:none;
  }
  .wb-toolbar::-webkit-scrollbar{display:none;}
  .wb-toolbar>span:first-child{display:none;}
  .wb-toolbar .wb-sep{margin:0 3px;height:18px;}
  .wb-toolbar .wb-btn{min-width:26px;height:26px;padding:3px 5px;}
  .wb-toolbar .wb-btn svg{width:14px;height:14px;}
  .wb-color-btn{width:18px;height:18px;}
  .wb-color-picker{width:18px;height:18px;}
  .wb-size-slider{width:46px;}
  .wb-opacity-slider{width:32px;}
  .wb-size-label{font-size:9px;min-width:16px;}
  .wb-toolbar-right{gap:2px;}
  .wb-collab-input{width:60px;font-size:10px;padding:2px 4px;}
  .wb-collab{gap:3px;}
  .wb-collab-status{font-size:9px;gap:2px;}
  .wb-collab-peers{font-size:9px;}
  .wb-ai-popover,.wb-ai-draw-popover{min-width:200px;right:-40px;}
  .wb-chat{width:200px;}
  .wb-sidebar{left:6px;padding:4px;gap:1px;border-radius:10px;}
  .wb-sidebar .wb-btn{min-width:28px;height:28px;padding:3px;}
  .wb-sidebar .wb-btn svg{width:14px;height:14px;}
}
@media(max-width:480px){
  .wb-toolbar{gap:3px;padding:5px 6px;}
  .wb-toolbar .wb-sep{display:none;}
  .wb-toolbar .wb-btn{min-width:24px;height:24px;padding:2px 4px;}
  .wb-toolbar .wb-btn svg{width:13px;height:13px;}
  .wb-color-btn{width:16px;height:16px;border-width:1.5px;}
  .wb-color-picker{width:16px;height:16px;}
  .wb-size-slider{width:36px;}
  .wb-opacity-slider{width:24px;}
  .wb-collab-input{width:50px;}
  .wb-chat{width:180px;}
  .wb-sidebar{left:4px;padding:3px;border-radius:8px;}
  .wb-sidebar .wb-btn{min-width:24px;height:24px;padding:2px;}
  .wb-sidebar .wb-btn svg{width:13px;height:13px;}
  .wb-sidebar .wb-sep{margin:1px 0;}
}

/* FULLSCREEN */
.snake-canvas-wrap:fullscreen, .trade-panel:fullscreen{
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  background:#0b0d10;width:100%;height:100%;
}
.snake-canvas-wrap:fullscreen #snake-canvas{max-width:none;height:auto;}
.trade-panel:fullscreen{padding:24px;overflow-y:auto;}
.trade-panel:fullscreen .trade-canvas-wrap{width:100%;max-width:1200px;}

/* SCREEN RECORDER */
.rec-fab{
  position:fixed;bottom:24px;right:24px;z-index:1000;
  width:48px;height:48px;border-radius:50%;border:none;
  background:rgba(30,33,48,0.92);backdrop-filter:blur(10px);
  color:var(--ink);cursor:pointer;display:flex;align-items:center;justify-content:center;
  box-shadow:0 4px 20px rgba(0,0,0,0.5);transition:background 0.2s, transform 0.15s;
}
.rec-fab:hover{background:rgba(40,44,60,0.95);transform:scale(1.08);}
.rec-fab.recording{background:rgba(220,38,38,0.85);animation:rec-pulse 1.5s infinite;}
@keyframes rec-pulse{0%,100%{box-shadow:0 0 0 0 rgba(220,38,38,0.4);}50%{box-shadow:0 0 0 12px rgba(220,38,38,0);}}
.rec-fab svg{pointer-events:none;}
.rec-panel{
  position:fixed;bottom:80px;right:24px;z-index:1000;
  background:rgba(30,33,48,0.95);backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,0.1);border-radius:14px;
  padding:16px;width:340px;max-height:calc(100vh - 100px);overflow-y:auto;
  box-shadow:0 8px 32px rgba(0,0,0,0.5);display:none;
}
.rec-panel.visible{display:block;}
.rec-panel-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;}
.rec-panel-title{font-size:13px;font-weight:600;color:var(--ink);}
.rec-panel-close{background:none;border:none;color:var(--muted);cursor:pointer;font-size:18px;line-height:1;padding:2px 6px;}
.rec-panel-close:hover{color:var(--ink);}
.rec-timer{font-size:22px;font-weight:600;font-variant-numeric:tabular-nums;color:#ef4444;text-align:center;margin:8px 0;}
.rec-actions{display:flex;gap:8px;margin-top:8px;}
.rec-actions button{
  flex:1;padding:6px 12px;border-radius:8px;border:none;
  font-size:12px;font-family:inherit;cursor:pointer;font-weight:500;
  display:flex;align-items:center;justify-content:center;gap:6px;
}
.rec-btn-stop{background:#ef4444;color:#fff;}
.rec-btn-stop:hover{background:#dc2626;}
.rec-btn-rec{background:var(--accent);color:#fff;}
.rec-btn-rec:hover{opacity:0.85;}
.rec-library{margin-top:12px;}
.rec-library-title{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:6px;}
.rec-item{
  background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);
  border-radius:10px;padding:10px;margin-bottom:8px;
}
.rec-item video{width:100%;border-radius:6px;background:#000;display:block;margin-bottom:6px;}
.rec-item-meta{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;}
.rec-item-info{font-size:11px;color:var(--muted);}
.rec-item-actions{display:flex;gap:6px;}
.rec-item-actions button{
  padding:4px 10px;border-radius:6px;border:none;font-size:11px;
  font-family:inherit;cursor:pointer;display:flex;align-items:center;gap:4px;
}
.rec-item-dl{background:rgba(255,255,255,0.1);color:var(--ink);}
.rec-item-dl:hover{background:rgba(255,255,255,0.15);}
.rec-item-del{background:rgba(239,68,68,0.15);color:#ef4444;}
.rec-item-del:hover{background:rgba(239,68,68,0.25);}
.rec-empty{font-size:12px;color:var(--muted);text-align:center;padding:12px 0;}
.rec-item-trim{background:rgba(139,92,246,0.15);color:#a78bfa;}
.rec-item-trim:hover{background:rgba(139,92,246,0.25);}
.rec-trim-overlay{
  display:none;position:fixed;inset:0;z-index:2000;
  background:rgba(0,0,0,0.85);backdrop-filter:blur(8px);
  flex-direction:column;align-items:center;justify-content:center;padding:24px;
}
.rec-trim-overlay.visible{display:flex;}
.rec-trim-overlay video{
  max-width:min(90vw, 800px);max-height:55vh;width:auto;height:auto;
  border-radius:10px;background:#000;display:block;
}
.rec-trim-controls{
  width:min(90vw, 800px);margin-top:16px;
  background:rgba(30,33,48,0.95);border:1px solid rgba(255,255,255,0.1);
  border-radius:12px;padding:16px;
}
.rec-trim-times{display:flex;justify-content:space-between;font-size:12px;color:var(--muted);margin-bottom:8px;font-variant-numeric:tabular-nums;}
.rec-trim-track{position:relative;height:32px;background:rgba(255,255,255,0.08);border-radius:6px;cursor:pointer;touch-action:none;user-select:none;}
.rec-trim-range{position:absolute;top:0;height:100%;background:rgba(139,92,246,0.3);border-radius:6px;pointer-events:none;}
.rec-trim-handle{position:absolute;top:50%;width:18px;height:18px;background:#a78bfa;border:2px solid #fff;border-radius:50%;transform:translate(-50%,-50%);cursor:grab;touch-action:none;z-index:1;}
.rec-trim-handle:active{cursor:grabbing;background:#c4b5fd;}
.rec-trim-actions{display:flex;gap:8px;margin-top:12px;}
.rec-trim-actions button{flex:1;padding:8px 14px;border-radius:8px;border:none;font-size:13px;font-family:inherit;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:6px;font-weight:500;}
.rec-trim-save{background:rgba(139,92,246,0.4);color:#e0d4fc;}
.rec-trim-save:hover{background:rgba(139,92,246,0.55);}
.rec-trim-save:disabled{opacity:0.5;cursor:not-allowed;}
.rec-trim-cancel{background:rgba(255,255,255,0.1);color:var(--muted);}
.rec-trim-cancel:hover{background:rgba(255,255,255,0.15);}

/* RESPONSIVE */
@media (max-width:768px){
  .section-heading{font-size:2rem;}
  nav a{font-size:13px; margin:0 8px;}
  .snake-dpad{display:block;}
  .game-tab{padding:4px 10px;font-size:12px;}
}
</style>
</head>
<body>

<nav>
  <a href="/" data-en="Home" data-ro="Acasă">Home</a>
  <div class="nav-sep"></div>
  <button class="game-tab active" data-tab="0" data-en="Snake" data-ro="Snake">Snake</button>
  <button class="game-tab" data-tab="1" data-en="Day Trader" data-ro="Day Trader">Day Trader</button>
  <button class="game-tab" data-tab="2" data-en="Whiteboard" data-ro="Tablă">Whiteboard</button>
  <div class="nav-sep"></div>
  <button id="lang-toggle">RO</button>
</nav>

<section id="games" class="reveal">
  <div class="game-slider" id="game-slider">
    <div class="game-track" id="game-track">

      <!-- PANE 0: SNAKE -->
      <div class="game-pane">
        <div class="game-col">

    <!-- SNAKE -->
      <div class="game-toolbar">
        <div class="snake-score-bar">
          <div><span data-en="Score" data-ro="Scor">Score</span>: <span id="snake-score">0</span></div>
          <div><span data-en="Best" data-ro="Record">Best</span>: <span id="snake-high">0</span></div>
        </div>
        <div class="game-toolbar-btns">
          <button class="game-toolbar-btn" id="snake-settings-btn" title="Settings">&#9881;</button>
          <button class="game-toolbar-btn" id="snake-fullscreen-btn" title="Fullscreen"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 00-2 2v3"/><path d="M21 8V5a2 2 0 00-2-2h-3"/><path d="M3 16v3a2 2 0 002 2h3"/><path d="M16 21h3a2 2 0 002-2v-3"/></svg></button>
        </div>
      </div>
      <div class="snake-canvas-wrap" id="snake-wrap">
        <div class="game-settings-modal hidden" id="snake-settings-modal">
          <div class="game-settings-inner">
            <h4>Settings</h4>
            <div class="game-settings-row">
              <label>Speed</label>
              <select class="game-settings-select" id="ss-speed">
                <option value="slow">Slow</option>
                <option value="normal" selected>Normal</option>
                <option value="fast">Fast</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>Green Gems</label>
              <select class="game-settings-select" id="ss-gems">
                <option value="rare">Rare</option>
                <option value="normal" selected>Normal</option>
                <option value="frequent">Frequent</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>Purple Gems</label>
              <select class="game-settings-select" id="ss-shrink">
                <option value="rare">Rare</option>
                <option value="normal" selected>Normal</option>
                <option value="frequent">Frequent</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>Bombs</label>
              <select class="game-settings-select" id="ss-bombs">
                <option value="off">Off</option>
                <option value="rare">Rare</option>
                <option value="normal" selected>Normal</option>
                <option value="frequent">Frequent</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>Walls</label>
              <select class="game-settings-select" id="ss-walls">
                <option value="on" selected>Solid</option>
                <option value="off">Wrap Around</option>
              </select>
            </div>
            <button class="game-settings-close" id="ss-close">Close</button>
          </div>
        </div>
        <canvas id="snake-canvas" width="400" height="400"></canvas>
        <div class="snake-overlay" id="snake-overlay-start">
          <h3 data-en="Snake" data-ro="Snake">Snake</h3>
          <p data-en="Use arrow keys or WASD to play" data-ro="Folosește săgețile sau WASD">Use arrow keys or WASD to play</p>
          <button class="snake-btn" id="snake-start-btn" data-en="Start Game" data-ro="Începe Jocul">Start Game</button>
        </div>
        <div class="snake-overlay hidden" id="snake-overlay-pause">
          <h3 data-en="Paused" data-ro="Pauză">Paused</h3>
          <p data-en="Press Space or click to resume" data-ro="Apasă Space sau click pt. reluare">Press Space or click to resume</p>
          <button class="snake-btn" id="snake-resume-btn" data-en="Resume" data-ro="Reia">Resume</button>
        </div>
        <div class="snake-overlay hidden" id="snake-overlay-end">
          <h3 data-en="Game Over" data-ro="Joc Terminat">Game Over</h3>
          <div class="snake-final-score" id="snake-final-score">0</div>
          <button class="snake-btn" id="snake-restart-btn" data-en="Play Again" data-ro="Joacă Din Nou">Play Again</button>
        </div>
      </div>
      <div class="snake-dpad">
        <button class="d-up" data-dir="up">&#9650;</button>
        <button class="d-down" data-dir="down">&#9660;</button>
        <button class="d-left" data-dir="left">&#9664;</button>
        <button class="d-right" data-dir="right">&#9654;</button>
      </div>
      <div class="snake-leaderboard">
        <div class="lb-header">
          <h4 data-en="Best Scores" data-ro="Cele Mai Bune Scoruri">Best Scores</h4>
          <button class="lb-clear-btn" id="snake-clear-lb" title="Clear leaderboard"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/><path d="M19 6l-1 14a2 2 0 01-2 2H8a2 2 0 01-2-2L5 6"/></svg></button>
        </div>
        <table>
          <thead><tr>
            <th data-en="#" data-ro="#">#</th>
            <th data-en="Score" data-ro="Scor">Score</th>
            <th data-en="Date" data-ro="Data">Date</th>
          </tr></thead>
          <tbody id="snake-lb-body"></tbody>
        </table>
      </div>
        </div><!-- /game-col -->
      </div><!-- /game-pane 0 -->

      <!-- PANE 1: TRADING -->
      <div class="game-pane">
        <div class="game-col">
      <div class="trade-panel" id="trade-wrap">
        <h3 data-en="SPY Day Trader" data-ro="SPY Day Trader">SPY Day Trader</h3>
        <div class="game-toolbar-btns" style="position:absolute;top:12px;right:12px;z-index:3;">
          <button class="game-toolbar-btn" id="game-settings-btn" title="Settings">&#9881;</button>
          <button class="game-toolbar-btn" id="trade-fullscreen-btn" title="Fullscreen"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 00-2 2v3"/><path d="M21 8V5a2 2 0 00-2-2h-3"/><path d="M3 16v3a2 2 0 002 2h3"/><path d="M16 21h3a2 2 0 002-2v-3"/></svg></button>
        </div>
        <div class="game-settings-modal hidden" id="game-settings-modal">
          <div class="game-settings-inner">
            <h4>Settings</h4>
            <div class="game-settings-row">
              <label>Data Source</label>
              <select class="game-settings-select" id="ts-source">
                <option value="real">Real (Yahoo)</option>
                <option value="simulated">Simulated</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>Duration</label>
              <select class="game-settings-select" id="ts-duration">
                <option value="10">10s</option>
                <option value="30" selected>30s</option>
                <option value="60">60s</option>
                <option value="300">300s</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>P&amp;L Display</label>
              <select class="game-settings-select" id="ts-pnlmode">
                <option value="total">Total</option>
                <option value="split" selected>Realized + Unrealized</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>Position Tint</label>
              <select class="game-settings-select" id="ts-postint">
                <option value="on" selected>On</option>
                <option value="off">Off</option>
              </select>
            </div>
            <button class="game-settings-close" id="ts-close">Close</button>
          </div>
        </div>
        <div class="trade-timer"><div class="trade-timer-fill" id="trade-timer-fill"></div></div>
        <div class="trade-info">
          <div><small data-en="Price" data-ro="Preț">Price</small><span id="trade-price">—</span></div>
          <div><small data-en="Position" data-ro="Poziție">Position</small><span id="trade-pos">0</span></div>
          <div id="trade-pnl-total"><small data-en="P&amp;L" data-ro="Profit">P&amp;L</small><span id="trade-pnl">$0.00</span></div>
          <div id="trade-pnl-realized" style="display:none"><small>Realized</small><span id="trade-rpnl">$0.00</span></div>
          <div id="trade-pnl-unrealized" style="display:none"><small>Unrealized</small><span id="trade-upnl">$0.00</span></div>
        </div>
        <div class="trade-position-bar">
          <small>-1000</small>
          <div class="trade-pos-dots">
            <div class="trade-pos-dot" data-i="-10"></div>
            <div class="trade-pos-dot" data-i="-9"></div>
            <div class="trade-pos-dot" data-i="-8"></div>
            <div class="trade-pos-dot" data-i="-7"></div>
            <div class="trade-pos-dot" data-i="-6"></div>
            <div class="trade-pos-dot" data-i="-5"></div>
            <div class="trade-pos-dot" data-i="-4"></div>
            <div class="trade-pos-dot" data-i="-3"></div>
            <div class="trade-pos-dot" data-i="-2"></div>
            <div class="trade-pos-dot" data-i="-1"></div>
            <div class="trade-pos-dot zero" data-i="0"></div>
            <div class="trade-pos-dot" data-i="1"></div>
            <div class="trade-pos-dot" data-i="2"></div>
            <div class="trade-pos-dot" data-i="3"></div>
            <div class="trade-pos-dot" data-i="4"></div>
            <div class="trade-pos-dot" data-i="5"></div>
            <div class="trade-pos-dot" data-i="6"></div>
            <div class="trade-pos-dot" data-i="7"></div>
            <div class="trade-pos-dot" data-i="8"></div>
            <div class="trade-pos-dot" data-i="9"></div>
            <div class="trade-pos-dot" data-i="10"></div>
          </div>
          <small>+1000</small>
        </div>
        <div class="trade-canvas-wrap">
          <canvas id="trade-canvas" width="400" height="220"></canvas>
          <div class="trade-overlay" id="trade-overlay-start">
            <h3 data-en="SPY Day Trader" data-ro="SPY Day Trader">SPY Day Trader</h3>
            <p data-en="Trade simulated SPY in 30 seconds." data-ro="Tranzacționează SPY simulat în 30 de secunde.">Trade simulated SPY in 30 seconds.</p>
            <p style="font-size:0.8rem;color:var(--muted);margin-bottom:14px" data-en="&#9650;/&#9660; or buttons to trade &bull; Space to pause" data-ro="&#9650;/&#9660; sau butoane pt. tranzacții &bull; Space pt. pauză">&#9650;/&#9660; or buttons to trade &bull; Space to pause</p>
            <button class="trade-btn start" id="trade-start-btn" data-en="Start Trading" data-ro="Începe Tranzacția">Start Trading</button>
          </div>
          <div class="trade-overlay hidden" id="trade-overlay-pause">
            <h3 data-en="Paused" data-ro="Pauză">Paused</h3>
            <p data-en="Press Space or click to resume" data-ro="Apasă Space sau click pt. reluare">Press Space or click to resume</p>
            <div style="display:flex;gap:8px">
              <button class="trade-btn start" id="trade-resume-btn" data-en="Resume" data-ro="Reia">Resume</button>
              <button class="trade-btn end" id="trade-end-btn" data-en="End Session" data-ro="Încheie Sesiunea">End Session</button>
            </div>
          </div>
          <div class="trade-overlay hidden" id="trade-overlay-end">
            <h3 data-en="Market Closed" data-ro="Piața Închisă">Market Closed</h3>
            <div class="trade-result" id="trade-result">$0.00</div>
            <p id="trade-vol-info" style="font-size:0.85rem;color:var(--muted);margin-bottom:4px"></p>
            <p id="trade-date-info" style="font-size:0.85rem;color:var(--muted);margin-bottom:10px"></p>
            <button class="trade-btn start" id="trade-restart-btn" data-en="Trade Again" data-ro="Tranzacționează Din Nou">Trade Again</button>
          </div>
        </div>
        <div class="trade-paused-badge" id="trade-paused-badge" data-en="&#9208; PAUSED" data-ro="&#9208; PAUZĂ">&#9208; PAUSED</div>
        <div class="trade-btns">
          <button class="trade-btn buy" id="trade-buy-btn" disabled data-en="Buy +100 (&#9650;)" data-ro="Cumpără +100 (&#9650;)">Buy +100 (&#9650;)</button>
          <button class="trade-btn sell" id="trade-sell-btn" disabled data-en="Sell -100 (&#9660;)" data-ro="Vinde -100 (&#9660;)">Sell -100 (&#9660;)</button>
        </div>
        <div class="trade-hint" data-en="&#9650;/&#9660; Buy &amp; Sell &bull; <kbd>Space</kbd> Pause" data-ro="&#9650;/&#9660; Cumpără &amp; Vinde &bull; <kbd>Space</kbd> Pauză">&#9650;/&#9660; Buy &amp; Sell &bull; <kbd>Space</kbd> Pause</div>
        <div class="trade-log" id="trade-log" style="display:none">
          <h4>Trade Log</h4>
          <div class="trade-log-scroll">
            <table>
              <thead><tr>
                <th>Time</th>
                <th>Side</th>
                <th>Qty</th>
                <th>Price</th>
                <th>R. P&amp;L</th>
              </tr></thead>
              <tbody id="trade-log-body">
                <tr><td colspan="5" style="color:var(--muted);text-align:center;padding:12px 0">No trades yet</td></tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="trade-lb" id="trade-lb">
          <div class="lb-header">
            <h4 data-en="Best Sessions" data-ro="Cele Mai Bune Sesiuni">Best Sessions</h4>
            <button class="lb-clear-btn" id="trade-clear-lb" title="Clear leaderboard"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/><path d="M19 6l-1 14a2 2 0 01-2 2H8a2 2 0 01-2-2L5 6"/></svg></button>
          </div>
          <table>
            <thead><tr>
              <th data-en="#" data-ro="#">#</th>
              <th data-en="P&amp;L" data-ro="Profit">P&amp;L</th>
              <th data-en="Vol" data-ro="Vol">Vol</th>
              <th data-en="Date" data-ro="Data">Date</th>
            </tr></thead>
            <tbody id="trade-lb-body"></tbody>
          </table>
        </div>
      </div>
        </div><!-- /game-col -->
      </div><!-- /game-pane 1 -->

      <!-- PANE 2: WHITEBOARD -->
      <div class="game-pane" style="padding:0 16px">
  <div class="wb-wrap" id="wb-wrap">
    <div class="wb-toolbar" id="wb-toolbar">
      <span style="font-size:13px;font-weight:600;color:var(--ink);margin-right:6px" data-en="Whiteboard" data-ro="Tablă">Whiteboard</span>
      <div class="wb-sep"></div>
      <div class="wb-toolbar-group" id="wb-colors">
        <button class="wb-color-btn active" data-color="#f5f7fa" style="background:#f5f7fa" title="White"></button>
        <button class="wb-color-btn" data-color="#ef4444" style="background:#ef4444" title="Red"></button>
        <button class="wb-color-btn" data-color="#fbbf24" style="background:#fbbf24" title="Yellow"></button>
        <button class="wb-color-btn" data-color="#34d399" style="background:#34d399" title="Green"></button>
        <button class="wb-color-btn" data-color="#4f8cff" style="background:#4f8cff" title="Blue"></button>
        <button class="wb-color-btn" data-color="#a855f7" style="background:#a855f7" title="Purple"></button>
        <input type="color" class="wb-color-picker" id="wb-custom-color" value="#ff6b6b" title="Custom color">
      </div>
      <div class="wb-sep"></div>
      <div class="wb-toolbar-group">
        <input type="range" class="wb-size-slider" id="wb-size" min="1" max="32" value="3">
        <span class="wb-size-label" id="wb-size-label">3</span>
      </div>
      <div class="wb-sep"></div>
      <div class="wb-toolbar-group">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="opacity:0.5;flex-shrink:0"><circle cx="12" cy="12" r="10"/><path d="M12 2a10 10 0 010 20z" fill="currentColor" stroke="none"/></svg>
        <input type="range" class="wb-opacity-slider" id="wb-opacity" min="10" max="100" value="100">
        <span class="wb-size-label" id="wb-opacity-label">100%</span>
      </div>
      <div class="wb-toolbar-right">
        <button class="wb-btn" id="wb-undo-btn" title="Undo (Ctrl+Z)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13"/></svg></button>
        <button class="wb-btn" id="wb-redo-btn" title="Redo (Ctrl+Y)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 019-9 9 9 0 016 2.3l3 2.7"/></svg></button>
        <button class="wb-btn" id="wb-clear-btn" title="Clear All"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg></button>
        <div class="wb-sep"></div>
        <div class="wb-collab" id="wb-collab">
          <input class="wb-collab-input" id="wb-room-input" placeholder="Room name">
          <button class="wb-btn" id="wb-connect-btn" title="Connect to room"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h4a2 2 0 012 2v14a2 2 0 01-2 2h-4"/><polyline points="10 17 15 12 10 7"/><line x1="15" y1="12" x2="3" y2="12"/></svg></button>
          <span class="wb-collab-status" id="wb-collab-status" style="display:none"><span class="wb-collab-dot" id="wb-collab-dot"></span><svg id="wb-host-icon" style="display:none" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 4l3 12h14l3-12-6 7-4-7-4 7-6-7z"/><path d="M3 20h18"/></svg><span id="wb-collab-text"></span></span>
          <span class="wb-collab-peers" id="wb-collab-peers" style="display:none"></span>
          <button class="wb-btn" id="wb-disconnect-btn" style="display:none" title="Disconnect"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg></button>
        </div>
        <div class="wb-sep"></div>
        <div style="position:relative;display:flex;align-items:center;gap:3px">
          <button class="wb-btn wb-ai-btn" id="wb-ai-btn" title="AI Guess (right-click to change key)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9.937 15.5A2 2 0 008.5 14.063l-6.135-1.582a.5.5 0 010-.962L8.5 9.936A2 2 0 009.937 8.5l1.582-6.135a.5.5 0 01.963 0L14.063 8.5A2 2 0 0015.5 9.937l6.135 1.581a.5.5 0 010 .964L15.5 14.063a2 2 0 00-1.437 1.437l-1.582 6.135a.5.5 0 01-.963 0z"/></svg></button>
          <button class="wb-btn wb-ai-btn" id="wb-ai-draw-btn" title="AI Draw (right-click to change key)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 3-1.9 5.8a2 2 0 01-1.287 1.288L3 12l5.8 1.9a2 2 0 011.288 1.288L12 21l1.9-5.8a2 2 0 011.287-1.288L21 12l-5.8-1.9a2 2 0 01-1.288-1.288z"/><path d="M2 8V2h6"/></svg></button>
          <div class="wb-ai-popover" id="wb-ai-popover">
            <label>OpenAI API Key</label>
            <input type="password" id="wb-ai-key" placeholder="sk-..." spellcheck="false" autocomplete="off">
            <div class="wb-ai-row">
              <button class="wb-ai-save" id="wb-ai-save">Save</button>
              <span class="wb-ai-status" id="wb-ai-status">Stored locally only</span>
            </div>
          </div>
          <div class="wb-ai-draw-popover" id="wb-ai-draw-popover">
            <label>Describe what to draw</label>
            <input type="text" id="wb-ai-draw-prompt" placeholder="e.g. a cat sitting on a fence" spellcheck="false" autocomplete="off">
            <div class="wb-ai-draw-row">
              <button class="wb-ai-draw-go" id="wb-ai-draw-go">Draw</button>
              <span class="wb-ai-draw-status" id="wb-ai-draw-status"></span>
            </div>
          </div>
        </div>
        <div class="wb-sep"></div>
        <button class="wb-btn" id="wb-fullscreen-btn" title="Fullscreen"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></svg></button>
        <div style="position:relative">
          <button class="wb-btn" id="wb-more-btn" title="More options"><svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><circle cx="12" cy="5" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="19" r="2"/></svg></button>
          <div class="wb-more-popover" id="wb-more-popover">
            <label class="wb-more-item"><input type="checkbox" id="wb-fill-check"> Fill shapes</label>
            <label class="wb-more-item"><input type="checkbox" id="wb-grid-check"> Show grid</label>
            <div class="wb-more-sep"></div>
            <button class="wb-more-item wb-more-action" id="wb-download-btn"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v12"/><path d="m8 11 4 4 4-4"/><path d="M8 5H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V7a2 2 0 00-2-2h-4"/></svg> Save as PNG</button>
          </div>
        </div>
      </div>
    </div>
    <div class="wb-chat-row">
      <div class="wb-canvas-area" id="wb-canvas-area">
        <div class="wb-sidebar" id="wb-sidebar">
          <div class="wb-toolbar-group" id="wb-tools">
            <button class="wb-btn active" data-tool="pen" title="Pen (P)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.174 6.812a1 1 0 00-3.986-3.987L3.842 16.174a2 2 0 00-.5.83l-1.321 4.352a.5.5 0 00.623.622l4.353-1.32a2 2 0 00.83-.497z"/></svg></button>
            <button class="wb-btn" data-tool="line" title="Line (L)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M4 20L20 4"/></svg></button>
            <button class="wb-btn" data-tool="rect" title="Rectangle (R)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/></svg></button>
            <button class="wb-btn" data-tool="ellipse" title="Ellipse (E)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="10"/></svg></button>
            <button class="wb-btn" data-tool="arrow" title="Arrow (A)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></button>
            <div class="wb-sep"></div>
            <button class="wb-btn" data-tool="highlighter" title="Highlighter (H)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 11-6 6v3h9l3-3"/><path d="m22 12-4.6 4.6a2 2 0 01-2.8 0l-5.2-5.2a2 2 0 010-2.8L14 4"/></svg></button>
            <button class="wb-btn" data-tool="text" title="Text (T)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 7V4h16v3"/><path d="M9 20h6"/><path d="M12 4v16"/></svg></button>
            <div class="wb-sep"></div>
            <button class="wb-btn" data-tool="eraser" title="Eraser (X)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg></button>
            <button class="wb-btn" data-tool="hand" title="Hand / Pan (G or Space+drag)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 11V6a2 2 0 10-4 0v5"/><path d="M14 10V4a2 2 0 10-4 0v6"/><path d="M10 9.5V4a2 2 0 10-4 0v10"/><path d="M18 11a2 2 0 114 0v3a8 8 0 01-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.66-3.66a2 2 0 112.83-2.83L7 15"/></svg></button>
          </div>
        </div>
        <canvas id="wb-canvas" width="1200" height="600"></canvas>
        <canvas id="wb-grid" class="wb-grid-canvas" width="1200" height="600"></canvas>
        <div class="wb-ai-guess" id="wb-ai-guess"><span class="wb-ai-icon"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M9.937 15.5A2 2 0 008.5 14.063l-6.135-1.582a.5.5 0 010-.962L8.5 9.936A2 2 0 009.937 8.5l1.582-6.135a.5.5 0 01.963 0L14.063 8.5A2 2 0 0015.5 9.937l6.135 1.581a.5.5 0 010 .964L15.5 14.063a2 2 0 00-1.437 1.437l-1.582 6.135a.5.5 0 01-.963 0z"/></svg></span><span id="wb-ai-guess-text"></span></div>
        <button class="wb-chat-toggle" id="wb-chat-toggle" style="display:none" title="Toggle chat"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg></button>
        <div class="wb-chat" id="wb-chat" style="display:none">
          <div class="wb-chat-header">
            Chat
            <input class="wb-chat-nick" id="wb-chat-nick" placeholder="Nickname" spellcheck="false" autocomplete="off">
          </div>
          <div class="wb-chat-msgs" id="wb-chat-msgs"></div>
          <div class="wb-chat-input-row">
            <input class="wb-chat-input" id="wb-chat-input" placeholder="Type a message..." spellcheck="false" autocomplete="off">
            <button class="wb-chat-send" id="wb-chat-send" title="Send"><svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg></button>
          </div>
        </div>
      </div>
    </div>
  </div>
      </div><!-- /game-pane 2 -->

    </div><!-- /game-track -->
  </div><!-- /game-slider -->

</section>

<!-- Screen Recorder -->
<button class="rec-fab" id="rec-fab" title="Record screen">
  <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="4" fill="currentColor" stroke="none"/></svg>
</button>
<div class="rec-panel" id="rec-panel">
  <div class="rec-panel-header">
    <span class="rec-panel-title" id="rec-panel-title">Screen Recorder</span>
    <button class="rec-panel-close" id="rec-panel-close">&times;</button>
  </div>
  <div class="rec-timer" id="rec-timer" style="display:none">00:00</div>
  <div class="rec-actions" id="rec-actions">
    <button class="rec-btn-rec" id="rec-start">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none"><circle cx="12" cy="12" r="10"/></svg>
      Record
    </button>
  </div>
  <div class="rec-library" id="rec-library"></div>
</div>

<footer class="reveal">
  © 2025 TATOMIR N. ALEX PFA. All rights reserved.
</footer>

<script src="data/spy_data.js"></script>
<script src="https://unpkg.com/peerjs@1/dist/peerjs.min.js"></script>
<script>
// Reveal animations
const observer = new IntersectionObserver(entries=>{
  entries.forEach(e=>{
    if(e.isIntersecting) e.target.classList.add("visible");
  });
},{threshold:0.15});
document.querySelectorAll('.reveal').forEach(el=>observer.observe(el));

// Language toggle
const toggle = document.getElementById('lang-toggle');
let lang = 'en';
toggle.addEventListener('click', ()=>{
  lang = lang === 'en' ? 'ro' : 'en';
  toggle.textContent = lang === 'en' ? 'RO' : 'EN';
  document.querySelectorAll('[data-en]').forEach(el=>{
    el.textContent = el.getAttribute(`data-${lang}`);
  });
});

// Game Tabs
(function(){
  const tabs = document.querySelectorAll('nav .game-tab');
  const track = document.getElementById('game-track');
  let current = 0;

  function switchTab(idx){
    if(idx === current) return;
    current = idx;
    track.style.transform = `translateX(-${idx * 100}%)`;
    tabs.forEach(t => t.classList.toggle('active', parseInt(t.dataset.tab) === idx));
    try { sessionStorage.setItem('game-tab', idx); } catch(e){}
  }

  tabs.forEach(tab => {
    tab.addEventListener('click', () => switchTab(parseInt(tab.dataset.tab)));
  });

  // Restore tab from session (skip transition on load)
  try {
    const saved = parseInt(sessionStorage.getItem('game-tab'));
    if(saved > 0 && saved < tabs.length){
      track.style.transition = 'none';
      current = -1;
      switchTab(saved);
      // Re-enable transition after paint
      requestAnimationFrame(() => { track.style.transition = ''; });
    }
  } catch(e){}
})();

// Snake Game
(function(){
  const canvas = document.getElementById('snake-canvas');
  const ctx = canvas.getContext('2d');
  let SIZE = 20;
  const COLS = canvas.width / SIZE;
  const ROWS = canvas.height / SIZE;
  const BOMB_LIFETIME = 8000;

  // Settings
  const SNAKE_DEFAULTS = { speed:'normal', gems:'normal', shrink:'normal', bombs:'normal', walls:'on' };
  function loadSnakeSettings(){ try { return Object.assign({}, SNAKE_DEFAULTS, JSON.parse(localStorage.getItem('snakeSettings'))); } catch(e){ return Object.assign({}, SNAKE_DEFAULTS); } }
  function saveSnakeSettings(s){ localStorage.setItem('snakeSettings', JSON.stringify(s)); }
  let snakeSettings = loadSnakeSettings();

  function getSpeedParams(){
    const map = { slow:[180,0.5,80], normal:[140,1,60], fast:[100,2,40] };
    const [base, step, min] = map[snakeSettings.speed] || map.normal;
    return { BASE_SPEED:base, SPEED_STEP:step, MIN_SPEED:min };
  }
  function getSpawnDelay(setting){
    const map = { rare:[8000,12000], normal:[4000,6000], frequent:[1500,3000] };
    return map[setting] || map.normal;
  }

  function applySnakeSettingsUI(){
    document.getElementById('ss-speed').value = snakeSettings.speed;
    document.getElementById('ss-gems').value = snakeSettings.gems;
    document.getElementById('ss-shrink').value = snakeSettings.shrink;
    document.getElementById('ss-bombs').value = snakeSettings.bombs;
    document.getElementById('ss-walls').value = snakeSettings.walls;
  }
  applySnakeSettingsUI();

  let snake, dir, dirQueue, food, score, highScore, speed, loop, running, paused;
  let gem, gemTimer, bombs, bombTimer, bombTimers;
  let shrinkGem, shrinkGemTimer;

  highScore = parseInt(localStorage.getItem('snakeHigh') || '0');
  document.getElementById('snake-high').textContent = highScore;

  function loadLB(){
    let lb = JSON.parse(localStorage.getItem('snakeLB') || '[]');
    // Migrate old formats to {score, date}
    if(lb.length && typeof lb[0] === 'object' && lb[0].name) lb = lb.map(e=>({score:e.score, date:null}));
    else if(lb.length && typeof lb[0] === 'number') lb = lb.map(e=>({score:e, date:null}));
    return lb;
  }
  function saveLB(lb){ localStorage.setItem('snakeLB', JSON.stringify(lb)); }
  function fmtDate(d){ if(!d) return '—'; const dt=new Date(d); return dt.toLocaleDateString('en-US',{month:'short',day:'numeric'})+' '+dt.toLocaleTimeString('en-US',{hour:'numeric',minute:'2-digit'}); }
  function renderLB(){
    const lb = loadLB();
    const tbody = document.getElementById('snake-lb-body');
    tbody.innerHTML = lb.length === 0
      ? '<tr><td colspan="3" style="color:var(--muted);text-align:center;padding:12px 0">—</td></tr>'
      : lb.map((e,i)=>`<tr><td>${i+1}</td><td>${e.score}</td><td style="color:var(--muted);font-size:11px">${fmtDate(e.date)}</td></tr>`).join('');
  }
  renderLB();

  function isFree(pos){
    if(snake.some(s=>s.x===pos.x&&s.y===pos.y)) return false;
    if(food&&food.x===pos.x&&food.y===pos.y) return false;
    if(gem&&gem.x===pos.x&&gem.y===pos.y) return false;
    if(shrinkGem&&shrinkGem.x===pos.x&&shrinkGem.y===pos.y) return false;
    if(bombs.some(b=>b.x===pos.x&&b.y===pos.y)) return false;
    return true;
  }
  function randFreePos(){
    let pos;
    do { pos={x:Math.floor(Math.random()*COLS),y:Math.floor(Math.random()*ROWS)}; } while(!isFree(pos));
    return pos;
  }
  function placeFood(){ food = randFreePos(); }

  function spawnGem(){
    gem = randFreePos();
    if(gemTimer) clearTimeout(gemTimer);
    gemTimer = setTimeout(()=>{ gem=null; scheduleGem(); }, 4000+Math.random()*2000);
  }
  function scheduleGem(){
    if(!running||paused) return;
    const [base,range] = getSpawnDelay(snakeSettings.gems);
    gemTimer = setTimeout(()=>{ if(running&&!paused) spawnGem(); }, base+Math.random()*range);
  }
  function isInFrontOfSnake(pos){
    if(!snake||!snake.length||!dir) return false;
    const head = snake[0];
    for(let i=1;i<=4;i++){
      let fx = head.x + dir.x * i;
      let fy = head.y + dir.y * i;
      if(snakeSettings.walls === 'off'){
        fx = ((fx % COLS) + COLS) % COLS;
        fy = ((fy % ROWS) + ROWS) % ROWS;
      }
      if(pos.x === fx && pos.y === fy) return true;
    }
    return false;
  }
  function randFreePosForBomb(){
    let pos, attempts = 0;
    do {
      pos = {x:Math.floor(Math.random()*COLS),y:Math.floor(Math.random()*ROWS)};
      attempts++;
    } while((!isFree(pos) || isInFrontOfSnake(pos)) && attempts < 200);
    return isFree(pos) ? pos : null;
  }
  function spawnBomb(){
    if(!running||paused) return;
    if(snakeSettings.bombs === 'off') return;
    if(bombs.length<3){
      const b = randFreePosForBomb();
      if(!b){ scheduleBomb(); return; }
      bombs.push(b);
      const timer = setTimeout(()=>{
        const idx = bombs.indexOf(b);
        if(idx !== -1) bombs.splice(idx, 1);
        const ti = bombTimers.indexOf(timer);
        if(ti !== -1) bombTimers.splice(ti, 1);
        if(running&&!paused) draw();
      }, BOMB_LIFETIME);
      bombTimers.push(timer);
    }
    scheduleBomb();
  }
  function scheduleBomb(){
    if(!running||paused||snakeSettings.bombs==='off') return;
    const [base,range] = getSpawnDelay(snakeSettings.bombs);
    bombTimer = setTimeout(()=>{ if(running&&!paused) spawnBomb(); }, base+Math.random()*range);
  }

  function spawnShrinkGem(){
    shrinkGem = randFreePos();
    if(shrinkGemTimer) clearTimeout(shrinkGemTimer);
    shrinkGemTimer = setTimeout(()=>{ shrinkGem=null; scheduleShrinkGem(); }, 3000+Math.random()*2000);
  }
  function scheduleShrinkGem(){
    if(!running||paused) return;
    const [base,range] = getSpawnDelay(snakeSettings.shrink);
    shrinkGemTimer = setTimeout(()=>{ if(running&&!paused) spawnShrinkGem(); }, base+Math.random()*range);
  }

  function clearAllTimers(){
    if(gemTimer) clearTimeout(gemTimer);
    if(bombTimer) clearTimeout(bombTimer);
    if(bombTimers) bombTimers.forEach(t=>clearTimeout(t));
    if(shrinkGemTimer) clearTimeout(shrinkGemTimer);
  }

  function togglePause(){
    if(!running) return;
    if(paused){
      paused = false;
      loop = setInterval(tick, speed);
      document.getElementById('snake-overlay-pause').classList.add('hidden');
      scheduleGem(); scheduleBomb(); scheduleShrinkGem();
    } else {
      paused = true;
      clearInterval(loop);
      if(gemTimer) clearTimeout(gemTimer);
      if(bombTimer) clearTimeout(bombTimer);
      document.getElementById('snake-overlay-pause').classList.remove('hidden');
    }
  }

  function startGame(){
    snakeSettings = loadSnakeSettings();
    const sp = getSpeedParams();
    snake = [{x:Math.floor(COLS/2), y:Math.floor(ROWS/2)}];
    dir = {x:1,y:0}; dirQueue = [];
    score = 0; speed = sp.BASE_SPEED; running = true; paused = false;
    gem = null; shrinkGem = null; bombs = []; bombTimers = [];
    clearAllTimers();
    document.getElementById('snake-score').textContent = 0;
    placeFood(); scheduleGem(); scheduleBomb(); scheduleShrinkGem();
    document.getElementById('snake-overlay-start').classList.add('hidden');
    document.getElementById('snake-overlay-end').classList.add('hidden');
    document.getElementById('snake-overlay-pause').classList.add('hidden');
    document.getElementById('snake-settings-modal').classList.add('hidden');
    if(loop) clearInterval(loop);
    loop = setInterval(tick, speed);
  }

  function tick(){
    if(dirQueue.length) dir = dirQueue.shift();
    const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};
    if(snakeSettings.walls === 'off'){
      if(head.x < 0) head.x = COLS - 1;
      else if(head.x >= COLS) head.x = 0;
      if(head.y < 0) head.y = ROWS - 1;
      else if(head.y >= ROWS) head.y = 0;
    } else {
      if(head.x<0||head.x>=COLS||head.y<0||head.y>=ROWS){ gameOver(); return; }
    }
    if(snake.some(s=>s.x===head.x&&s.y===head.y)){ gameOver(); return; }
    if(bombs.some(b=>b.x===head.x&&b.y===head.y)){ gameOver(); return; }
    snake.unshift(head);
    let ate = false;
    let ateGem = false;
    if(head.x===food.x&&head.y===food.y){ score++; ate = true; placeFood(); }
    if(gem&&head.x===gem.x&&head.y===gem.y){
      score += 3; ateGem = true; gem = null;
      if(gemTimer) clearTimeout(gemTimer);
      scheduleGem();
    }
    let ateShrink = false;
    if(shrinkGem&&head.x===shrinkGem.x&&head.y===shrinkGem.y){
      score += 2; ateShrink = true; shrinkGem = null;
      if(shrinkGemTimer) clearTimeout(shrinkGemTimer);
      scheduleShrinkGem();
      // Shrink: remove tail segments but keep at least 1
      const removeCount = Math.min(3, snake.length - 1);
      for(let r=0;r<removeCount;r++) snake.pop();
    }
    if(ate || ateGem || ateShrink){
      document.getElementById('snake-score').textContent = score;
      if(score>highScore){
        highScore = score;
        localStorage.setItem('snakeHigh', highScore);
        document.getElementById('snake-high').textContent = highScore;
      }
    }
    if(ate || ateGem){
      const sp = getSpeedParams();
      const newSpeed = Math.max(sp.MIN_SPEED, sp.BASE_SPEED - score * sp.SPEED_STEP);
      if(newSpeed !== speed){ speed = newSpeed; clearInterval(loop); loop = setInterval(tick, speed); }
    } else if(!ateShrink) { snake.pop(); }
    draw();
  }

  function draw(){
    ctx.fillStyle = '#0b0d10';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    for(let x=0;x<=COLS;x++){ctx.beginPath();ctx.moveTo(x*SIZE,0);ctx.lineTo(x*SIZE,canvas.height);ctx.stroke();}
    for(let y=0;y<=ROWS;y++){ctx.beginPath();ctx.moveTo(0,y*SIZE);ctx.lineTo(canvas.width,y*SIZE);ctx.stroke();}
    ctx.fillStyle = '#fbbf24';
    ctx.beginPath(); ctx.arc(food.x*SIZE+SIZE/2, food.y*SIZE+SIZE/2, SIZE/2-2, 0, Math.PI*2); ctx.fill();
    if(gem){
      const gx=gem.x*SIZE+SIZE/2, gy=gem.y*SIZE+SIZE/2, gr=SIZE/2-2;
      ctx.fillStyle='#34d399';
      ctx.beginPath(); ctx.moveTo(gx,gy-gr); ctx.lineTo(gx+gr,gy); ctx.lineTo(gx,gy+gr); ctx.lineTo(gx-gr,gy);
      ctx.closePath(); ctx.fill();
      ctx.shadowColor='#34d399'; ctx.shadowBlur=8; ctx.fill(); ctx.shadowBlur=0;
    }
    if(shrinkGem){
      const sx=shrinkGem.x*SIZE+SIZE/2, sy=shrinkGem.y*SIZE+SIZE/2, sr=SIZE/2-1;
      ctx.fillStyle='#a855f7';
      ctx.beginPath();
      for(let i=0;i<6;i++){const a=Math.PI/6+i*Math.PI/3;ctx.lineTo(sx+sr*Math.cos(a),sy+sr*Math.sin(a));}
      ctx.closePath(); ctx.fill();
      ctx.shadowColor='#a855f7'; ctx.shadowBlur=8; ctx.fill(); ctx.shadowBlur=0;
    }
    bombs.forEach(b=>{
      ctx.fillStyle='#ef4444';
      ctx.fillRect(b.x*SIZE+2, b.y*SIZE+2, SIZE-4, SIZE-4);
      ctx.strokeStyle='#0b0d10'; ctx.lineWidth=2;
      const bx=b.x*SIZE+SIZE/2, by=b.y*SIZE+SIZE/2;
      ctx.beginPath(); ctx.moveTo(bx-3,by-3); ctx.lineTo(bx+3,by+3); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(bx+3,by-3); ctx.lineTo(bx-3,by+3); ctx.stroke();
      ctx.lineWidth=1;
    });
    snake.forEach((s,i)=>{
      ctx.fillStyle = i===0 ? '#4f8cff' : 'rgba(79,140,255,0.65)';
      ctx.beginPath(); ctx.roundRect(s.x*SIZE+1, s.y*SIZE+1, SIZE-2, SIZE-2, 4); ctx.fill();
    });
  }
  ctx.fillStyle='#0b0d10';ctx.fillRect(0,0,canvas.width,canvas.height);

  function gameOver(){
    running = false; clearInterval(loop);
    clearAllTimers();
    document.getElementById('snake-final-score').textContent = score;
    document.getElementById('snake-overlay-end').classList.remove('hidden');
    // Save score to leaderboard
    const lb = loadLB(); lb.push({score, date: new Date().toISOString()});
    lb.sort((a,b)=>b.score-a.score); if(lb.length>5) lb.length=5;
    saveLB(lb); renderLB();
  }

  const DIR_MAP = {
    ArrowUp:{x:0,y:-1},ArrowDown:{x:0,y:1},ArrowLeft:{x:-1,y:0},ArrowRight:{x:1,y:0},
    w:{x:0,y:-1},s:{x:0,y:1},a:{x:-1,y:0},d:{x:1,y:0},
    W:{x:0,y:-1},S:{x:0,y:1},A:{x:-1,y:0},D:{x:1,y:0}
  };
  document.addEventListener('keydown', e=>{
    if((e.key===' '||e.key==='Escape') && running){ togglePause(); e.preventDefault(); return; }
    if(!running||paused) return;
    const d = DIR_MAP[e.key];
    if(d){
      const last = dirQueue.length ? dirQueue[dirQueue.length-1] : dir;
      if(d.x !== -last.x || d.y !== -last.y){ dirQueue.push(d); if(dirQueue.length>4) dirQueue.shift(); }
      e.preventDefault();
    }
  });

  document.querySelectorAll('.snake-dpad button').forEach(btn=>{
    const dirName = btn.dataset.dir;
    const map = {up:{x:0,y:-1},down:{x:0,y:1},left:{x:-1,y:0},right:{x:1,y:0}};
    btn.addEventListener('touchstart', e=>{ e.preventDefault(); if(!running||paused) return; const d=map[dirName]; const last=dirQueue.length?dirQueue[dirQueue.length-1]:dir; if(d.x!==-last.x||d.y!==-last.y){dirQueue.push(d);if(dirQueue.length>4)dirQueue.shift();} });
    btn.addEventListener('mousedown', ()=>{ if(!running||paused) return; const d=map[dirName]; const last=dirQueue.length?dirQueue[dirQueue.length-1]:dir; if(d.x!==-last.x||d.y!==-last.y){dirQueue.push(d);if(dirQueue.length>4)dirQueue.shift();} });
  });

  document.getElementById('snake-start-btn').addEventListener('click', startGame);
  document.getElementById('snake-restart-btn').addEventListener('click', startGame);
  document.getElementById('snake-resume-btn').addEventListener('click', togglePause);
  document.getElementById('snake-clear-lb').addEventListener('click', ()=>{
    if(confirm('Clear the snake leaderboard?')){
      localStorage.removeItem('snakeLB');
      renderLB();
    }
  });

  // Snake settings modal
  document.getElementById('snake-settings-btn').addEventListener('click', ()=>{
    if(running && !paused) togglePause();
    document.getElementById('snake-settings-modal').classList.remove('hidden');
  });
  document.getElementById('ss-close').addEventListener('click', ()=>{
    snakeSettings.speed = document.getElementById('ss-speed').value;
    snakeSettings.gems = document.getElementById('ss-gems').value;
    snakeSettings.shrink = document.getElementById('ss-shrink').value;
    snakeSettings.bombs = document.getElementById('ss-bombs').value;
    snakeSettings.walls = document.getElementById('ss-walls').value;
    saveSnakeSettings(snakeSettings);
    document.getElementById('snake-settings-modal').classList.add('hidden');
  });

  // Fullscreen
  document.getElementById('snake-fullscreen-btn').addEventListener('click', ()=>{
    const el = document.getElementById('snake-wrap');
    if(!document.fullscreenElement) el.requestFullscreen().catch(()=>{});
    else document.exitFullscreen();
  });
  document.addEventListener('fullscreenchange', ()=>{
    const wrap = document.getElementById('snake-wrap');
    if(document.fullscreenElement === wrap){
      const maxW = window.innerWidth;
      const maxH = window.innerHeight;
      SIZE = Math.floor(Math.min(maxW / COLS, maxH / ROWS));
      canvas.width = COLS * SIZE;
      canvas.height = ROWS * SIZE;
    } else {
      SIZE = 20;
      canvas.width = COLS * SIZE;
      canvas.height = ROWS * SIZE;
    }
    draw();
  });
})();

// Trading Game
(function(){
  const canvas = document.getElementById('trade-canvas');
  const ctx = canvas.getContext('2d');
  let W = canvas.width, H = canvas.height;
  const TICK = 100;
  const MULTIPLIER = 100;
  const MAX_POS = 10;

  // Settings
  const DEFAULT_SETTINGS = { dataSource: 'real', duration: 30, pnlMode: 'split', posTint: true };
  function loadSettings(){ try { return Object.assign({}, DEFAULT_SETTINGS, JSON.parse(localStorage.getItem('tradeSettings'))); } catch(e){ return Object.assign({}, DEFAULT_SETTINGS); } }
  function saveSettings(s){ localStorage.setItem('tradeSettings', JSON.stringify(s)); }
  let settings = loadSettings();
  let DURATION = settings.duration * 1000;
  let TOTAL_TICKS = DURATION / TICK;

  // Apply settings to UI
  function applySettingsUI(){
    document.getElementById('ts-source').value = settings.dataSource;
    document.getElementById('ts-duration').value = settings.duration;
    document.getElementById('ts-pnlmode').value = settings.pnlMode;
    document.getElementById('ts-postint').value = settings.posTint ? 'on' : 'off';
  }
  applySettingsUI();

  let prices, currentTick, position, pnl, running, paused, loop, tradingDate;
  let totalCost, avgPrice; // cost basis tracking
  let realizedPnl; // for split PnL mode
  let posHistory; // position at each tick for tinting
  let tradedVolume; // total $ volume traded

  function generateSimulatedPrices(){
    tradingDate = 'Simulated';
    const base = 450 + Math.random() * 150; // ~$450-$600
    const dailyVol = 0.01;
    const tickVol = dailyVol / Math.sqrt(TOTAL_TICKS);
    const pts = [base];
    for(let i = 1; i <= TOTAL_TICKS; i++){
      const ret = (Math.random() + Math.random() + Math.random() - 1.5) * tickVol;
      pts.push(pts[i-1] * (1 + ret));
    }
    return pts;
  }

  function fetchRealPrices(){
    if(settings.dataSource === 'simulated') return generateSimulatedPrices();
    // Pick a random trading day from the bundled data
    const idx = Math.floor(Math.random() * window.SPY_DATA.length);
    const [date, dayPrices] = window.SPY_DATA[idx];
    tradingDate = date;

    // Resample to TOTAL_TICKS+1 points via linear interpolation
    const resampled = [];
    for(let i = 0; i <= TOTAL_TICKS; i++){
      const t = i * (dayPrices.length - 1) / TOTAL_TICKS;
      const lo = Math.floor(t);
      const hi = Math.min(lo + 1, dayPrices.length - 1);
      const frac = t - lo;
      resampled.push(dayPrices[lo] * (1 - frac) + dayPrices[hi] * frac);
    }
    return resampled;
  }

  function loadTradeLB(){
    let lb = JSON.parse(localStorage.getItem('tradeLB')||'[]');
    // Migrate old formats
    if(lb.length && typeof lb[0] === 'number') lb = lb.map(e=>({pnl:e, date:null, vol:0}));
    else if(lb.length && typeof lb[0] === 'object' && lb[0].vol === undefined) lb = lb.map(e=>({...e, vol:0}));
    return lb;
  }
  function saveTradeLB(lb){ localStorage.setItem('tradeLB',JSON.stringify(lb)); }
  function fmtTradeDate(d){ if(!d) return '—'; const dt=new Date(d); return dt.toLocaleDateString('en-US',{month:'short',day:'numeric'})+' '+dt.toLocaleTimeString('en-US',{hour:'numeric',minute:'2-digit'}); }
  function fmtVol(v){
    if(!v) return '—';
    if(v>=1e6) return '$'+(v/1e6).toFixed(1)+'M';
    if(v>=1e3) return '$'+(v/1e3).toFixed(0)+'K';
    return '$'+v.toFixed(0);
  }
  function renderTradeLB(){
    const lb = loadTradeLB();
    const tbody = document.getElementById('trade-lb-body');
    tbody.innerHTML = lb.length===0
      ? '<tr><td colspan="4" style="color:var(--muted);text-align:center;padding:12px 0">—</td></tr>'
      : lb.map((e,i)=>{
        const cls = e.pnl>=0?'pnl-pos':'pnl-neg';
        const sign = e.pnl>=0?'+':'-';
        return `<tr><td>${i+1}</td><td class="${cls}">${sign}$${Math.abs(e.pnl).toFixed(2)}</td><td style="color:var(--muted);font-size:11px">${fmtVol(e.vol)}</td><td style="color:var(--muted);font-size:11px">${fmtTradeDate(e.date)}</td></tr>`;
      }).join('');
  }
  renderTradeLB();

  let tradeLog = [];
  function formatTradeTime(tick){
    if(settings.dataSource === 'simulated'){
      return (tick * TICK / 1000).toFixed(1) + 's';
    }
    // Map tick to market hours 9:30–16:00
    const frac = tick / TOTAL_TICKS;
    const hours = 9.5 + frac * 6.5;
    const h = Math.floor(hours);
    const m = Math.floor((hours - h) * 60);
    const h12 = h > 12 ? h - 12 : h;
    const ampm = h >= 12 ? 'pm' : 'am';
    return h12 + ':' + String(m).padStart(2, '0') + ampm;
  }
  function logTrade(side, qty, price, rpnl){
    const time = formatTradeTime(currentTick);
    tradedVolume += qty * price;
    tradeLog.push({ time, side, qty, price, rpnl });
    renderTradeLog();
  }
  function renderTradeLog(){
    const tbody = document.getElementById('trade-log-body');
    if(!tbody) return;
    if(tradeLog.length === 0){
      tbody.innerHTML = '<tr><td colspan="5" style="color:var(--muted);text-align:center;padding:12px 0">No trades yet</td></tr>';
      return;
    }
    tbody.innerHTML = tradeLog.slice().reverse().map(t=>{
      const sideColor = t.side==='BUY'?'#34d399':'#ef4444';
      const rpnlStr = t.rpnl !== 0
        ? `<span class="${t.rpnl>=0?'pnl-pos':'pnl-neg'}">${t.rpnl>=0?'+':'-'}$${Math.abs(t.rpnl).toFixed(2)}</span>`
        : '<span style="color:var(--muted)">—</span>';
      return `<tr><td>${t.time}</td><td style="color:${sideColor};font-weight:600">${t.side}</td><td>${t.qty}</td><td>$${t.price.toFixed(2)}</td><td>${rpnlStr}</td></tr>`;
    }).join('');
  }

  function updateAvgPrice(newPos, price){
    const oldPos = position;
    let tradeRpnl = 0;
    // Track realized P&L when reducing position
    if(oldPos !== 0){
      if(newPos === 0){
        tradeRpnl = oldPos * MULTIPLIER * (price - avgPrice);
      } else if(Math.sign(newPos) !== Math.sign(oldPos)){
        tradeRpnl = oldPos * MULTIPLIER * (price - avgPrice);
      } else if(Math.abs(newPos) < Math.abs(oldPos)){
        const closed = oldPos - newPos;
        tradeRpnl = closed * MULTIPLIER * (price - avgPrice);
      }
      realizedPnl += tradeRpnl;
    }

    if(newPos === 0){ totalCost = 0; avgPrice = 0; }
    else if(Math.sign(newPos) !== Math.sign(oldPos) && oldPos !== 0){
      totalCost = newPos * price; avgPrice = price;
    } else if(Math.abs(newPos) > Math.abs(oldPos)){
      totalCost += (newPos - oldPos) * price;
      avgPrice = totalCost / newPos;
    } else if(Math.abs(newPos) < Math.abs(oldPos)){
      // Reducing position: keep avgPrice, shrink totalCost
      totalCost = newPos * avgPrice;
    }
    return tradeRpnl;
  }

  function doBuy(){
    if(!running||paused||position>=MAX_POS) return;
    const price = prices[currentTick];
    const rpnl = updateAvgPrice(position+1, price);
    position++;
    posHistory[currentTick] = position;
    logTrade('BUY', MULTIPLIER, price, rpnl);
    updatePosDisplay();
    drawChart();
  }
  function doSell(){
    if(!running||paused||position<=-MAX_POS) return;
    const price = prices[currentTick];
    const rpnl = updateAvgPrice(position-1, price);
    position--;
    posHistory[currentTick] = position;
    logTrade('SELL', MULTIPLIER, price, rpnl);
    updatePosDisplay();
    drawChart();
  }

  function togglePause(){
    if(!running) return;
    if(paused){
      paused = false;
      loop = setInterval(tick, TICK);
      document.getElementById('trade-overlay-pause').classList.add('hidden');
      document.getElementById('trade-paused-badge').classList.remove('visible');
      document.getElementById('trade-buy-btn').disabled = false;
      document.getElementById('trade-sell-btn').disabled = false;
    } else {
      paused = true;
      clearInterval(loop);
      document.getElementById('trade-overlay-pause').classList.remove('hidden');
      document.getElementById('trade-paused-badge').classList.add('visible');
      document.getElementById('trade-buy-btn').disabled = true;
      document.getElementById('trade-sell-btn').disabled = true;
    }
  }

  function updatePosDisplay(){
    const display = position * MULTIPLIER;
    document.getElementById('trade-pos').textContent = (display>0?'+':'') + display;
    document.querySelectorAll('.trade-pos-dot').forEach(dot=>{
      const i = parseInt(dot.dataset.i);
      dot.classList.remove('long','short');
      if(position>0 && i>0 && i<=position) dot.classList.add('long');
      if(position<0 && i<0 && i>=position) dot.classList.add('short');
    });
  }

  function updatePnlDisplay(){
    const isSplit = settings.pnlMode === 'split';
    document.getElementById('trade-pnl-total').style.display = isSplit ? 'none' : '';
    document.getElementById('trade-pnl-realized').style.display = isSplit ? '' : 'none';
    document.getElementById('trade-pnl-unrealized').style.display = isSplit ? '' : 'none';

    if(isSplit){
      const unrealized = (running && position !== 0) ? position * MULTIPLIER * (prices[currentTick] - avgPrice) : 0;
      const rEl = document.getElementById('trade-rpnl');
      const uEl = document.getElementById('trade-upnl');
      rEl.textContent = `${realizedPnl>=0?'+':''}$${Math.abs(realizedPnl).toFixed(2)}`;
      rEl.className = realizedPnl>=0?'pnl-pos':'pnl-neg';
      uEl.textContent = `${unrealized>=0?'+':''}$${Math.abs(unrealized).toFixed(2)}`;
      uEl.className = unrealized>=0?'pnl-pos':'pnl-neg';
    } else {
      const el = document.getElementById('trade-pnl');
      const sign = pnl>=0?'+':'';
      el.textContent = `${sign}$${Math.abs(pnl).toFixed(2)}`;
      el.className = pnl>=0?'pnl-pos':'pnl-neg';
    }
  }

  function drawChart(){
    ctx.fillStyle='#0b0d10';
    ctx.fillRect(0,0,W,H);
    if(currentTick<1) return;
    const slice = prices.slice(0, currentTick+1);
    const minP = Math.min(...slice)-0.5;
    const maxP = Math.max(...slice)+0.5;
    const range = maxP-minP||1;
    const padT=18, padB=32, padL=6, padR=6;
    const cW=W-padL-padR, cH=H-padT-padB;

    // Position tint bands
    if(settings.posTint && posHistory){
      for(let i=0;i<=currentTick;i++){
        const p = posHistory[i] || 0;
        if(p === 0) continue;
        const alpha = Math.min(Math.abs(p) / MAX_POS, 1) * 0.12;
        ctx.fillStyle = p > 0 ? `rgba(52,211,153,${alpha})` : `rgba(239,68,68,${alpha})`;
        const x0 = padL + (i / TOTAL_TICKS) * cW;
        const x1 = padL + ((i + 1) / TOTAL_TICKS) * cW;
        ctx.fillRect(x0, padT, x1 - x0, cH);
      }
    }

    ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.lineWidth=1;
    for(let i=0;i<5;i++){const y=padT+cH*i/4;ctx.beginPath();ctx.moveTo(padL,y);ctx.lineTo(W-padR,y);ctx.stroke();}

    // Time labels on x-axis
    if(settings.dataSource === 'simulated'){
      ctx.fillStyle='#9aa3b2';ctx.font='9px Inter,sans-serif';ctx.textAlign='center';
      const totalSec = settings.duration;
      const step = totalSec <= 30 ? 5 : totalSec <= 60 ? 10 : 60;
      for(let s = step; s < totalSec; s += step){
        const frac = s / totalSec;
        const x = padL + frac * cW;
        ctx.beginPath();ctx.moveTo(x,padT);ctx.lineTo(x,padT+cH);ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.stroke();
        ctx.fillText(s + 's', x, padT+cH+12);
      }
    } else {
      const MARKET_START=9.5, MARKET_END=16;
      ctx.fillStyle='#9aa3b2';ctx.font='9px Inter,sans-serif';ctx.textAlign='center';
      for(let hr=10;hr<=15;hr++){
        const frac=(hr-MARKET_START)/(MARKET_END-MARKET_START);
        const x=padL+frac*cW;
        ctx.beginPath();ctx.moveTo(x,padT);ctx.lineTo(x,padT+cH);ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.stroke();
        const label=hr<=12?hr+'am':(hr-12)+'pm';
        ctx.fillText(label,x,padT+cH+12);
      }
    }

    ctx.strokeStyle='#4f8cff';ctx.lineWidth=2;ctx.beginPath();
    for(let i=0;i<=currentTick;i++){
      const x=padL+(i/TOTAL_TICKS)*cW;
      const y=padT+cH*(1-(slice[i]-minP)/range);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    const lastX=padL+(currentTick/TOTAL_TICKS)*cW;
    const lastY=padT+cH*(1-(slice[currentTick]-minP)/range);
    ctx.lineTo(lastX,padT+cH);ctx.lineTo(padL,padT+cH);ctx.closePath();
    ctx.fillStyle='rgba(79,140,255,0.08)';ctx.fill();

    // Average price horizontal line
    if(position !== 0 && avgPrice >= minP && avgPrice <= maxP){
      const avgY = padT + cH * (1 - (avgPrice - minP) / range);
      const color = position > 0 ? '#34d399' : '#ef4444';
      ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.setLineDash([4,4]);
      ctx.beginPath(); ctx.moveTo(padL, avgY); ctx.lineTo(W-padR, avgY); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = color; ctx.font = '9px Inter,sans-serif'; ctx.textAlign = 'right';
      ctx.fillText('avg $'+avgPrice.toFixed(2), W-padR, avgY-3);
    }

    ctx.fillStyle='#4f8cff';ctx.beginPath();ctx.arc(lastX,lastY,4,0,Math.PI*2);ctx.fill();

    ctx.fillStyle='#f5f7fa';ctx.font='11px Inter,sans-serif';ctx.textAlign='right';
    ctx.fillText('$'+slice[currentTick].toFixed(2),W-padR,padT-5);
    ctx.fillStyle='#9aa3b2';ctx.font='10px Inter,sans-serif';ctx.textAlign='left';
    ctx.fillText('$'+slice[0].toFixed(2),padL,padT+cH+24);
  }

  function tick(){
    if(currentTick>=TOTAL_TICKS){endGame();return;}
    const prevPrice = prices[currentTick];
    currentTick++;
    const newPrice = prices[currentTick];
    pnl += position * MULTIPLIER * (newPrice - prevPrice);
    posHistory[currentTick] = position;
    document.getElementById('trade-price').textContent = '$'+newPrice.toFixed(2);
    updatePnlDisplay();
    document.getElementById('trade-timer-fill').style.width = (currentTick/TOTAL_TICKS*100)+'%';
    drawChart();
  }

  function startGame(){
    settings = loadSettings();
    DURATION = settings.duration * 1000;
    TOTAL_TICKS = DURATION / TICK;

    prices = fetchRealPrices();

    currentTick = 0; position = 0; pnl = 0; running = true; paused = false;
    totalCost = 0; avgPrice = 0; realizedPnl = 0; tradedVolume = 0;
    posHistory = [0];
    tradeLog = [];
    document.getElementById('trade-log').style.display = '';
    document.getElementById('trade-lb').style.display = 'none';
    renderTradeLog();
    document.getElementById('trade-price').textContent = '$'+prices[0].toFixed(2);
    document.getElementById('trade-pos').textContent = '0';
    updatePnlDisplay();
    updatePosDisplay();
    document.getElementById('trade-timer-fill').style.width = '0%';
    document.getElementById('trade-overlay-start').classList.add('hidden');
    document.getElementById('trade-overlay-end').classList.add('hidden');
    document.getElementById('trade-overlay-pause').classList.add('hidden');
    document.getElementById('game-settings-modal').classList.add('hidden');
    document.getElementById('trade-paused-badge').classList.remove('visible');
    document.getElementById('trade-buy-btn').disabled = false;
    document.getElementById('trade-sell-btn').disabled = false;
    drawChart();
    if(loop) clearInterval(loop);
    loop = setInterval(tick, TICK);
  }

  function endGame(){
    running = false; paused = false;
    clearInterval(loop);
    document.getElementById('trade-buy-btn').disabled = true;
    document.getElementById('trade-sell-btn').disabled = true;
    document.getElementById('trade-overlay-pause').classList.add('hidden');
    document.getElementById('trade-paused-badge').classList.remove('visible');
    const el = document.getElementById('trade-result');
    const sign = pnl>=0?'+':'';
    el.textContent = `${sign}$${Math.abs(pnl).toFixed(2)}`;
    el.style.color = pnl>=0?'#34d399':'#ef4444';

    // Show date and chart link
    document.getElementById('trade-vol-info').textContent = 'Volume: ' + fmtVol(tradedVolume);
    const dateInfo = document.getElementById('trade-date-info');
    if(tradingDate === 'Simulated'){
      dateInfo.innerHTML = `Trading day: <strong>Simulated</strong>`;
    } else {
      const formattedDate = new Date(tradingDate + 'T12:00:00').toLocaleDateString('en-US', {
        year: 'numeric', month: 'short', day: 'numeric'
      });
      const d = new Date(tradingDate + 'T00:00:00');
      const p1 = Math.floor(d.getTime()/1000);
      const p2 = p1 + 86400;
      const yahooUrl = `https://finance.yahoo.com/quote/SPY/history/?period1=${p1}&period2=${p2}`;
      dateInfo.innerHTML = `Trading day: <strong>${formattedDate}</strong><br><a href="${yahooUrl}" target="_blank" rel="noopener" style="color:var(--accent);text-decoration:none;font-size:0.8rem">View on Yahoo Finance &rarr;</a>`;
    }

    // Show total PnL at game end regardless of mode
    document.getElementById('trade-pnl-total').style.display = '';
    document.getElementById('trade-pnl-realized').style.display = 'none';
    document.getElementById('trade-pnl-unrealized').style.display = 'none';
    const pnlEl = document.getElementById('trade-pnl');
    const pnlSign = pnl>=0?'+':'';
    pnlEl.textContent = `${pnlSign}$${Math.abs(pnl).toFixed(2)}`;
    pnlEl.className = pnl>=0?'pnl-pos':'pnl-neg';

    document.getElementById('trade-overlay-end').classList.remove('hidden');
    const lb = loadTradeLB();
    lb.push({pnl: parseFloat(pnl.toFixed(2)), vol: Math.round(tradedVolume), date: new Date().toISOString()});
    lb.sort((a,b)=>b.pnl-a.pnl);
    if(lb.length>5) lb.length=5;
    saveTradeLB(lb);
    renderTradeLB();
    document.getElementById('trade-log').style.display = 'none';
    document.getElementById('trade-lb').style.display = '';
  }

  // Settings modal
  document.getElementById('game-settings-btn').addEventListener('click', ()=>{
    if(running && !paused) togglePause();
    document.getElementById('game-settings-modal').classList.remove('hidden');
  });
  document.getElementById('ts-close').addEventListener('click', ()=>{
    settings.dataSource = document.getElementById('ts-source').value;
    settings.duration = parseInt(document.getElementById('ts-duration').value);
    settings.pnlMode = document.getElementById('ts-pnlmode').value;
    settings.posTint = document.getElementById('ts-postint').value === 'on';
    saveSettings(settings);
    // Apply PnL mode immediately if a game is running
    if(running) updatePnlDisplay();
    document.getElementById('game-settings-modal').classList.add('hidden');
  });
  document.getElementById('trade-clear-lb').addEventListener('click', ()=>{
    if(confirm('Clear the trading leaderboard?')){
      localStorage.removeItem('tradeLB');
      renderTradeLB();
    }
  });

  document.getElementById('trade-buy-btn').addEventListener('click', doBuy);
  document.getElementById('trade-sell-btn').addEventListener('click', doSell);
  document.getElementById('trade-start-btn').addEventListener('click', startGame);
  document.getElementById('trade-restart-btn').addEventListener('click', startGame);
  document.getElementById('trade-resume-btn').addEventListener('click', togglePause);
  document.getElementById('trade-end-btn').addEventListener('click', ()=>{ if(running) endGame(); });

  document.addEventListener('keydown', e=>{
    if((e.key===' '||e.key==='Escape') && running){ togglePause(); e.preventDefault(); return; }
    if(!running||paused) return;
    if(e.key==='ArrowUp'||e.key==='ArrowRight'){doBuy();e.preventDefault();}
    if(e.key==='ArrowDown'||e.key==='ArrowLeft'){doSell();e.preventDefault();}
  });

  ctx.fillStyle='#0b0d10';ctx.fillRect(0,0,W,H);

  // Fullscreen
  document.getElementById('trade-fullscreen-btn').addEventListener('click', ()=>{
    const el = document.getElementById('trade-wrap');
    if(!document.fullscreenElement) el.requestFullscreen().catch(()=>{});
    else document.exitFullscreen();
  });
  document.addEventListener('fullscreenchange', ()=>{
    const wrap = document.getElementById('trade-wrap');
    if(document.fullscreenElement === wrap){
      const maxW = Math.min(window.innerWidth - 48, 1200);
      W = maxW;
      H = Math.round(maxW * 0.55);
      canvas.width = W;
      canvas.height = H;
    } else {
      W = 400; H = 220;
      canvas.width = W;
      canvas.height = H;
    }
    drawChart();
  });
})();

// Whiteboard — object-based with infinite canvas (pan/zoom) & object eraser
(function(){
  const canvas = document.getElementById('wb-canvas');
  const ctx = canvas.getContext('2d');
  const gridCanvas = document.getElementById('wb-grid');
  const gridCtx = gridCanvas.getContext('2d');
  const area = document.getElementById('wb-canvas-area');
  const wrap = document.getElementById('wb-wrap');
  const BG = '#181b22';

  let W = canvas.width, H = canvas.height;
  let tool = 'pen';
  let color = '#f5f7fa';
  let lineWidth = 3;
  let opacity = 1;
  let fillShapes = false;
  let showGrid = false;
  let drawing = false;
  let shiftHeld = false;
  let spaceHeld = false;

  // --- Pan & Zoom state ---
  let panX = 0, panY = 0;
  let zoom = 1;
  const MIN_ZOOM = 0.1, MAX_ZOOM = 5;
  let isPanning = false;
  let panStartMouse = null;
  let panStartOffset = null;

  // --- Object store ---
  // Each object: {type, color, lineWidth, opacity, points?, x1,y1,x2,y2?, fill?, text?, fontSize?}
  let objects = [];
  let currentObj = null;   // stroke/shape being drawn
  let previewShape = null; // shape preview during drag

  // --- History (snapshots of objects array) ---
  let undoStack = [];
  let redoStack = [];
  const MAX_HISTORY = 40;

  function deepClone(arr){ return JSON.parse(JSON.stringify(arr)); }

  function saveState(broadcastType, broadcastData){
    undoStack.push(deepClone(objects));
    if(undoStack.length > MAX_HISTORY) undoStack.shift();
    redoStack = [];
    if(broadcastType) collabBroadcast({type:broadcastType, ...(broadcastData||{})});
  }

  // --- Coordinate conversion ---
  function getScreenPos(e){
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * (W / rect.width),
      y: (e.clientY - rect.top) * (H / rect.height)
    };
  }
  function screenToWorld(sx, sy){
    return { x: (sx - panX) / zoom, y: (sy - panY) / zoom };
  }
  function getPos(e){
    const sp = getScreenPos(e);
    return screenToWorld(sp.x, sp.y);
  }

  // --- Color helpers ---
  function colorWithOpacity(c, a){
    const r = parseInt(c.slice(1,3),16);
    const g = parseInt(c.slice(3,5),16);
    const b = parseInt(c.slice(5,7),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  // --- Draw a single object to a context ---
  function drawObject(c, obj){
    c.save();
    if(obj.type === 'pen'){
      c.strokeStyle = colorWithOpacity(obj.color, obj.opacity);
      c.lineWidth = obj.lineWidth;
      c.lineCap = 'round'; c.lineJoin = 'round';
      if(obj.points.length === 1){
        c.beginPath();
        c.arc(obj.points[0].x, obj.points[0].y, obj.lineWidth/2, 0, Math.PI*2);
        c.fillStyle = colorWithOpacity(obj.color, obj.opacity);
        c.fill();
      } else {
        c.beginPath();
        c.moveTo(obj.points[0].x, obj.points[0].y);
        for(let i=1; i<obj.points.length; i++){
          const prev = obj.points[i-1], curr = obj.points[i];
          const mx = (prev.x+curr.x)/2, my = (prev.y+curr.y)/2;
          c.quadraticCurveTo(prev.x, prev.y, mx, my);
        }
        const last = obj.points[obj.points.length-1];
        c.lineTo(last.x, last.y);
        c.stroke();
      }
    } else if(obj.type === 'highlighter'){
      c.globalCompositeOperation = 'screen';
      c.globalAlpha = 0.15;
      c.strokeStyle = obj.color;
      c.lineWidth = obj.lineWidth * 6;
      c.lineCap = 'round'; c.lineJoin = 'round';
      if(obj.points.length === 1){
        c.beginPath();
        c.arc(obj.points[0].x, obj.points[0].y, obj.lineWidth*3, 0, Math.PI*2);
        c.fillStyle = obj.color; c.fill();
      } else {
        c.beginPath();
        c.moveTo(obj.points[0].x, obj.points[0].y);
        for(let i=1; i<obj.points.length; i++){
          const prev = obj.points[i-1], curr = obj.points[i];
          const mx = (prev.x+curr.x)/2, my = (prev.y+curr.y)/2;
          c.quadraticCurveTo(prev.x, prev.y, mx, my);
        }
        const last = obj.points[obj.points.length-1];
        c.lineTo(last.x, last.y);
        c.stroke();
      }
    } else if(obj.type === 'line'){
      c.globalAlpha = obj.opacity;
      c.strokeStyle = obj.color; c.lineWidth = obj.lineWidth;
      c.lineCap = 'round';
      c.beginPath(); c.moveTo(obj.x1,obj.y1); c.lineTo(obj.x2,obj.y2); c.stroke();
    } else if(obj.type === 'arrow'){
      c.globalAlpha = obj.opacity;
      c.strokeStyle = obj.color; c.fillStyle = obj.color;
      c.lineWidth = obj.lineWidth; c.lineCap = 'round'; c.lineJoin = 'round';
      const angle = Math.atan2(obj.y2-obj.y1, obj.x2-obj.x1);
      const headLen = Math.max(14, obj.lineWidth*5);
      const tipX = obj.x2 - headLen*0.3*Math.cos(angle);
      const tipY = obj.y2 - headLen*0.3*Math.sin(angle);
      c.beginPath(); c.moveTo(obj.x1,obj.y1); c.lineTo(tipX,tipY); c.stroke();
      c.beginPath(); c.moveTo(obj.x2,obj.y2);
      c.lineTo(obj.x2 - headLen*Math.cos(angle-Math.PI/7), obj.y2 - headLen*Math.sin(angle-Math.PI/7));
      c.lineTo(obj.x2 - headLen*Math.cos(angle+Math.PI/7), obj.y2 - headLen*Math.sin(angle+Math.PI/7));
      c.closePath(); c.fill();
    } else if(obj.type === 'rect'){
      c.globalAlpha = obj.opacity;
      c.strokeStyle = obj.color; c.fillStyle = obj.color;
      c.lineWidth = obj.lineWidth; c.lineCap = 'round'; c.lineJoin = 'round';
      const rx = Math.min(obj.x1,obj.x2), ry = Math.min(obj.y1,obj.y2);
      const rw = Math.abs(obj.x2-obj.x1), rh = Math.abs(obj.y2-obj.y1);
      if(obj.fill) c.fillRect(rx,ry,rw,rh);
      c.strokeRect(rx,ry,rw,rh);
    } else if(obj.type === 'ellipse'){
      c.globalAlpha = obj.opacity;
      c.strokeStyle = obj.color; c.fillStyle = obj.color;
      c.lineWidth = obj.lineWidth;
      const cx = (obj.x1+obj.x2)/2, cy = (obj.y1+obj.y2)/2;
      const rx = Math.abs(obj.x2-obj.x1)/2, ry = Math.abs(obj.y2-obj.y1)/2;
      c.beginPath(); c.ellipse(cx,cy,Math.max(0,rx),Math.max(0,ry),0,0,Math.PI*2);
      if(obj.fill) c.fill(); c.stroke();
    } else if(obj.type === 'text'){
      c.globalAlpha = obj.opacity;
      c.font = `${obj.fontSize}px Inter, sans-serif`;
      c.fillStyle = obj.color; c.textBaseline = 'top';
      const lines = obj.text.split('\n');
      const lineH = obj.fontSize * 1.3;
      lines.forEach((line,i)=>{ c.fillText(line, obj.x, obj.y + i*lineH); });
    }
    c.restore();
  }

  // --- Full render ---
  function render(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = BG;
    ctx.fillRect(0,0,W,H);
    ctx.setTransform(zoom,0,0,zoom,panX,panY);
    for(const obj of objects) drawObject(ctx, obj);
    if(currentObj) drawObject(ctx, currentObj);
    if(previewShape) drawObject(ctx, previewShape);
    ctx.setTransform(1,0,0,1,0,0);
  }

  function renderGrid(){
    gridCtx.setTransform(1,0,0,1,0,0);
    gridCtx.clearRect(0,0,W,H);
    if(!showGrid) return;
    const step = 24;
    gridCtx.setTransform(zoom,0,0,zoom,panX,panY);
    const x0 = Math.floor(-panX/zoom/step)*step;
    const y0 = Math.floor(-panY/zoom/step)*step;
    const x1 = Math.ceil((W-panX)/zoom/step)*step;
    const y1 = Math.ceil((H-panY)/zoom/step)*step;
    gridCtx.fillStyle = 'rgba(255,255,255,0.08)';
    for(let x=x0; x<=x1; x+=step){
      for(let y=y0; y<=y1; y+=step){
        gridCtx.beginPath();
        gridCtx.arc(x, y, 1/zoom, 0, Math.PI*2);
        gridCtx.fill();
      }
    }
    gridCtx.setTransform(1,0,0,1,0,0);
  }

  // Initial render
  render();
  saveState();

  // --- Zoom helpers ---
  function updateZoomLabel(){
    const el = document.getElementById('wb-zoom-label');
    if(el) el.textContent = Math.round(zoom*100) + '%';
  }

  function zoomAt(sx, sy, factor){
    const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom * factor));
    const scale = newZoom / zoom;
    panX = sx - (sx - panX) * scale;
    panY = sy - (sy - panY) * scale;
    zoom = newZoom;
    render(); renderGrid(); updateZoomLabel(); repositionAllCursors();
  }

  function zoomCenter(factor){
    zoomAt(W/2, H/2, factor);
  }

  function resetView(){
    panX = 0; panY = 0; zoom = 1;
    render(); renderGrid(); updateZoomLabel(); repositionAllCursors();
  }

  // --- Hit testing for object eraser ---
  function ptSegDistSq(px,py, ax,ay, bx,by){
    const dx=bx-ax, dy=by-ay, lenSq=dx*dx+dy*dy;
    if(lenSq===0) return (px-ax)**2+(py-ay)**2;
    let t = ((px-ax)*dx+(py-ay)*dy)/lenSq;
    t = Math.max(0,Math.min(1,t));
    const projX=ax+t*dx, projY=ay+t*dy;
    return (px-projX)**2+(py-projY)**2;
  }

  function hitTest(obj, wx, wy, radius){
    const rSq = radius*radius;
    if(obj.type === 'pen' || obj.type === 'highlighter'){
      const hw = obj.type==='highlighter' ? obj.lineWidth*3 : obj.lineWidth/2;
      const thr = (radius+hw)*(radius+hw);
      for(let i=0; i<obj.points.length; i++){
        const p = obj.points[i];
        if(i===0){
          if((wx-p.x)**2+(wy-p.y)**2 < thr) return true;
        } else {
          const q = obj.points[i-1];
          if(ptSegDistSq(wx,wy, q.x,q.y, p.x,p.y) < thr) return true;
        }
      }
      return false;
    }
    if(obj.type === 'line' || obj.type === 'arrow'){
      const thr = radius + obj.lineWidth/2;
      return ptSegDistSq(wx,wy, obj.x1,obj.y1, obj.x2,obj.y2) < thr*thr;
    }
    if(obj.type === 'rect'){
      const x1=Math.min(obj.x1,obj.x2), y1=Math.min(obj.y1,obj.y2);
      const x2=Math.max(obj.x1,obj.x2), y2=Math.max(obj.y1,obj.y2);
      if(obj.fill){
        return wx>=x1-radius && wx<=x2+radius && wy>=y1-radius && wy<=y2+radius;
      }
      const thr = radius+obj.lineWidth/2, tSq=thr*thr;
      return ptSegDistSq(wx,wy,x1,y1,x2,y1)<tSq || ptSegDistSq(wx,wy,x2,y1,x2,y2)<tSq ||
             ptSegDistSq(wx,wy,x2,y2,x1,y2)<tSq || ptSegDistSq(wx,wy,x1,y2,x1,y1)<tSq;
    }
    if(obj.type === 'ellipse'){
      const cx=(obj.x1+obj.x2)/2, cy=(obj.y1+obj.y2)/2;
      const rx=Math.abs(obj.x2-obj.x1)/2+radius, ry=Math.abs(obj.y2-obj.y1)/2+radius;
      if(rx===0||ry===0) return false;
      const nx=(wx-cx)/rx, ny=(wy-cy)/ry;
      if(nx*nx+ny*ny > 1) return false;
      if(obj.fill) return true;
      const irx=Math.max(0,Math.abs(obj.x2-obj.x1)/2-radius-obj.lineWidth);
      const iry=Math.max(0,Math.abs(obj.y2-obj.y1)/2-radius-obj.lineWidth);
      if(irx===0||iry===0) return true;
      const inx=(wx-cx)/irx, iny=(wy-cy)/iry;
      return inx*inx+iny*iny >= 1;
    }
    if(obj.type === 'text'){
      const lines = obj.text.split('\n');
      const lineH = obj.fontSize*1.3;
      const h = lines.length*lineH;
      const w = Math.max(...lines.map(l=>l.length*obj.fontSize*0.6));
      return wx>=obj.x-radius && wx<=obj.x+w+radius && wy>=obj.y-radius && wy<=obj.y+h+radius;
    }
    return false;
  }

  function eraseAt(wx, wy){
    const radius = Math.max(8, lineWidth*2) / zoom;
    let removed = false;
    for(let i=objects.length-1; i>=0; i--){
      if(hitTest(objects[i], wx, wy, radius)){
        objects.splice(i,1);
        removed = true;
      }
    }
    if(removed) render();
    return removed;
  }

  // --- Shift constraints ---
  function constrain(x1,y1,x2,y2){
    if(!shiftHeld) return {x2,y2};
    const dx=x2-x1, dy=y2-y1;
    if(tool==='line'||tool==='arrow'){
      const angle = Math.atan2(dy,dx);
      const snap = Math.round(angle/(Math.PI/4))*(Math.PI/4);
      const dist = Math.sqrt(dx*dx+dy*dy);
      return { x2: x1+dist*Math.cos(snap), y2: y1+dist*Math.sin(snap) };
    }
    if(tool==='rect'||tool==='ellipse'){
      const side = Math.max(Math.abs(dx),Math.abs(dy));
      return { x2: x1+side*Math.sign(dx||1), y2: y1+side*Math.sign(dy||1) };
    }
    return {x2,y2};
  }

  // --- Text tool ---
  let activeTextInput = null;
  let textDragStart = null;  // {cx, cy} in CSS coords relative to area
  let textDragPreview = null; // preview div during drag

  function commitText(){
    if(!activeTextInput) return;
    const txt = activeTextInput.value.trim();
    if(txt){
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      const scaleY = H / rect.height;
      const box = activeTextInput.getBoundingClientRect();
      const sx = (box.left - rect.left) * scaleX;
      const sy = (box.top - rect.top) * scaleY;
      const wpos = screenToWorld(sx, sy);
      const fontSize = parseFloat(activeTextInput.style.fontSize) * scaleX / zoom;
      const textObj = {
        type:'text', x: wpos.x + 4/zoom, y: wpos.y + 2/zoom,
        text: txt, fontSize, color, opacity
      };
      objects.push(textObj);
      saveState('add', {obj: deepClone(textObj)});
      render();
    }
    activeTextInput.remove();
    activeTextInput = null;
  }

  function createTextArea(left, top, width, height, fontSize){
    commitText();
    const ta = document.createElement('textarea');
    ta.className = 'wb-text-input';
    ta.style.left = left + 'px';
    ta.style.top = top + 'px';
    ta.style.fontSize = fontSize + 'px';
    ta.style.color = colorWithOpacity(color, opacity);
    const isFixed = width != null;
    let currentFontSize = fontSize;
    const minFontSize = 8;
    if(isFixed){
      ta.style.width = width + 'px';
      ta.style.height = height + 'px';
    } else {
      ta.rows = 1;
    }
    area.appendChild(ta);
    activeTextInput = ta;
    let ready = false;
    setTimeout(()=>{ ta.focus(); ready = true; }, 50);

    function autoFit(){
      if(isFixed){
        // Shrink font until text fits, grow back if possible
        while(ta.scrollHeight > ta.clientHeight && currentFontSize > minFontSize){
          currentFontSize = Math.max(minFontSize, currentFontSize - 1);
          ta.style.fontSize = currentFontSize + 'px';
        }
        // Try growing back if there's room
        while(currentFontSize < fontSize){
          ta.style.fontSize = (currentFontSize + 1) + 'px';
          if(ta.scrollHeight > ta.clientHeight){
            ta.style.fontSize = currentFontSize + 'px';
            break;
          }
          currentFontSize++;
        }
      } else {
        ta.style.height = 'auto';
        ta.style.height = ta.scrollHeight + 'px';
      }
    }

    ta.addEventListener('input', autoFit);
    ta.addEventListener('keydown', (ev)=>{
      ev.stopPropagation();
      if(ev.key === 'Escape'){ commitText(); }
      if(ev.key === 'Enter' && !ev.shiftKey){ ev.preventDefault(); commitText(); }
    });
    ta.addEventListener('blur', ()=>{ if(ready) setTimeout(commitText, 100); });
  }

  function startTextDrag(e){
    commitText();
    const rect = canvas.getBoundingClientRect();
    textDragStart = { cx: e.clientX - rect.left, cy: e.clientY - rect.top };
    // Create preview box
    textDragPreview = document.createElement('div');
    textDragPreview.style.cssText = `position:absolute;border:1px dashed rgba(79,140,255,0.6);pointer-events:none;z-index:5;
      left:${textDragStart.cx}px;top:${textDragStart.cy}px;width:0;height:0;`;
    area.appendChild(textDragPreview);
  }

  function moveTextDrag(e){
    if(!textDragPreview || !textDragStart) return;
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const left = Math.min(textDragStart.cx, cx);
    const top = Math.min(textDragStart.cy, cy);
    const w = Math.abs(cx - textDragStart.cx);
    const h = Math.abs(cy - textDragStart.cy);
    textDragPreview.style.left = left + 'px';
    textDragPreview.style.top = top + 'px';
    textDragPreview.style.width = w + 'px';
    textDragPreview.style.height = h + 'px';
  }

  function endTextDrag(e){
    if(!textDragStart) return;
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const left = Math.min(textDragStart.cx, cx);
    const top = Math.min(textDragStart.cy, cy);
    const w = Math.abs(cx - textDragStart.cx);
    const h = Math.abs(cy - textDragStart.cy);
    if(textDragPreview){ textDragPreview.remove(); textDragPreview = null; }
    const MIN_DRAG = 20;
    if(w > MIN_DRAG && h > MIN_DRAG){
      // Font size proportional to box height (~60% of height for single line)
      const fontSize = Math.max(12, Math.min(200, Math.round(h * 0.6)));
      createTextArea(left, top, w, h, fontSize);
    } else {
      const cssSize = Math.max(14, lineWidth * 5);
      createTextArea(textDragStart.cx, textDragStart.cy, null, null, cssSize);
    }
    textDragStart = null;
  }

  // --- Pointer events ---
  let startWX, startWY;
  let eraserDirty = false;

  function shouldPan(e){
    return tool === 'hand' || spaceHeld || e.button === 1;
  }

  function onPointerDown(e){
    // Pan: hand tool, space+drag, or middle mouse
    if(shouldPan(e)){
      isPanning = true;
      panStartMouse = getScreenPos(e);
      panStartOffset = { x: panX, y: panY };
      area.classList.add('panning-active');
      e.preventDefault();
      return;
    }
    if(e.button && e.button !== 0) return;
    if(tool === 'text'){ startTextDrag(e); e.preventDefault(); return; }
    e.preventDefault();
    drawing = true;
    const pos = getPos(e);
    startWX = pos.x; startWY = pos.y;

    if(tool === 'pen'){
      currentObj = { type:'pen', points:[{x:pos.x,y:pos.y}], color, lineWidth, opacity };
    } else if(tool === 'highlighter'){
      currentObj = { type:'highlighter', points:[{x:pos.x,y:pos.y}], color, lineWidth };
    } else if(tool === 'eraser'){
      eraserDirty = false;
      if(eraseAt(pos.x, pos.y)) eraserDirty = true;
    }
    // shapes: startWX/startWY recorded, preview on move
  }

  function onPointerMove(e){
    if(isPanning){
      const sp = getScreenPos(e);
      panX = panStartOffset.x + (sp.x - panStartMouse.x);
      panY = panStartOffset.y + (sp.y - panStartMouse.y);
      render(); renderGrid(); updateZoomLabel(); repositionAllCursors();
      return;
    }
    if(textDragStart){ moveTextDrag(e); return; }
    if(!drawing) return;
    e.preventDefault();
    const pos = getPos(e);

    if(tool === 'pen' || tool === 'highlighter'){
      currentObj.points.push({x:pos.x, y:pos.y});
      render();
    } else if(tool === 'eraser'){
      if(eraseAt(pos.x, pos.y)) eraserDirty = true;
    } else {
      // Shape preview
      const c = constrain(startWX, startWY, pos.x, pos.y);
      previewShape = {
        type: tool, x1:startWX, y1:startWY, x2:c.x2, y2:c.y2,
        color, lineWidth, opacity, fill:fillShapes
      };
      render();
    }
  }

  function onPointerUp(e){
    if(isPanning){
      isPanning = false;
      area.classList.remove('panning-active');
      updateCursor();
      return;
    }
    if(textDragStart){ endTextDrag(e); return; }
    if(!drawing) return;
    drawing = false;
    const pos = getPos(e);

    if(tool === 'pen' || tool === 'highlighter'){
      if(currentObj){
        const obj = currentObj;
        objects.push(obj);
        currentObj = null;
        saveState('add', {obj: deepClone(obj)}); render();
      }
    } else if(tool === 'eraser'){
      if(eraserDirty){
        saveState();
        collabBroadcast({type:'erase', objects: deepClone(objects)});
      }
    } else {
      // Finalize shape
      const c = constrain(startWX, startWY, pos.x, pos.y);
      const obj = {
        type:tool, x1:startWX, y1:startWY, x2:c.x2, y2:c.y2,
        color, lineWidth, opacity, fill:fillShapes
      };
      objects.push(obj);
      previewShape = null;
      saveState('add', {obj: deepClone(obj)}); render();
    }
  }

  // Pointer capture for smooth drawing
  // --- Multi-touch pinch/pan state ---
  let activeTouches = new Map(); // pointerId → {x,y}
  let pinchActive = false;
  let pinchStartDist = 0;
  let pinchStartZoom = 1;
  let pinchStartMid = {x:0,y:0};
  let pinchStartPanX = 0;
  let pinchStartPanY = 0;

  function getTouchDist(a, b){ return Math.hypot(a.x - b.x, a.y - b.y); }
  function getTouchMid(a, b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }

  function screenPosFromClient(cx, cy){
    const rect = canvas.getBoundingClientRect();
    return { x: (cx - rect.left) * (W / rect.width), y: (cy - rect.top) * (H / rect.height) };
  }

  canvas.addEventListener('pointerdown', (e)=>{
    // Track touch points
    if(e.pointerType === 'touch'){
      activeTouches.set(e.pointerId, screenPosFromClient(e.clientX, e.clientY));
      // Two fingers → start pinch, cancel any drawing
      if(activeTouches.size === 2){
        if(drawing){ drawing = false; currentObj = null; previewShape = null; render(); }
        if(isPanning){ isPanning = false; area.classList.remove('panning-active'); }
        const pts = [...activeTouches.values()];
        pinchActive = true;
        pinchStartDist = getTouchDist(pts[0], pts[1]);
        pinchStartZoom = zoom;
        pinchStartMid = getTouchMid(pts[0], pts[1]);
        pinchStartPanX = panX;
        pinchStartPanY = panY;
        e.preventDefault();
        return;
      }
      if(activeTouches.size > 2){ e.preventDefault(); return; }
    }
    canvas.setPointerCapture(e.pointerId);
    onPointerDown(e);
  });

  canvas.addEventListener('pointermove', (e)=>{
    broadcastCursor(e);
    if(e.pointerType === 'touch' && activeTouches.has(e.pointerId)){
      activeTouches.set(e.pointerId, screenPosFromClient(e.clientX, e.clientY));
      if(pinchActive && activeTouches.size >= 2){
        const pts = [...activeTouches.values()];
        const dist = getTouchDist(pts[0], pts[1]);
        const mid = getTouchMid(pts[0], pts[1]);
        // Zoom
        const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, pinchStartZoom * (dist / pinchStartDist)));
        const scale = newZoom / pinchStartZoom;
        // Pan: follow midpoint + zoom around pinch center
        panX = pinchStartPanX + (mid.x - pinchStartMid.x) - (pinchStartMid.x - pinchStartPanX) * (scale - 1);
        panY = pinchStartPanY + (mid.y - pinchStartMid.y) - (pinchStartMid.y - pinchStartPanY) * (scale - 1);
        zoom = newZoom;
        render(); renderGrid(); updateZoomLabel(); repositionAllCursors();
        e.preventDefault();
        return;
      }
    }
    if(!pinchActive) onPointerMove(e);
  });

  canvas.addEventListener('pointerup', (e)=>{
    if(e.pointerType === 'touch'){
      activeTouches.delete(e.pointerId);
      if(pinchActive){
        if(activeTouches.size < 2) pinchActive = false;
        e.preventDefault();
        return;
      }
    }
    canvas.releasePointerCapture(e.pointerId);
    onPointerUp(e);
  });

  canvas.addEventListener('pointercancel', (e)=>{
    if(e.pointerType === 'touch'){
      activeTouches.delete(e.pointerId);
      if(pinchActive){
        if(activeTouches.size < 2) pinchActive = false;
        return;
      }
    }
    if(drawing||isPanning||textDragStart) onPointerUp(e);
  });

  canvas.addEventListener('lostpointercapture', (e)=>{ if(drawing||isPanning||textDragStart) onPointerUp(e); });
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); }, {passive:false});
  canvas.addEventListener('touchmove', e=>{ e.preventDefault(); }, {passive:false});

  // --- Scroll wheel zoom / trackpad pan ---
  area.addEventListener('wheel', (e)=>{
    e.preventDefault();
    if(e.ctrlKey || e.metaKey){
      // Pinch-to-zoom (trackpad) or Ctrl+scroll
      const sp = getScreenPos(e);
      const factor = e.deltaY < 0 ? 1.08 : 1/1.08;
      zoomAt(sp.x, sp.y, factor);
    } else {
      // Two-finger scroll → pan
      panX -= e.deltaX;
      panY -= e.deltaY;
      render(); renderGrid(); updateZoomLabel(); repositionAllCursors();
    }
  }, {passive:false});

  // --- Cursors ---
  function updateCursor(){
    area.classList.remove('panning','panning-active');
    if(tool === 'hand'){
      area.style.cursor = 'grab';
      area.classList.add('panning');
    } else if(tool === 'eraser'){
      const sz = Math.max(8, lineWidth * 4);
      const half = Math.round(sz / 2);
      const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${sz}' height='${sz}'><circle cx='${half}' cy='${half}' r='${half-1}' fill='none' stroke='white' stroke-width='1.5'/></svg>`;
      area.style.cursor = `url("data:image/svg+xml,${encodeURIComponent(svg)}") ${half} ${half}, cell`;
    } else if(tool === 'pen' || tool === 'highlighter'){
      const sz = tool === 'highlighter' ? Math.max(8, lineWidth * 6) : Math.max(6, lineWidth);
      const half = Math.round(sz / 2);
      const svgSz = sz + 4;
      const c = svgSz / 2;
      const r = half;
      const encoded = color.replace('#','%23');
      const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${svgSz}' height='${svgSz}'><circle cx='${c}' cy='${c}' r='${r}' fill='${encoded}' opacity='${tool==="highlighter"?0.4:opacity}'/><circle cx='${c}' cy='${c}' r='${r}' fill='none' stroke='white' stroke-width='0.5' opacity='0.6'/></svg>`;
      area.style.cursor = `url("data:image/svg+xml,${encodeURIComponent(svg)}") ${c} ${c}, crosshair`;
    } else if(tool === 'text'){
      area.style.cursor = 'text';
    } else {
      area.style.cursor = 'crosshair';
    }
  }
  updateCursor();

  // --- Tool selection ---
  document.querySelectorAll('#wb-tools .wb-btn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      commitText();
      document.querySelectorAll('#wb-tools .wb-btn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      tool = btn.dataset.tool;
      updateCursor();
    });
  });

  // --- Color selection ---
  document.querySelectorAll('#wb-colors .wb-color-btn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      document.querySelectorAll('#wb-colors .wb-color-btn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      color = btn.dataset.color;
      document.getElementById('wb-custom-color').classList.remove('active');
      updateCursor();
    });
  });
  const customColor = document.getElementById('wb-custom-color');
  customColor.addEventListener('input', ()=>{
    color = customColor.value;
    document.querySelectorAll('#wb-colors .wb-color-btn').forEach(b=>b.classList.remove('active'));
    updateCursor();
  });

  // --- Size slider ---
  const sizeSlider = document.getElementById('wb-size');
  const sizeLabel = document.getElementById('wb-size-label');
  sizeSlider.addEventListener('input', ()=>{
    lineWidth = parseInt(sizeSlider.value);
    sizeLabel.textContent = lineWidth;
    updateCursor();
  });

  // --- Opacity slider ---
  const opacitySlider = document.getElementById('wb-opacity');
  const opacityLabel = document.getElementById('wb-opacity-label');
  opacitySlider.addEventListener('input', ()=>{
    opacity = parseInt(opacitySlider.value) / 100;
    opacityLabel.textContent = parseInt(opacitySlider.value) + '%';
    updateCursor();
  });

  // Fill toggle
  document.getElementById('wb-fill-check').addEventListener('change', (e)=>{
    fillShapes = e.target.checked;
  });

  // Grid toggle
  document.getElementById('wb-grid-check').addEventListener('change', (e)=>{
    showGrid = e.target.checked;
    gridCanvas.classList.toggle('visible', showGrid);
    renderGrid();
  });

  // --- Undo / Redo ---
  function undo(){
    commitText();
    if(undoStack.length <= 1) return;
    redoStack.push(undoStack.pop());
    objects = deepClone(undoStack[undoStack.length-1]);
    render();
    collabBroadcast({type:'undo', objects: deepClone(objects)});
  }
  function redo(){
    if(redoStack.length === 0) return;
    const state = redoStack.pop();
    undoStack.push(state);
    objects = deepClone(state);
    render();
    collabBroadcast({type:'redo', objects: deepClone(objects)});
  }
  document.getElementById('wb-undo-btn').addEventListener('click', undo);
  document.getElementById('wb-redo-btn').addEventListener('click', redo);

  // Clear
  document.getElementById('wb-clear-btn').addEventListener('click', ()=>{
    commitText();
    if(!confirm('Clear the whiteboard?')) return;
    objects = [];
    saveState(); render();
    collabBroadcast({type:'clear', objects:[]});
  });

  // Download — renders all objects to a tight bounding box PNG
  document.getElementById('wb-download-btn').addEventListener('click', ()=>{
    // Find bounding box of all objects
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    function expandPt(x,y){ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; }
    function expandObj(obj){
      const pad = obj.lineWidth ? obj.lineWidth*4 : 20;
      if(obj.points){
        obj.points.forEach(p=>{ expandPt(p.x-pad,p.y-pad); expandPt(p.x+pad,p.y+pad); });
      } else if(obj.type==='text'){
        const lines = obj.text.split('\n');
        const lineH = obj.fontSize*1.3;
        const h = lines.length*lineH;
        const w = Math.max(...lines.map(l=>l.length*obj.fontSize*0.6));
        expandPt(obj.x-pad,obj.y-pad); expandPt(obj.x+w+pad,obj.y+h+pad);
      } else {
        expandPt(Math.min(obj.x1,obj.x2)-pad, Math.min(obj.y1,obj.y2)-pad);
        expandPt(Math.max(obj.x1,obj.x2)+pad, Math.max(obj.y1,obj.y2)+pad);
      }
    }
    if(objects.length === 0){
      // Export current viewport
      const link = document.createElement('a');
      link.download = 'whiteboard.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
      return;
    }
    objects.forEach(expandObj);
    const margin = 20;
    minX -= margin; minY -= margin; maxX += margin; maxY += margin;
    const expW = Math.ceil(maxX-minX), expH = Math.ceil(maxY-minY);
    const offscreen = document.createElement('canvas');
    offscreen.width = expW; offscreen.height = expH;
    const oCtx = offscreen.getContext('2d');
    oCtx.fillStyle = BG;
    oCtx.fillRect(0,0,expW,expH);
    oCtx.translate(-minX, -minY);
    for(const obj of objects) drawObject(oCtx, obj);
    const link = document.createElement('a');
    link.download = 'whiteboard.png';
    link.href = offscreen.toDataURL('image/png');
    link.click();
  });

  // --- More popover ---
  const moreBtn = document.getElementById('wb-more-btn');
  const morePopover = document.getElementById('wb-more-popover');
  moreBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    morePopover.classList.toggle('visible');
  });
  document.addEventListener('click', (e)=>{
    if(!morePopover.contains(e.target) && e.target !== moreBtn) morePopover.classList.remove('visible');
  });

  // --- Fullscreen ---
  document.getElementById('wb-fullscreen-btn').addEventListener('click', ()=>{
    if(!document.fullscreenElement) wrap.requestFullscreen().catch(()=>{});
    else document.exitFullscreen();
  });

  document.addEventListener('fullscreenchange', ()=>{
    if(document.fullscreenElement === wrap){
      W = window.innerWidth;
      H = window.innerHeight - document.getElementById('wb-toolbar').offsetHeight;
    } else {
      W = 1200; H = 600;
    }
    canvas.width = W; canvas.height = H;
    gridCanvas.width = W; gridCanvas.height = H;
    render(); renderGrid();
  });

  // --- Shift & Space key tracking ---
  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Shift') shiftHeld = true;
    if(e.key === ' ' && !e.repeat && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'INPUT'){
      e.preventDefault();
      spaceHeld = true;
      if(!isPanning) area.style.cursor = 'grab';
    }
  });
  document.addEventListener('keyup', (e)=>{
    if(e.key === 'Shift') shiftHeld = false;
    if(e.key === ' '){
      spaceHeld = false;
      if(!isPanning) updateCursor();
    }
  });

  // --- Keyboard shortcuts ---
  document.addEventListener('keydown', (e)=>{
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
    if((e.ctrlKey||e.metaKey) && e.key === 'z' && !e.shiftKey){ e.preventDefault(); undo(); }
    if((e.ctrlKey||e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))){ e.preventDefault(); redo(); }
    if((e.ctrlKey||e.metaKey) && (e.key === '=' || e.key === '+')){ e.preventDefault(); zoomCenter(1.25); }
    if((e.ctrlKey||e.metaKey) && e.key === '-'){ e.preventDefault(); zoomCenter(1/1.25); }
    if((e.ctrlKey||e.metaKey) && e.key === '0'){ e.preventDefault(); resetView(); }
    if(e.ctrlKey || e.metaKey) return;
    const keyMap = {p:'pen', l:'line', r:'rect', e:'ellipse', a:'arrow', h:'highlighter', t:'text', x:'eraser', g:'hand'};
    if(keyMap[e.key]) document.querySelector(`#wb-tools .wb-btn[data-tool="${keyMap[e.key]}"]`).click();
  });

  // --- AI Live Guess ---
  let aiKey = localStorage.getItem('wb-ai-key') || '';
  let aiAbort = null;
  const aiBtnEl = document.getElementById('wb-ai-btn');
  const aiPopover = document.getElementById('wb-ai-popover');
  const aiKeyInput = document.getElementById('wb-ai-key');
  const aiSaveBtn = document.getElementById('wb-ai-save');
  const aiStatusEl = document.getElementById('wb-ai-status');
  const aiGuessEl = document.getElementById('wb-ai-guess');
  const aiGuessText = document.getElementById('wb-ai-guess-text');

  if(aiKey) aiKeyInput.value = aiKey.slice(0,3) + '...' + aiKey.slice(-4);

  function showKeyPopover(){
    const dp = document.getElementById('wb-ai-draw-popover');
    if(dp) dp.classList.remove('visible');
    aiPopover.classList.toggle('visible');
    if(aiPopover.classList.contains('visible')){
      aiKeyInput.value = '';
      aiKeyInput.focus();
    }
  }

  aiBtnEl.addEventListener('click', ()=>{
    if(!aiKey){ showKeyPopover(); return; }
    doGuess();
  });

  // Right-click on either AI button to change API key
  aiBtnEl.addEventListener('contextmenu', (e)=>{ e.preventDefault(); showKeyPopover(); });


  aiSaveBtn.addEventListener('click', ()=>{
    const key = aiKeyInput.value.trim();
    if(!key || key.length < 10){
      aiStatusEl.textContent = 'Enter a valid key';
      aiStatusEl.style.color = '#ef4444';
      return;
    }
    aiKey = key;
    localStorage.setItem('wb-ai-key', aiKey);
    aiStatusEl.textContent = 'Saved!';
    aiStatusEl.style.color = '#34d399';
    aiKeyInput.value = aiKey.slice(0,3) + '...' + aiKey.slice(-4);
    setTimeout(()=>{
      aiPopover.classList.remove('visible');
      aiStatusEl.textContent = 'Stored locally only';
      aiStatusEl.style.color = '';
    }, 400);
  });

  aiKeyInput.addEventListener('keydown', (ev)=>{
    ev.stopPropagation(); // prevent whiteboard shortcuts
    if(ev.key === 'Enter') aiSaveBtn.click();
    if(ev.key === 'Escape') aiPopover.classList.remove('visible');
  });

  // Close popover when clicking outside
  document.addEventListener('pointerdown', (ev)=>{
    if(aiPopover.classList.contains('visible') &&
       !aiPopover.contains(ev.target) && ev.target !== aiBtnEl &&
       ev.target !== document.getElementById('wb-ai-draw-btn')){
      aiPopover.classList.remove('visible');
    }
  });

  function showGuess(text, loading){
    aiGuessText.textContent = text;
    aiGuessEl.classList.add('visible');
    aiGuessEl.classList.toggle('loading', !!loading);
  }
  function hideGuess(){
    aiGuessEl.classList.remove('visible','loading');
  }

  // Capture canvas for API
  function captureForAI(){
    const sz = 512;
    const off = document.createElement('canvas');
    off.width = sz; off.height = sz;
    const oCtx = off.getContext('2d');
    oCtx.fillStyle = BG;
    oCtx.fillRect(0,0,sz,sz);
    if(objects.length === 0) return null;
    // Find bounding box
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    function expand(obj){
      const pad = obj.lineWidth ? obj.lineWidth*4 : 20;
      if(obj.points) obj.points.forEach(p=>{
        if(p.x-pad<minX)minX=p.x-pad; if(p.y-pad<minY)minY=p.y-pad;
        if(p.x+pad>maxX)maxX=p.x+pad; if(p.y+pad>maxY)maxY=p.y+pad;
      });
      else if(obj.type==='text'){
        const lines=obj.text.split('\n'), lh=obj.fontSize*1.3;
        const h=lines.length*lh, w=Math.max(...lines.map(l=>l.length*obj.fontSize*0.6));
        if(obj.x-pad<minX)minX=obj.x-pad; if(obj.y-pad<minY)minY=obj.y-pad;
        if(obj.x+w+pad>maxX)maxX=obj.x+w+pad; if(obj.y+h+pad>maxY)maxY=obj.y+h+pad;
      } else {
        const x0=Math.min(obj.x1,obj.x2)-pad, y0=Math.min(obj.y1,obj.y2)-pad;
        const x1=Math.max(obj.x1,obj.x2)+pad, y1=Math.max(obj.y1,obj.y2)+pad;
        if(x0<minX)minX=x0; if(y0<minY)minY=y0; if(x1>maxX)maxX=x1; if(y1>maxY)maxY=y1;
      }
    }
    objects.forEach(expand);
    const bw=maxX-minX, bh=maxY-minY;
    if(bw<=0||bh<=0) return null;
    const scale = Math.min(sz/bw, sz/bh) * 0.9;
    const offX = (sz - bw*scale)/2 - minX*scale;
    const offY = (sz - bh*scale)/2 - minY*scale;
    oCtx.setTransform(scale,0,0,scale,offX,offY);
    for(const obj of objects) drawObject(oCtx, obj);
    return off.toDataURL('image/png');
  }

  async function doGuess(){
    if(!aiKey || objects.length === 0){ hideGuess(); return; }
    const dataUrl = captureForAI();
    if(!dataUrl){ hideGuess(); return; }
    showGuess('Sending request...', true);
    if(aiAbort) aiAbort.abort();
    aiAbort = new AbortController();
    try {
      const resp = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${aiKey}`
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [{
            role: 'user',
            content: [
              { type: 'text', text: 'This is a whiteboard sketch on a dark background. What is being drawn? Reply with ONLY a short guess (1-5 words), like "a cat", "house with tree", "smiley face". Nothing else.' },
              { type: 'image_url', image_url: { url: dataUrl, detail: 'low' } }
            ]
          }],
          max_tokens: 20
        }),
        signal: aiAbort.signal
      });
      const data = await resp.json();
      if(data.error){
        showGuess('API error: ' + (data.error.message || 'unknown').slice(0,40), false);
        setTimeout(hideGuess, 5000);
        return;
      }
      const guess = data.choices?.[0]?.message?.content?.trim() || '?';
      let costStr = '';
      if(data.usage){
        // gpt-4o-mini: $0.15/1M input, $0.60/1M output
        const inCost = (data.usage.prompt_tokens || 0) * 0.15 / 1e6;
        const outCost = (data.usage.completion_tokens || 0) * 0.60 / 1e6;
        const totalCost = inCost + outCost;
        const tokens = data.usage.total_tokens;
        costStr = ` (${tokens} tok, $${totalCost.toFixed(5)})`;
      }
      showGuess(guess + costStr, false);
    } catch(err){
      if(err.name === 'AbortError') return;
      showGuess('Connection error', false);
      setTimeout(hideGuess, 5000);
    }
  }

  // --- AI Draw ---
  const aiDrawBtn = document.getElementById('wb-ai-draw-btn');
  const aiDrawPopover = document.getElementById('wb-ai-draw-popover');
  const aiDrawPrompt = document.getElementById('wb-ai-draw-prompt');
  const aiDrawGo = document.getElementById('wb-ai-draw-go');
  const aiDrawStatus = document.getElementById('wb-ai-draw-status');
  let aiDrawAbort = null;

  aiDrawBtn.addEventListener('click', ()=>{
    if(!aiKey){ showKeyPopover(); return; }
    aiPopover.classList.remove('visible');
    aiDrawPopover.classList.toggle('visible');
    if(aiDrawPopover.classList.contains('visible')){
      aiDrawPrompt.focus();
    }
  });

  aiDrawBtn.addEventListener('contextmenu', (e)=>{ e.preventDefault(); showKeyPopover(); });

  aiDrawPrompt.addEventListener('keydown', (ev)=>{
    ev.stopPropagation();
    if(ev.key === 'Enter') aiDrawGo.click();
    if(ev.key === 'Escape') aiDrawPopover.classList.remove('visible');
  });

  // Close popover when clicking outside
  document.addEventListener('pointerdown', (ev)=>{
    if(aiDrawPopover.classList.contains('visible') &&
       !aiDrawPopover.contains(ev.target) && ev.target !== aiDrawBtn){
      aiDrawPopover.classList.remove('visible');
    }
  });

  // Convert SVG string to pen strokes using browser's SVG parser
  function svgToStrokes(svgText){
    const strokes = [];
    const parser = new DOMParser();
    if(!svgText.trim().startsWith('<svg')) svgText = `<svg xmlns="http://www.w3.org/2000/svg">${svgText}</svg>`;
    const doc = parser.parseFromString(svgText, 'image/svg+xml');
    const svg = doc.querySelector('svg');
    if(!svg) return strokes;

    // Inject SVG into DOM temporarily so getPointAtLength works
    svg.style.position = 'absolute';
    svg.style.left = '-9999px';
    svg.style.top = '-9999px';
    document.body.appendChild(svg);

    const vb = svg.getAttribute('viewBox');
    let svgW = 200, svgH = 200;
    if(vb){
      const parts = vb.split(/[\s,]+/).map(Number);
      if(parts.length >= 4){ svgW = parts[2]; svgH = parts[3]; }
    } else {
      svgW = parseFloat(svg.getAttribute('width')) || 200;
      svgH = parseFloat(svg.getAttribute('height')) || 200;
    }

    // Walk up parents to resolve inherited stroke/fill/stroke-width
    function resolveAttr(el, attr){
      let node = el;
      while(node && node !== svg){
        const v = node.getAttribute(attr);
        if(v) return v;
        node = node.parentElement;
      }
      return null;
    }

    function getColor(el){
      const stroke = resolveAttr(el, 'stroke');
      const fill = resolveAttr(el, 'fill');
      if(stroke && stroke !== 'none') return stroke;
      if(fill && fill !== 'none') return fill;
      return '#f5f7fa';
    }

    function getWidth(el){
      const sw = parseFloat(resolveAttr(el, 'stroke-width'));
      return sw > 0 ? sw : 2;
    }

    function toPath(el){
      const tag = el.tagName.toLowerCase();
      if(tag === 'path') return el.getAttribute('d');
      if(tag === 'line'){
        return `M${el.getAttribute('x1')||0},${el.getAttribute('y1')||0}L${el.getAttribute('x2')||0},${el.getAttribute('y2')||0}`;
      }
      if(tag === 'polyline' || tag === 'polygon'){
        const pts = (el.getAttribute('points')||'').trim().split(/[\s,]+/);
        let d = '';
        for(let i=0;i<pts.length-1;i+=2) d += (i===0?'M':'L') + pts[i]+','+pts[i+1];
        if(tag === 'polygon') d += 'Z';
        return d;
      }
      if(tag === 'circle'){
        const cx=+(el.getAttribute('cx')||0), cy=+(el.getAttribute('cy')||0), r=+(el.getAttribute('r')||0);
        if(r<=0) return null;
        return `M${cx-r},${cy}A${r},${r},0,1,1,${cx+r},${cy}A${r},${r},0,1,1,${cx-r},${cy}Z`;
      }
      if(tag === 'ellipse'){
        const cx=+(el.getAttribute('cx')||0), cy=+(el.getAttribute('cy')||0);
        const rx=+(el.getAttribute('rx')||0), ry=+(el.getAttribute('ry')||0);
        if(rx<=0||ry<=0) return null;
        return `M${cx-rx},${cy}A${rx},${ry},0,1,1,${cx+rx},${cy}A${rx},${ry},0,1,1,${cx-rx},${cy}Z`;
      }
      if(tag === 'rect'){
        const x=+(el.getAttribute('x')||0), y=+(el.getAttribute('y')||0);
        const w=+(el.getAttribute('width')||0), h=+(el.getAttribute('height')||0);
        if(w<=0||h<=0) return null;
        return `M${x},${y}L${x+w},${y}L${x+w},${y+h}L${x},${y+h}Z`;
      }
      return null;
    }

    // Process all drawable elements (including inside <g> groups)
    const elements = svg.querySelectorAll('path, line, polyline, polygon, circle, ellipse, rect');
    elements.forEach(el => {
      const c = getColor(el);
      const w = getWidth(el);
      const d = toPath(el);
      if(!d) return;

      // Create a temporary path element in the live SVG for sampling
      const pathEl = document.createElementNS('http://www.w3.org/2000/svg','path');
      pathEl.setAttribute('d', d);
      svg.appendChild(pathEl);

      try {
        const len = pathEl.getTotalLength();
        if(len > 0){
          const numPts = Math.max(12, Math.min(120, Math.round(len / 1.5)));
          const points = [];
          for(let i=0; i<=numPts; i++){
            const p = pathEl.getPointAtLength(i * len / numPts);
            points.push({x: p.x, y: p.y});
          }
          strokes.push({ points, color: c, width: w, svgW, svgH });
        }
      } catch(e){}
      svg.removeChild(pathEl);
    });

    document.body.removeChild(svg);
    return strokes;
  }

  aiDrawGo.addEventListener('click', async ()=>{
    const prompt = aiDrawPrompt.value.trim();
    if(!prompt){ aiDrawStatus.textContent = 'Enter a prompt'; aiDrawStatus.style.color = '#ef4444'; return; }
    if(!aiKey){ showKeyPopover(); return; }

    aiDrawPopover.classList.remove('visible');
    showGuess('Sending request...', true);
    aiDrawGo.disabled = true;

    if(aiDrawAbort) aiDrawAbort.abort();
    aiDrawAbort = new AbortController();

    try {
      const resp = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${aiKey}`
        },
        body: JSON.stringify({
          model: 'gpt-4o',
          messages: [{
            role: 'system',
            content: `You are an expert SVG artist. You create beautiful, detailed SVG illustrations. Output ONLY the SVG markup, nothing else.

Requirements:
- Use viewBox="0 0 200 200". Fill the viewBox — the drawing should span most of the 200x200 area.
- Use <path> with cubic bezier curves (C command) for smooth organic shapes. Use <circle>, <ellipse>, <rect>, <line> for geometric parts.
- Use bright colors visible on dark background (#181b22). Never use black, #000, or very dark colors.
- Set stroke, stroke-width, and fill on each element. Use fill="none" for outlines only.
- <g> groups are OK for organizing. Do NOT use <text>, <image>, <use>, <defs>, <style>, <clipPath>, <filter>, transforms, or CSS.
- Create detailed, realistic illustrations — NOT stick figures or simple shapes.

Example — a star:
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
<polygon points="100,10 120,75 190,75 135,115 155,180 100,145 45,180 65,115 10,75 80,75" fill="#facc15" stroke="#fbbf24" stroke-width="2"/>
</svg>`
          },{
            role: 'user',
            content: `Draw: ${prompt}`
          }],
          max_tokens: 4096,
          temperature: 0.7
        }),
        signal: aiDrawAbort.signal
      });

      const data = await resp.json();
      if(data.error){
        showGuess('API error: ' + (data.error.message || 'unknown').slice(0, 40), false);
        setTimeout(hideGuess, 5000);
        aiDrawGo.disabled = false;
        return;
      }

      let raw = data.choices?.[0]?.message?.content?.trim() || '';
      // Strip markdown fences if present
      raw = raw.replace(/^```(?:xml|svg|html)?\s*/i, '').replace(/\s*```$/,'');

      // Extract SVG tag if surrounded by other text
      const svgMatch = raw.match(/<svg[\s\S]*<\/svg>/i);
      if(svgMatch) raw = svgMatch[0];

      const strokes = svgToStrokes(raw);

      if(strokes.length === 0){
        showGuess('No drawable elements found', false);
        setTimeout(hideGuess, 5000);
        aiDrawGo.disabled = false;
        return;
      }

      // Cost info (gpt-4o: $2.50/1M input, $10/1M output)
      let costStr = '';
      if(data.usage){
        const inCost = (data.usage.prompt_tokens || 0) * 2.50 / 1e6;
        const outCost = (data.usage.completion_tokens || 0) * 10.0 / 1e6;
        const totalCost = inCost + outCost;
        costStr = ` (${data.usage.total_tokens} tok, $${totalCost.toFixed(4)})`;
      }

      // Compute scale & offset to fill ~85% of visible viewport
      const vw = W / zoom;
      const vh = H / zoom;
      const svgW = strokes[0].svgW;
      const svgH = strokes[0].svgH;
      const targetW = vw * 0.85;
      const targetH = vh * 0.85;
      const scale = Math.min(targetW / svgW, targetH / svgH);
      const viewX0 = -panX / zoom;
      const viewY0 = -panY / zoom;
      const offsetX = viewX0 + (vw - svgW * scale) / 2;
      const offsetY = viewY0 + (vh - svgH * scale) / 2;

      // Add strokes with animation
      saveState();
      let strokeIdx = 0;
      function addNextStroke(){
        if(strokeIdx >= strokes.length){
          showGuess(`Done! ${strokes.length} strokes${costStr}`, false);
          aiDrawGo.disabled = false;
          saveState();
          return;
        }
        const s = strokes[strokeIdx];
        const pts = s.points.map(p => ({
          x: p.x * scale + offsetX,
          y: p.y * scale + offsetY
        }));
        if(pts.length > 0){
          const aiObj = {
            type: 'pen',
            points: pts,
            color: s.color || color,
            lineWidth: Math.max(1, s.width * scale),
            opacity: 1
          };
          objects.push(aiObj);
          collabBroadcast({type:'add', obj: deepClone(aiObj)});
          render();
        }
        strokeIdx++;
        setTimeout(addNextStroke, 30);
      }

      showGuess('Drawing...', true);
      addNextStroke();

    } catch(err){
      if(err.name === 'AbortError') return;
      showGuess('Connection error', false);
      setTimeout(hideGuess, 5000);
      aiDrawGo.disabled = false;
    }
  });

  // --- Multiplayer Collaboration via PeerJS ---
  let collabPeer = null;
  let collabConns = [];
  let collabIsHost = false;
  let collabRoomId = null;   // internal ID (with suffix)
  let collabRoomName = null; // display name (without suffix)
  let collabTotalPeers = 0;  // total people in the room (from host broadcasts)

  const roomInput = document.getElementById('wb-room-input');
  const connectBtn = document.getElementById('wb-connect-btn');
  const collabStatus = document.getElementById('wb-collab-status');
  const collabDot = document.getElementById('wb-collab-dot');
  const collabText = document.getElementById('wb-collab-text');
  const collabHostIcon = document.getElementById('wb-host-icon');
  const collabPeersEl = document.getElementById('wb-collab-peers');
  const collabDisconnectBtn = document.getElementById('wb-disconnect-btn');

  // Chat elements
  const chatEl = document.getElementById('wb-chat');
  const chatMsgs = document.getElementById('wb-chat-msgs');
  const chatInput = document.getElementById('wb-chat-input');
  const chatSendBtn = document.getElementById('wb-chat-send');
  const chatNickInput = document.getElementById('wb-chat-nick');
  const chatToggleBtn = document.getElementById('wb-chat-toggle');
  let chatCollapsed = false;

  const _adj = ['Swift','Bold','Chill','Neon','Pixel','Dusk','Zen','Vivid','Amber','Cobalt','Lucky','Tiny','Warm','Cool','Bright','Silent','Wild','Calm','Fuzzy','Misty','Snowy','Stormy','Sunny','Rusty','Dizzy','Lazy','Witty','Jolly','Brave','Spicy'];
  const _noun = ['Fox','Owl','Cat','Wolf','Bear','Lynx','Crow','Hare','Frog','Moth','Panda','Otter','Raven','Finch','Whale','Shark','Tiger','Koala','Moose','Llama','Gecko','Robin','Crane','Bison','Viper','Sloth','Dingo','Hippo','Lemur','Quail'];
  function randomNick(){ return _adj[Math.random()*_adj.length|0] + _noun[Math.random()*_noun.length|0] + (Math.random()*90+10|0); }
  let chatNick = localStorage.getItem('wb-chat-nick') || randomNick();
  if(!localStorage.getItem('wb-chat-nick')) localStorage.setItem('wb-chat-nick', chatNick);
  chatNickInput.value = chatNick;

  chatNickInput.addEventListener('input', () => {
    chatNick = chatNickInput.value.trim() || chatNick;
    localStorage.setItem('wb-chat-nick', chatNick);
  });
  chatNickInput.addEventListener('keydown', (e) => e.stopPropagation());

  // Track last nick to avoid repeating name on consecutive messages
  let lastChatNick = null;

  function chatAppend(nick, text, isMine, sys){
    if(sys){
      const div = document.createElement('div');
      div.className = 'wb-chat-sys';
      div.textContent = text;
      chatMsgs.appendChild(div);
      lastChatNick = null;
    } else {
      const div = document.createElement('div');
      div.className = 'wb-chat-bubble ' + (isMine ? 'mine' : 'theirs');
      // Show nick label if different from last sender
      if(nick !== lastChatNick){
        const label = document.createElement('span');
        label.className = 'wb-chat-nick-label';
        label.textContent = nick;
        div.appendChild(label);
      }
      div.appendChild(document.createTextNode(text));
      lastChatNick = nick;
      chatMsgs.appendChild(div);
    }
    chatMsgs.scrollTop = chatMsgs.scrollHeight;
  }

  function chatSend(){
    const text = chatInput.value.trim();
    if(!text) return;
    chatInput.value = '';
    chatAppend(chatNick, text, true);
    collabBroadcast({type:'chat', nick:chatNick, text});
  }

  chatSendBtn.addEventListener('click', chatSend);
  chatInput.addEventListener('keydown', (e) => {
    e.stopPropagation();
    if(e.key === 'Enter') chatSend();
  });

  chatToggleBtn.addEventListener('click', () => {
    chatCollapsed = !chatCollapsed;
    chatEl.classList.toggle('collapsed', chatCollapsed);
    chatToggleBtn.classList.toggle('shifted', !chatCollapsed);
    chatToggleBtn.querySelector('svg').style.transform = chatCollapsed ? 'rotate(180deg)' : '';
    if(!chatCollapsed) setTimeout(() => chatInput.focus(), 260);
  });

  function chatClear(){
    chatMsgs.innerHTML = '';
    lastChatNick = null;
  }

  function collabUpdateUI(){
    const connected = collabPeer && !collabPeer.destroyed;
    collabStatus.style.display = connected ? 'inline-flex' : 'none';
    const peerCount = collabIsHost ? collabConns.length + 1 : collabTotalPeers;
    collabDot.classList.toggle('on', connected && peerCount > 1);
    collabHostIcon.style.display = connected && collabIsHost ? 'inline' : 'none';
    collabText.textContent = "" // connected ? (collabIsHost ? (peerCount > 1 ? 'Host' : 'Hosting...') : (peerCount > 1 ? 'Connected' : 'Waiting...')) : '';
    collabPeersEl.style.display = peerCount > 1 ? 'inline' : 'none';
    collabPeersEl.textContent = peerCount + '';
    collabDisconnectBtn.style.display = connected ? 'flex' : 'none';
    connectBtn.style.display = connected ? 'none' : 'flex';
    roomInput.disabled = !!connected;
    if(connected && collabRoomName) roomInput.value = collabRoomName;
    chatEl.style.display = connected ? 'flex' : 'none';
    chatToggleBtn.style.display = connected ? 'flex' : 'none';
    if(connected && !chatCollapsed) chatToggleBtn.classList.add('shifted');
    if(!connected){
      chatCollapsed = false;
      chatEl.classList.remove('collapsed');
      chatToggleBtn.classList.remove('shifted');
      chatToggleBtn.querySelector('svg').style.transform = '';
    }
  }

  function collabSend(conn, msg){
    try { conn.send(JSON.stringify(msg)); } catch(e){}
  }

  function collabBroadcast(msg){
    collabConns.forEach(c => collabSend(c, msg));
  }

  function collabHandleMessage(raw, fromConn){
    let msg;
    try { msg = typeof raw === 'string' ? JSON.parse(raw) : raw; } catch(e){ return; }
    if(msg.type === 'sync'){
      objects = deepClone(msg.objects);
      undoStack = [deepClone(objects)];
      redoStack = [];
      render();
    } else if(msg.type === 'add'){
      objects.push(deepClone(msg.obj));
      undoStack.push(deepClone(objects));
      if(undoStack.length > MAX_HISTORY) undoStack.shift();
      redoStack = [];
      render();
    } else if(msg.type === 'undo' || msg.type === 'redo' || msg.type === 'clear' || msg.type === 'erase'){
      objects = deepClone(msg.objects);
      undoStack.push(deepClone(objects));
      if(undoStack.length > MAX_HISTORY) undoStack.shift();
      redoStack = [];
      render();
    } else if(msg.type === 'chat'){
      chatAppend(msg.nick || '?', msg.text || '', false);
    } else if(msg.type === 'join-announce'){
      chatAppend(null, msg.nick + ' joined', false, true);
    } else if(msg.type === 'peers'){
      collabTotalPeers = msg.count || 0;
      collabUpdateUI();
    } else if(msg.type === 'cursor'){
      updateRemoteCursor(msg.id, msg.x, msg.y, msg.nick, msg.color);
    }
    // Host relays to all other guests (except peer count, host sends that itself)
    if(collabIsHost && msg.type !== 'peers'){
      collabConns.forEach(c => {
        if(c !== fromConn) collabSend(c, msg);
      });
    }
  }

  function broadcastPeerCount(){
    if(!collabIsHost) return;
    const count = collabConns.length + 1; // guests + host
    collabBroadcast({type:'peers', count});
  }

  function collabSetupConn(conn){
    collabConns.push(conn);
    collabUpdateUI();
    broadcastPeerCount();
    conn.on('data', (data) => collabHandleMessage(data, conn));
    function onLost(){
      collabConns = collabConns.filter(c => c !== conn);
      if(conn.peer) removeRemoteCursor(conn.peer);
      collabUpdateUI();
      broadcastPeerCount();
      // Guest lost its only connection (to host) — auto-reconnect (max 3 tries)
      if(!collabManualDisconnect && !collabIsHost && collabConns.length === 0 && collabRoomName){
        collabReconnectCount++;
        if(collabReconnectCount <= 3){
          const name = collabRoomName;
          chatAppend(null, 'Connection lost — reconnecting (' + collabReconnectCount + '/3)...', false, true);
          setTimeout(() => connectToRoom(name), 1000);
        } else {
          chatAppend(null, 'Could not reconnect after 3 attempts.', false, true);
        }
      }
    }
    conn.on('close', onLost);
    conn.on('error', onLost);
  }

  function collabSaveSession(){
    try {
      if(collabRoomName){
        localStorage.setItem('wb-room', collabRoomName);
      }
    } catch(e){}
  }

  let collabRetryTimer = null;
  let collabSettled = false; // true once successfully connected or hosting
  let collabReconnectCount = 0; // track reconnection attempts for guests

  // --- Remote cursors ---
  const CURSOR_COLORS = ['#ef4444','#3b82f6','#22c55e','#f59e0b','#a855f7','#ec4899','#14b8a6','#f97316'];
  let myColor = CURSOR_COLORS[Math.random() * CURSOR_COLORS.length | 0];
  const remoteCursors = new Map(); // peerId → {el, timeout}
  let lastCursorBroadcast = 0;

  function worldToScreen(wx, wy){
    const rect = canvas.getBoundingClientRect();
    const sx = wx * zoom + panX;
    const sy = wy * zoom + panY;
    return { x: sx * (rect.width / W), y: sy * (rect.height / H) };
  }

  function updateRemoteCursor(id, wx, wy, nick, clr){
    let entry = remoteCursors.get(id);
    if(!entry){
      const el = document.createElement('div');
      el.className = 'wb-remote-cursor';
      el.innerHTML = '<svg width="16" height="20" viewBox="0 0 16 20"><path d="M0 0l16 12-7 1-4 7z" fill="' + clr + '" stroke="#000" stroke-width="0.8"/></svg>'
        + '<span class="wb-remote-cursor-label" style="background:' + clr + '"></span>';
      area.appendChild(el);
      entry = {el, timeout:null, wx:0, wy:0, nick:'', color:clr};
      remoteCursors.set(id, entry);
    }
    entry.wx = wx; entry.wy = wy; entry.nick = nick; entry.color = clr;
    const label = entry.el.querySelector('.wb-remote-cursor-label');
    label.textContent = nick;
    repositionCursor(entry);
    // Hide after 5s of no updates
    if(entry.timeout) clearTimeout(entry.timeout);
    entry.timeout = setTimeout(()=>{ entry.el.style.display = 'none'; }, 5000);
    entry.el.style.display = '';
  }

  function repositionCursor(entry){
    const pos = worldToScreen(entry.wx, entry.wy);
    entry.el.style.left = pos.x + 'px';
    entry.el.style.top = pos.y + 'px';
  }

  function repositionAllCursors(){
    remoteCursors.forEach(entry => repositionCursor(entry));
  }

  function removeRemoteCursor(id){
    const entry = remoteCursors.get(id);
    if(entry){
      if(entry.timeout) clearTimeout(entry.timeout);
      entry.el.remove();
      remoteCursors.delete(id);
    }
  }

  function removeAllRemoteCursors(){
    remoteCursors.forEach((entry, id) => removeRemoteCursor(id));
  }

  function broadcastCursor(e){
    if(!collabSettled || collabConns.length === 0) return;
    const now = Date.now();
    if(now - lastCursorBroadcast < 50) return; // throttle to ~20fps
    lastCursorBroadcast = now;
    const pos = getPos(e);
    collabBroadcast({type:'cursor', x:pos.x, y:pos.y, nick:chatNick, color:myColor, id:collabPeer?.id || ''});
  }

  function collabCleanup(){
    if(collabRetryTimer){ clearTimeout(collabRetryTimer); collabRetryTimer = null; }
    collabConns.forEach(c => { try { c.close(); } catch(e){} });
    collabConns = [];
    if(collabPeer){ try { collabPeer.destroy(); } catch(e){} }
    collabPeer = null;
    collabIsHost = false;
    collabSettled = false;
    collabTotalPeers = 0;
    removeAllRemoteCursors();
  }

  // Attempt to join as guest. Calls onResult(true) if connected, onResult(false) if failed.
  function tryJoin(name, onResult){
    collabCleanup();
    collabRoomId = name;
    collabPeer = new Peer();
    let done = false;
    function finish(ok){
      if(done) return; done = true;
      onResult(ok);
    }
    collabPeer.on('open', () => {
      const conn = collabPeer.connect(name, {reliable:true});
      conn.on('open', () => {
        collabIsHost = false;
        collabSettled = true;
        collabReconnectCount = 0;
        collabSetupConn(conn);
        collabSend(conn, {type:'join-announce', nick:chatNick});
        collabSaveSession();
        collabUpdateUI();
        finish(true);
      });
      conn.on('error', () => finish(false));
      setTimeout(() => {
        if(!done){ try { conn.close(); } catch(e){} finish(false); }
      }, 2500);
    });
    collabPeer.on('error', () => finish(false));
    collabUpdateUI();
  }

  // Attempt to host. Calls onResult(true) if registered, onResult(false) if ID taken.
  function tryHost(name, onResult){
    collabCleanup();
    collabRoomId = name;
    collabPeer = new Peer(name);
    let done = false;
    function finish(ok){
      if(done) return; done = true;
      onResult(ok);
    }
    collabPeer.on('open', () => {
      collabIsHost = true;
      collabSettled = true;
      collabSaveSession();
      collabUpdateUI();
      chatAppend(null, 'Room created — waiting for others', false, true);
      finish(true);
    });
    collabPeer.on('connection', (conn) => {
      conn.on('open', () => {
        collabSetupConn(conn);
        collabSend(conn, {type:'sync', objects: deepClone(objects)});
      });
    });
    collabPeer.on('error', (err) => {
      if(err.type === 'unavailable-id'){
        try { collabPeer.destroy(); } catch(e){} collabPeer = null;
        finish(false);
      } else {
        console.warn('PeerJS error:', err);
        finish(false);
      }
    });
    // If host loses signaling server connection, re-register
    collabPeer.on('disconnected', () => {
      if(collabSettled && collabIsHost && collabRoomName){
        try { collabPeer.reconnect(); } catch(e){
          const n = collabRoomName;
          chatAppend(null, 'Lost server — reconnecting...', false, true);
          setTimeout(() => connectToRoom(n), 1000);
        }
      }
    });
    collabUpdateUI();
  }

  // Keep alternating join/host until one succeeds
  function connectToRoom(displayName){
    if(!displayName) return;
    const peerId = displayName + '-atatomir-com';
    collabManualDisconnect = false;
    collabCleanup();
    collabRoomName = displayName;
    collabRoomId = peerId;
    collabUpdateUI();
    let attempt = 0;

    function cycle(){
      if(collabSettled || collabRoomId !== peerId) return;
      attempt++;
      if(attempt % 2 === 1){
        tryJoin(peerId, (ok) => {
          if(ok || collabSettled) return;
          cycle();
        });
      } else {
        tryHost(peerId, (ok) => {
          if(ok || collabSettled) return;
          collabRetryTimer = setTimeout(cycle, 1500);
        });
      }
    }
    cycle();
  }

  let collabManualDisconnect = false;

  function collabDisconnect(){
    collabManualDisconnect = true;
    if(collabRetryTimer){ clearTimeout(collabRetryTimer); collabRetryTimer = null; }
    collabCleanup();
    collabRoomId = null;
    collabRoomName = null;
    chatClear();
    collabUpdateUI();
  }

  connectBtn.addEventListener('click', () => {
    const name = roomInput.value.trim() || 'main';
    connectToRoom(name);
  });

  roomInput.addEventListener('keydown', (e) => {
    e.stopPropagation();
    if(e.key === 'Enter') connectBtn.click();
  });

  collabDisconnectBtn.addEventListener('click', () => collabDisconnect());

  // Auto-connect on load
  {
    const savedRoom = localStorage.getItem('wb-room');
    roomInput.value = savedRoom;
  }

})();

// --- Screen Recorder ---
(function(){
  const fab = document.getElementById('rec-fab');
  const panel = document.getElementById('rec-panel');
  const panelTitle = document.getElementById('rec-panel-title');
  const panelClose = document.getElementById('rec-panel-close');
  const timerEl = document.getElementById('rec-timer');
  const actions = document.getElementById('rec-actions');
  const library = document.getElementById('rec-library');
  const startBtn = document.getElementById('rec-start');

  let mediaRecorder = null;
  let recordedChunks = [];
  let stream = null;
  let timerInterval = null;
  let startTime = 0;
  let mimeType = 'video/webm';

  // Library: array of { blobUrl, duration, timestamp }
  const recordings = [];

  function formatTime(ms){
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    const ss = s % 60;
    return `${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
  }

  function formatTimestamp(ts){
    const d = new Date(ts);
    return d.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' });
  }

  function showPanel(){ panel.classList.add('visible'); }
  function hidePanel(){ panel.classList.remove('visible'); }

  function setIdle(){
    fab.classList.remove('recording');
    fab.innerHTML = '<svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="4" fill="currentColor" stroke="none"/></svg>';
    timerEl.style.display = 'none';
    panelTitle.textContent = 'Screen Recorder';
    actions.innerHTML = `<button class="rec-btn-rec" id="rec-start-btn">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none"><circle cx="12" cy="12" r="10"/></svg>
      Record</button>`;
    document.getElementById('rec-start-btn').addEventListener('click', startRecording);
  }

  function setRecording(){
    fab.classList.add('recording');
    fab.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>';
    panelTitle.textContent = 'Recording...';
    timerEl.style.display = 'block';
    timerEl.textContent = '00:00';
    actions.innerHTML = '<button class="rec-btn-stop" id="rec-stop"><svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" rx="2"/></svg> Stop</button>';
    document.getElementById('rec-stop').addEventListener('click', stopRecording);
  }

  function renderLibrary(){
    if(recordings.length === 0){
      library.innerHTML = '<div class="rec-empty">No recordings yet</div>';
      return;
    }
    library.innerHTML = '<div class="rec-library-title">Recordings</div>';
    // Show newest first
    for(let i = recordings.length - 1; i >= 0; i--){
      const rec = recordings[i];
      const item = document.createElement('div');
      item.className = 'rec-item';
      item.innerHTML = `
        <video src="${rec.blobUrl}" controls playsinline preload="metadata"></video>
        <div class="rec-item-meta">
          <span class="rec-item-info">${formatTimestamp(rec.timestamp)} &middot; ${formatTime(rec.duration)}</span>
          <div class="rec-item-actions">
            <button class="rec-item-dl" data-idx="${i}"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg> Save</button>
            <button class="rec-item-trim" data-idx="${i}"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><line x1="20" y1="4" x2="8.12" y2="15.88"/><line x1="14.47" y1="14.48" x2="20" y2="20"/><line x1="8.12" y1="8.12" x2="12" y2="12"/></svg> Trim</button>
            <button class="rec-item-del" data-idx="${i}"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/><path d="M19 6l-1 14a2 2 0 01-2 2H8a2 2 0 01-2-2L5 6"/></svg></button>
          </div>
        </div>`;
      library.appendChild(item);
    }

    library.querySelectorAll('.rec-item-dl').forEach(btn => {
      btn.addEventListener('click', ()=>{
        const idx = parseInt(btn.dataset.idx);
        const rec = recordings[idx];
        const a = document.createElement('a');
        a.href = rec.blobUrl;
        const ts = new Date(rec.timestamp).toISOString().replace(/[:.]/g,'-').slice(0,19);
        a.download = `recording-${ts}.webm`;
        a.click();
      });
    });

    library.querySelectorAll('.rec-item-del').forEach(btn => {
      btn.addEventListener('click', ()=>{
        const idx = parseInt(btn.dataset.idx);
        URL.revokeObjectURL(recordings[idx].blobUrl);
        recordings.splice(idx, 1);
        renderLibrary();
      });
    });

    // Trim button: open overlay
    library.querySelectorAll('.rec-item-trim').forEach(btn => {
      btn.addEventListener('click', ()=> openTrimOverlay(parseInt(btn.dataset.idx)));
    });
  }

  // --- Trim overlay ---
  let trimOverlay = null;

  function formatTimeSec(sec){
    sec = Math.max(0, sec);
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    const ms = Math.floor((sec % 1) * 10);
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${ms}`;
  }

  function openTrimOverlay(idx){
    closeTrimOverlay();
    const rec = recordings[idx];
    const dur = rec.duration / 1000;

    const overlay = document.createElement('div');
    overlay.className = 'rec-trim-overlay visible';
    overlay._trimStart = 0;
    overlay._trimEnd = dur;
    overlay._duration = dur;
    overlay._idx = idx;

    overlay.innerHTML = `
      <video src="${rec.blobUrl}" controls playsinline preload="auto"></video>
      <div class="rec-trim-controls">
        <div class="rec-trim-times">
          <span class="rec-trim-start">${formatTimeSec(0)}</span>
          <span class="rec-trim-end">${formatTimeSec(dur)}</span>
        </div>
        <div class="rec-trim-track">
          <div class="rec-trim-range" style="left:0%;width:100%"></div>
          <div class="rec-trim-handle rec-trim-handle-start" style="left:0%"></div>
          <div class="rec-trim-handle rec-trim-handle-end" style="left:100%"></div>
        </div>
        <div class="rec-trim-actions">
          <button class="rec-trim-save">✂ Save Trimmed</button>
          <button class="rec-trim-cancel">Cancel</button>
        </div>
      </div>`;

    document.body.appendChild(overlay);
    trimOverlay = overlay;

    const video = overlay.querySelector('video');
    const track = overlay.querySelector('.rec-trim-track');

    // Handle dragging
    let activeHandle = null;

    track.addEventListener('pointerdown', e => {
      const rect = track.getBoundingClientRect();
      const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      const time = pct * overlay._duration;
      const dStart = Math.abs(time - overlay._trimStart);
      const dEnd = Math.abs(time - overlay._trimEnd);
      activeHandle = dStart <= dEnd ? 'start' : 'end';
      moveHandle(e);
      track.setPointerCapture(e.pointerId);
    });

    function moveHandle(e){
      const rect = track.getBoundingClientRect();
      const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      const time = pct * overlay._duration;
      if(activeHandle === 'start'){
        overlay._trimStart = Math.max(0, Math.min(time, overlay._trimEnd - 0.1));
      } else {
        overlay._trimEnd = Math.min(overlay._duration, Math.max(time, overlay._trimStart + 0.1));
      }
      updateTrimOverlay(overlay);
      if(video.duration) video.currentTime = activeHandle === 'start' ? overlay._trimStart : overlay._trimEnd;
    }

    track.addEventListener('pointermove', e => { if(activeHandle) moveHandle(e); });
    track.addEventListener('pointerup', () => { activeHandle = null; });
    track.addEventListener('pointercancel', () => { activeHandle = null; });

    // Cancel
    overlay.querySelector('.rec-trim-cancel').addEventListener('click', closeTrimOverlay);

    // Close on Escape
    overlay._onKey = e => { if(e.key === 'Escape') closeTrimOverlay(); };
    document.addEventListener('keydown', overlay._onKey);

    // Save trimmed
    overlay.querySelector('.rec-trim-save').addEventListener('click', ()=> saveTrimmed(overlay));
  }

  function updateTrimOverlay(overlay){
    const startPct = (overlay._trimStart / overlay._duration) * 100;
    const endPct = (overlay._trimEnd / overlay._duration) * 100;
    overlay.querySelector('.rec-trim-range').style.left = startPct + '%';
    overlay.querySelector('.rec-trim-range').style.width = (endPct - startPct) + '%';
    overlay.querySelector('.rec-trim-handle-start').style.left = startPct + '%';
    overlay.querySelector('.rec-trim-handle-end').style.left = endPct + '%';
    overlay.querySelector('.rec-trim-start').textContent = formatTimeSec(overlay._trimStart);
    overlay.querySelector('.rec-trim-end').textContent = formatTimeSec(overlay._trimEnd);
  }

  function closeTrimOverlay(){
    if(!trimOverlay) return;
    const video = trimOverlay.querySelector('video');
    if(video) video.pause();
    if(trimOverlay._onKey) document.removeEventListener('keydown', trimOverlay._onKey);
    trimOverlay.remove();
    trimOverlay = null;
  }

  async function saveTrimmed(overlay){
    const idx = overlay._idx;
    const rec = recordings[idx];
    const trimStart = overlay._trimStart;
    const trimEnd = overlay._trimEnd;
    const saveBtn = overlay.querySelector('.rec-trim-save');
    saveBtn.disabled = true;
    saveBtn.textContent = 'Trimming...';

    try {
      const video = document.createElement('video');
      video.src = rec.blobUrl;
      video.muted = true;
      video.playsInline = true;
      video.preload = 'auto';

      await new Promise((resolve, reject) => {
        video.onloadedmetadata = resolve;
        video.onerror = reject;
      });

      video.currentTime = trimStart;
      await new Promise(r => { video.onseeked = r; });

      const captureStream = video.captureStream();
      const trimMime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9')
        ? 'video/webm;codecs=vp9' : 'video/webm';
      const trimRecorder = new MediaRecorder(captureStream, { mimeType: trimMime });
      const chunks = [];

      trimRecorder.ondataavailable = e => { if(e.data.size > 0) chunks.push(e.data); };

      const done = new Promise(resolve => { trimRecorder.onstop = resolve; });

      trimRecorder.start(100);
      video.play();

      await new Promise(resolve => {
        function check(){
          if(video.currentTime >= trimEnd || video.ended || video.paused){
            video.pause();
            trimRecorder.stop();
            resolve();
          } else {
            requestAnimationFrame(check);
          }
        }
        check();
      });

      await done;

      const blob = new Blob(chunks, { type: trimMime });
      const blobUrl = URL.createObjectURL(blob);
      const duration = (trimEnd - trimStart) * 1000;
      recordings.push({ blobUrl, duration, timestamp: Date.now() });
      closeTrimOverlay();
      renderLibrary();
    } catch(e) {
      console.error('Trim failed:', e);
      saveBtn.disabled = false;
      saveBtn.textContent = '✂ Save Trimmed';
    }
  }

  async function startRecording(){
    try {
      stream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: true
      });
    } catch(e){
      return; // User cancelled
    }

    recordedChunks = [];
    mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9')
      ? 'video/webm;codecs=vp9'
      : 'video/webm';
    mediaRecorder = new MediaRecorder(stream, { mimeType });

    mediaRecorder.ondataavailable = (e) => {
      if(e.data.size > 0) recordedChunks.push(e.data);
    };

    mediaRecorder.onstop = () => {
      const duration = Date.now() - startTime;
      clearInterval(timerInterval);
      stream.getTracks().forEach(t => t.stop());
      stream = null;

      const blob = new Blob(recordedChunks, { type: mimeType });
      const blobUrl = URL.createObjectURL(blob);
      recordings.push({ blobUrl, duration, timestamp: Date.now() });

      setIdle();
      renderLibrary();
      showPanel();
    };

    // Stop if user ends sharing via browser UI
    stream.getVideoTracks()[0].addEventListener('ended', () => {
      if(mediaRecorder && mediaRecorder.state !== 'inactive'){
        mediaRecorder.stop();
      }
    });

    mediaRecorder.start(100);
    startTime = Date.now();
    timerInterval = setInterval(() => {
      timerEl.textContent = formatTime(Date.now() - startTime);
    }, 500);

    setRecording();
    showPanel();
  }

  function stopRecording(){
    if(mediaRecorder && mediaRecorder.state !== 'inactive'){
      mediaRecorder.stop();
    }
  }

  // FAB click: toggle panel, or stop if recording
  fab.addEventListener('click', ()=>{
    if(mediaRecorder && mediaRecorder.state === 'recording'){
      stopRecording();
      return;
    }
    panel.classList.toggle('visible');
  });

  panelClose.addEventListener('click', hidePanel);

  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape' && panel.classList.contains('visible')){
      hidePanel();
    }
  });

  // Init
  startBtn.addEventListener('click', startRecording);
  renderLibrary();
})();
</script>

</body>
</html>
