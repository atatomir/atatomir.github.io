<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Games • TATOMIR N. ALEX</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg-dark:#0b0d10;
  --bg-deep:#0f172a;
  --panel: rgba(255,255,255,0.06);
  --ink:#f5f7fa;
  --muted:#9aa3b2;
  --accent:#4f8cff;
}
*{margin:0;padding:0;box-sizing:border-box}
html{scroll-behavior:smooth}
body{
  font-family: 'Inter', sans-serif;
  color: var(--ink);
  line-height:1.7;
  background: linear-gradient(180deg, #0b0d10 0%, #0f172a 100%);
  background-attachment: fixed;
  background-size: cover;
}

/* NAV */
nav{
  position: fixed;
  top:20px;
  left:50%;
  transform: translateX(-50%);
  z-index:100;
  backdrop-filter: blur(16px);
  background: var(--panel);
  border:1px solid rgba(255,255,255,0.08);
  border-radius:999px;
  padding:10px 22px;
  display:flex;
  gap:16px;
  align-items:center;
}
nav a{
  color: var(--muted);
  text-decoration: none;
  font-weight:500;
  margin:0 10px;
  font-size:14px;
}
nav a:hover{color: var(--accent);}
#lang-toggle{
  margin-left:12px;
  cursor:pointer;
  background: var(--accent);
  border:none;
  border-radius:999px;
  padding:6px 12px;
  font-weight:600;
  color:white;
  font-size:13px;
  transition:0.2s;
}
#lang-toggle:hover{background:#3570d1;}

/* SECTIONS */
section{
  max-width:1100px;
  margin:0 auto;
  padding:120px 24px 60px;
}
.section-title{
  font-size:12px;
  text-transform:uppercase;
  letter-spacing:0.18em;
  color:var(--muted);
  margin-bottom:18px;
}
.section-heading{
  font-size: clamp(2rem, 4vw, 2.8rem);
  font-weight:700;
  letter-spacing:-0.02em;
  margin-bottom:28px;
}

/* REVEAL ANIMATION */
.reveal{
  opacity:0;
  transform: translateY(24px);
  transition:0.8s ease;
}
.reveal.visible{
  opacity:1;
  transform:none;
}

/* FOOTER */
footer{
  text-align:center;
  padding:60px 24px 40px;
  color:var(--muted);
  font-size:13px;
  border-top:1px solid rgba(255,255,255,0.06);
}

/* GAMES LAYOUT */
#games{text-align:center;}
.games-row{
  display:flex;
  gap:32px;
  justify-content:center;
  align-items:flex-start;
  flex-wrap:wrap;
}
.game-col{
  flex:0 1 440px;
  min-width:0;
}

/* GAME TOOLBAR */
.game-toolbar{
  display:flex;justify-content:space-between;align-items:center;
  margin-bottom:12px;padding:0 4px;
}
.game-toolbar-btns{display:flex;gap:4px;}
.game-toolbar-btn{
  background:none;border:none;color:var(--muted);font-size:16px;
  cursor:pointer;padding:4px 6px;border-radius:6px;transition:0.2s;
  display:flex;align-items:center;justify-content:center;
}
.game-toolbar-btn:hover{color:var(--ink);background:rgba(255,255,255,0.08);}

/* SNAKE GAME */
.snake-score-bar{
  display:flex;
  gap:32px;
  font-size:14px;
  color:var(--muted);
}
.snake-score-bar span{color:var(--accent);font-weight:600;}
.snake-canvas-wrap{
  position:relative;
  display:inline-block;
  border-radius:14px;
  overflow:hidden;
  border:2px solid rgba(79,140,255,0.35);
  box-shadow:0 0 30px rgba(79,140,255,0.1);
}
#snake-canvas{display:block;background:#0b0d10;max-width:100%;height:auto;}
.snake-overlay{
  position:absolute;inset:0;
  display:flex;flex-direction:column;
  align-items:center;justify-content:center;
  background:rgba(11,13,16,0.82);
  backdrop-filter:blur(6px);
  z-index:2;
  transition:opacity 0.3s;
}
.snake-overlay.hidden{opacity:0;pointer-events:none;}
.snake-overlay h3{font-size:1.6rem;margin-bottom:8px;}
.snake-overlay p{color:var(--muted);margin-bottom:18px;font-size:0.95rem;}
.snake-overlay .snake-final-score{font-size:2rem;font-weight:700;color:var(--accent);margin-bottom:6px;}
.snake-btn{
  padding:12px 28px;border:none;border-radius:999px;
  background:var(--accent);color:#fff;font-weight:600;font-size:14px;
  cursor:pointer;transition:0.2s;margin:4px;
}
.snake-btn:hover{background:#3570d1;transform:translateY(-1px);}
.snake-btn.secondary-btn{
  background:transparent;border:1px solid rgba(255,255,255,0.15);color:var(--ink);
}
.snake-btn.secondary-btn:hover{background:rgba(255,255,255,0.05);}
.snake-initials-input{
  background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);
  border-radius:8px;padding:8px 12px;color:var(--ink);font-size:1rem;
  text-align:center;width:80px;text-transform:uppercase;font-weight:600;
  margin-bottom:10px;outline:none;
}
.snake-initials-input:focus{border-color:var(--accent);}
.snake-leaderboard{
  margin:28px auto 0;max-width:340px;
  backdrop-filter:blur(16px);background:var(--panel);
  border:1px solid rgba(255,255,255,0.08);border-radius:14px;
  padding:20px 24px;
}
.snake-leaderboard h4{font-size:13px;text-transform:uppercase;letter-spacing:0.14em;color:var(--muted);margin-bottom:12px;}
.snake-leaderboard table{width:100%;border-collapse:collapse;font-size:14px;}
.snake-leaderboard th{color:var(--muted);font-weight:500;text-align:left;padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.06);}
.snake-leaderboard td{padding:6px 0;}
.snake-leaderboard td:last-child{text-align:right;color:var(--accent);font-weight:600;}
.snake-dpad{
  display:none;
  margin:18px auto 0;
  width:160px;height:160px;
  position:relative;
}
.snake-dpad button{
  position:absolute;width:50px;height:50px;
  border:none;border-radius:10px;
  background:var(--panel);backdrop-filter:blur(8px);
  border:1px solid rgba(255,255,255,0.1);
  color:var(--ink);font-size:20px;cursor:pointer;
  display:flex;align-items:center;justify-content:center;
  transition:0.15s;-webkit-tap-highlight-color:transparent;
  user-select:none;
}
.snake-dpad button:active{background:rgba(79,140,255,0.25);}
.snake-dpad .d-up{top:0;left:55px;}
.snake-dpad .d-down{bottom:0;left:55px;}
.snake-dpad .d-left{top:55px;left:0;}
.snake-dpad .d-right{top:55px;right:0;}

/* TRADING GAME */
.trade-panel{
  position:relative;
  backdrop-filter:blur(16px);background:var(--panel);
  border:1px solid rgba(255,255,255,0.08);border-radius:14px;
  padding:20px;text-align:center;
}
.trade-panel h3{font-size:1.1rem;font-weight:600;margin-bottom:12px;}
.trade-info{
  display:flex;justify-content:center;margin-bottom:14px;font-size:13px;color:var(--muted);
}
.trade-info > div{flex:1 1 0;min-width:0;text-align:center;}
.trade-info span{display:block;font-size:1.05rem;font-weight:600;color:var(--ink);margin-top:2px;font-variant-numeric:tabular-nums;}
.trade-info .pnl-pos{color:#34d399;}
.trade-info .pnl-neg{color:#ef4444;}
.trade-canvas-wrap{
  position:relative;border-radius:10px;overflow:hidden;
  border:1px solid rgba(255,255,255,0.08);margin-bottom:14px;
}
#trade-canvas{display:block;width:100%;height:auto;}
.trade-overlay{
  position:absolute;inset:0;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  background:rgba(11,13,16,0.82);backdrop-filter:blur(6px);z-index:2;transition:opacity 0.3s;
}
.trade-overlay.hidden{opacity:0;pointer-events:none;}
.trade-overlay h3{font-size:1.4rem;margin-bottom:0;}
.trade-overlay p{color:var(--muted);margin-bottom:1px;font-size:0.9rem;}
.trade-result{font-size:1.6rem;font-weight:700;margin-bottom:0;}
.trade-btns{display:flex;gap:8px;justify-content:center;}
.trade-btn{
  padding:10px 22px;border:none;border-radius:999px;
  font-weight:600;font-size:14px;cursor:pointer;transition:0.2s;
}
.trade-btn:hover{transform:translateY(-1px);}
.trade-btn.buy{background:#34d399;color:#0b0d10;}
.trade-btn.buy:hover{background:#2ab884;}
.trade-btn.sell{background:#ef4444;color:#fff;}
.trade-btn.sell:hover{background:#d63535;}
.trade-btn.start{background:var(--accent);color:#fff;}
.trade-btn.start:hover{background:#3570d1;}
.trade-position-bar{
  display:flex;align-items:center;justify-content:center;gap:6px;
  margin-bottom:14px;font-size:13px;color:var(--muted);
}
.trade-pos-dots{display:flex;gap:2px;align-items:center;}
.trade-pos-dot{
  width:7px;height:7px;border-radius:50%;
  background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);
  transition:0.15s;
}
.trade-pos-dot.zero{width:9px;height:9px;border-color:rgba(255,255,255,0.25);}
.trade-pos-dot.long{background:#34d399;border-color:#34d399;}
.trade-pos-dot.short{background:#ef4444;border-color:#ef4444;}
.trade-timer{
  height:3px;background:rgba(255,255,255,0.06);border-radius:2px;margin-bottom:14px;overflow:hidden;
}
.trade-timer-fill{height:100%;background:var(--accent);transition:width 0.1s linear;width:0%;}
.trade-btn.end{background:transparent;border:1px solid rgba(255,255,255,0.15);color:var(--ink);}
.trade-btn.end:hover{background:rgba(255,255,255,0.05);}
.trade-hint{margin-top:10px;font-size:11px;color:var(--muted);line-height:1.6;}
.trade-hint kbd{
  display:inline-block;padding:1px 6px;border-radius:4px;font-size:10px;font-family:inherit;
  background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);
  color:var(--ink);vertical-align:1px;
}
.trade-paused-badge{
  display:none;align-items:center;justify-content:center;gap:6px;
  margin-bottom:10px;font-size:13px;font-weight:600;color:#fbbf24;
}
.trade-paused-badge.visible{display:flex;}
.trade-log{margin-top:16px;}
.trade-log h4{font-size:13px;text-transform:uppercase;letter-spacing:0.14em;color:var(--muted);margin-bottom:10px;}
.trade-log-scroll{max-height:150px;overflow-y:auto;scrollbar-width:thin;scrollbar-color:rgba(255,255,255,0.1) transparent;}
.trade-log table{width:100%;border-collapse:collapse;font-size:12px;font-variant-numeric:tabular-nums;}
.trade-log th{color:var(--muted);font-weight:500;text-align:left;padding:3px 4px;border-bottom:1px solid rgba(255,255,255,0.06);font-size:11px;position:sticky;top:0;background:rgba(15,23,42,0.95);}
.trade-log td{padding:4px;white-space:nowrap;}
.trade-log td:last-child{text-align:right;font-weight:600;}
.lb-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;}
.lb-header h4{margin:0;}
.lb-clear-btn{
  background:none;border:none;color:var(--muted);font-size:14px;
  cursor:pointer;padding:2px 4px;border-radius:4px;transition:0.2s;line-height:1;
}
.lb-clear-btn:hover{color:#ef4444;background:rgba(239,68,68,0.1);}
.trade-lb{margin-top:16px;}
.trade-lb h4{font-size:13px;text-transform:uppercase;letter-spacing:0.14em;color:var(--muted);margin-bottom:10px;}
.trade-lb table{width:100%;border-collapse:collapse;font-size:14px;}
.trade-lb th{color:var(--muted);font-weight:500;text-align:left;padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.06);}
.trade-lb td{padding:6px 0;}
.trade-lb td:last-child{text-align:right;font-weight:600;}

/* GAME SETTINGS (shared) */
.game-settings-modal{
  position:absolute;inset:0;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  background:rgba(11,13,16,0.88);backdrop-filter:blur(8px);z-index:10;
  transition:opacity 0.3s;
}
.game-settings-modal.hidden{opacity:0;pointer-events:none;}
.game-settings-inner{width:85%;max-width:300px;text-align:left;}
.game-settings-inner h4{font-size:13px;text-transform:uppercase;letter-spacing:0.14em;color:var(--muted);margin-bottom:14px;text-align:center;}
.game-settings-row{
  display:flex;justify-content:space-between;align-items:center;
  margin-bottom:10px;font-size:13px;color:var(--ink);
}
.game-settings-row label{color:var(--muted);}
.game-settings-select{
  background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);
  border-radius:6px;padding:4px 8px;color:var(--ink);font-size:12px;
  font-family:inherit;outline:none;cursor:pointer;
}
.game-settings-select:focus{border-color:var(--accent);}
.game-settings-close{
  margin-top:10px;width:100%;padding:8px;border:none;border-radius:8px;
  background:rgba(255,255,255,0.08);color:var(--ink);font-weight:600;font-size:12px;
  cursor:pointer;transition:0.2s;font-family:inherit;
}
.game-settings-close:hover{background:rgba(255,255,255,0.15);}

/* WHITEBOARD */
.wb-wrap{
  width:100%;margin-top:32px;
  backdrop-filter:blur(16px);background:var(--panel);
  border:1px solid rgba(255,255,255,0.08);border-radius:14px;
  padding:0;overflow:hidden;position:relative;
}
.wb-toolbar{
  display:flex;align-items:center;gap:6px;padding:10px 14px;
  border-bottom:1px solid rgba(255,255,255,0.08);
  flex-wrap:wrap;background:rgba(0,0,0,0.15);
}
.wb-toolbar-group{display:flex;align-items:center;gap:3px;}
.wb-sep{width:1px;height:22px;background:rgba(255,255,255,0.1);margin:0 6px;}
.wb-btn{
  background:none;border:1px solid transparent;color:var(--muted);
  cursor:pointer;padding:5px 7px;border-radius:6px;transition:0.15s;
  display:flex;align-items:center;justify-content:center;font-size:14px;
  min-width:30px;height:30px;
}
.wb-btn:hover{color:var(--ink);background:rgba(255,255,255,0.08);}
.wb-btn.active{color:var(--accent);background:rgba(79,140,255,0.15);border-color:rgba(79,140,255,0.3);}
.wb-btn svg{pointer-events:none;}
.wb-color-btn{
  width:22px;height:22px;border-radius:50%;border:2px solid rgba(255,255,255,0.15);
  cursor:pointer;transition:0.15s;padding:0;flex-shrink:0;
}
.wb-color-btn:hover,.wb-color-btn.active{border-color:var(--accent);transform:scale(1.15);}
.wb-size-slider{
  -webkit-appearance:none;appearance:none;width:70px;height:4px;
  background:rgba(255,255,255,0.15);border-radius:2px;outline:none;cursor:pointer;
}
.wb-size-slider::-webkit-slider-thumb{
  -webkit-appearance:none;width:14px;height:14px;border-radius:50%;
  background:var(--accent);cursor:pointer;border:none;
}
.wb-size-slider::-moz-range-thumb{
  width:14px;height:14px;border-radius:50%;
  background:var(--accent);cursor:pointer;border:none;
}
.wb-size-label{font-size:11px;color:var(--muted);min-width:22px;text-align:center;}
.wb-canvas-area{
  position:relative;cursor:crosshair;background:#181b22;
  touch-action:none;
}
#wb-canvas{display:block;width:100%;height:auto;}
.wb-wrap:fullscreen{
  display:flex;flex-direction:column;background:#0b0d10;width:100%;height:100%;
}
.wb-wrap:fullscreen .wb-canvas-area{flex:1;min-height:0;}
.wb-wrap:fullscreen #wb-canvas{width:100%;height:100%;max-width:none;}
.wb-toolbar-right{margin-left:auto;display:flex;align-items:center;gap:3px;}
.wb-fill-toggle{font-size:11px;color:var(--muted);display:flex;align-items:center;gap:4px;cursor:pointer;user-select:none;}
.wb-fill-toggle input{accent-color:var(--accent);cursor:pointer;}
.wb-color-picker{
  width:22px;height:22px;border-radius:50%;border:2px solid rgba(255,255,255,0.15);
  cursor:pointer;padding:0;-webkit-appearance:none;appearance:none;background:none;
  overflow:hidden;flex-shrink:0;
}
.wb-color-picker::-webkit-color-swatch-wrapper{padding:0;}
.wb-color-picker::-webkit-color-swatch{border:none;border-radius:50%;}
.wb-color-picker::-moz-color-swatch{border:none;border-radius:50%;}
.wb-color-picker:hover{border-color:var(--accent);transform:scale(1.15);}
.wb-opacity-slider{
  -webkit-appearance:none;appearance:none;width:50px;height:4px;
  background:linear-gradient(to right,transparent,var(--ink));border-radius:2px;outline:none;cursor:pointer;
}
.wb-opacity-slider::-webkit-slider-thumb{
  -webkit-appearance:none;width:12px;height:12px;border-radius:50%;
  background:var(--ink);cursor:pointer;border:2px solid var(--accent);
}
.wb-opacity-slider::-moz-range-thumb{
  width:12px;height:12px;border-radius:50%;
  background:var(--ink);cursor:pointer;border:2px solid var(--accent);
}
.wb-text-input{
  position:absolute;background:transparent;border:1px dashed rgba(79,140,255,0.6);
  color:inherit;font-family:'Inter',sans-serif;outline:none;padding:4px 6px;
  z-index:5;min-width:40px;resize:none;overflow:hidden;line-height:1.3;
  word-wrap:break-word;white-space:pre-wrap;box-sizing:border-box;
}
.wb-grid-canvas{
  position:absolute;top:0;left:0;width:100%;height:100%;
  pointer-events:none;opacity:0;transition:opacity 0.2s;
}
.wb-grid-canvas.visible{opacity:1;}
.wb-zoom-btn{min-width:26px;height:26px;padding:3px;}
.wb-zoom-label{
  font-size:11px;color:var(--muted);min-width:36px;text-align:center;
  cursor:pointer;user-select:none;padding:2px 4px;border-radius:4px;
}
.wb-zoom-label:hover{color:var(--ink);background:rgba(255,255,255,0.06);}
.wb-canvas-area.panning{cursor:grab !important;}
.wb-canvas-area.panning-active{cursor:grabbing !important;}
/* AI Guess */
.wb-ai-btn.active{color:#facc15;background:rgba(250,204,21,0.15);border-color:rgba(250,204,21,0.3);}
.wb-ai-popover{
  position:absolute;top:100%;right:0;margin-top:6px;z-index:20;
  background:#1e2130;border:1px solid rgba(255,255,255,0.12);border-radius:10px;
  padding:12px 14px;min-width:260px;box-shadow:0 8px 32px rgba(0,0,0,0.5);
  display:none;
}
.wb-ai-popover.visible{display:block;}
.wb-ai-popover label{font-size:11px;color:var(--muted);display:block;margin-bottom:4px;}
.wb-ai-popover input[type="password"]{
  width:100%;box-sizing:border-box;padding:6px 8px;border-radius:6px;
  border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.3);
  color:var(--ink);font-size:12px;font-family:inherit;outline:none;
}
.wb-ai-popover input[type="password"]:focus{border-color:var(--accent);}
.wb-ai-popover .wb-ai-row{display:flex;align-items:center;gap:6px;margin-top:8px;}
.wb-ai-popover .wb-ai-save{
  padding:4px 12px;border-radius:6px;border:none;
  background:var(--accent);color:#fff;font-size:12px;cursor:pointer;font-family:inherit;
}
.wb-ai-popover .wb-ai-save:hover{opacity:0.85;}
.wb-ai-popover .wb-ai-status{font-size:10px;color:var(--muted);}
.wb-ai-draw-popover{
  position:absolute;top:100%;right:0;margin-top:6px;z-index:20;
  background:#1e2130;border:1px solid rgba(255,255,255,0.12);border-radius:10px;
  padding:12px 14px;min-width:300px;box-shadow:0 8px 32px rgba(0,0,0,0.5);
  display:none;
}
.wb-ai-draw-popover.visible{display:block;}
.wb-ai-draw-popover label{font-size:11px;color:var(--muted);display:block;margin-bottom:4px;}
.wb-ai-draw-popover input[type="text"]{
  width:100%;box-sizing:border-box;padding:6px 8px;border-radius:6px;
  border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.3);
  color:var(--ink);font-size:12px;font-family:inherit;outline:none;
}
.wb-ai-draw-popover input[type="text"]:focus{border-color:var(--accent);}
.wb-ai-draw-popover .wb-ai-draw-row{display:flex;align-items:center;gap:6px;margin-top:8px;}
.wb-ai-draw-popover .wb-ai-draw-go{
  padding:4px 12px;border-radius:6px;border:none;
  background:var(--accent);color:#fff;font-size:12px;cursor:pointer;font-family:inherit;
}
.wb-ai-draw-popover .wb-ai-draw-go:hover{opacity:0.85;}
.wb-ai-draw-popover .wb-ai-draw-status{font-size:10px;color:var(--muted);}
.wb-ai-guess{
  position:absolute;bottom:12px;left:50%;transform:translateX(-50%);
  background:rgba(20,22,30,0.88);backdrop-filter:blur(10px);
  border:1px solid rgba(255,255,255,0.1);border-radius:20px;
  padding:6px 16px;font-size:13px;color:var(--ink);
  pointer-events:none;opacity:0;transition:opacity 0.3s;
  white-space:nowrap;z-index:10;
}
.wb-ai-guess.visible{opacity:1;pointer-events:auto;}
.wb-ai-guess .wb-ai-icon{margin-right:6px;}
@keyframes wb-pulse{0%,100%{opacity:0.4;}50%{opacity:1;}}
.wb-ai-guess.loading .wb-ai-icon{animation:wb-pulse 1s infinite;}

/* FULLSCREEN */
.snake-canvas-wrap:fullscreen, .trade-panel:fullscreen{
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  background:#0b0d10;width:100%;height:100%;
}
.snake-canvas-wrap:fullscreen #snake-canvas{max-width:none;height:auto;}
.trade-panel:fullscreen{padding:24px;overflow-y:auto;}
.trade-panel:fullscreen .trade-canvas-wrap{width:100%;max-width:1200px;}

/* RESPONSIVE */
@media (max-width:768px){
  .section-heading{font-size:2rem;}
  nav a{font-size:13px; margin:0 8px;}
  .snake-dpad{display:block;}
  .games-row{flex-direction:column;align-items:center;}
}
</style>
</head>
<body>

<nav>
  <a href="/" data-en="Home" data-ro="Acasă">Home</a>
  <a href="/games" data-en="Games" data-ro="Jocuri">Games</a>
  <button id="lang-toggle">RO</button>
</nav>

<section id="games" class="reveal">
  <div class="section-title" data-en="Mini Games" data-ro="Mini Jocuri">Mini Games</div>
  <div class="section-heading" data-en="Take a Break" data-ro="Ia o Pauză">Take a Break</div>
  <div class="games-row">

    <!-- SNAKE -->
    <div class="game-col">
      <div class="game-toolbar">
        <div class="snake-score-bar">
          <div><span data-en="Score" data-ro="Scor">Score</span>: <span id="snake-score">0</span></div>
          <div><span data-en="Best" data-ro="Record">Best</span>: <span id="snake-high">0</span></div>
        </div>
        <div class="game-toolbar-btns">
          <button class="game-toolbar-btn" id="snake-settings-btn" title="Settings">&#9881;</button>
          <button class="game-toolbar-btn" id="snake-fullscreen-btn" title="Fullscreen"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 00-2 2v3"/><path d="M21 8V5a2 2 0 00-2-2h-3"/><path d="M3 16v3a2 2 0 002 2h3"/><path d="M16 21h3a2 2 0 002-2v-3"/></svg></button>
        </div>
      </div>
      <div class="snake-canvas-wrap" id="snake-wrap">
        <div class="game-settings-modal hidden" id="snake-settings-modal">
          <div class="game-settings-inner">
            <h4>Settings</h4>
            <div class="game-settings-row">
              <label>Speed</label>
              <select class="game-settings-select" id="ss-speed">
                <option value="slow">Slow</option>
                <option value="normal" selected>Normal</option>
                <option value="fast">Fast</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>Green Gems</label>
              <select class="game-settings-select" id="ss-gems">
                <option value="rare">Rare</option>
                <option value="normal" selected>Normal</option>
                <option value="frequent">Frequent</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>Purple Gems</label>
              <select class="game-settings-select" id="ss-shrink">
                <option value="rare">Rare</option>
                <option value="normal" selected>Normal</option>
                <option value="frequent">Frequent</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>Bombs</label>
              <select class="game-settings-select" id="ss-bombs">
                <option value="off">Off</option>
                <option value="rare">Rare</option>
                <option value="normal" selected>Normal</option>
                <option value="frequent">Frequent</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>Walls</label>
              <select class="game-settings-select" id="ss-walls">
                <option value="on" selected>Solid</option>
                <option value="off">Wrap Around</option>
              </select>
            </div>
            <button class="game-settings-close" id="ss-close">Close</button>
          </div>
        </div>
        <canvas id="snake-canvas" width="400" height="400"></canvas>
        <div class="snake-overlay" id="snake-overlay-start">
          <h3 data-en="Snake" data-ro="Snake">Snake</h3>
          <p data-en="Use arrow keys or WASD to play" data-ro="Folosește săgețile sau WASD">Use arrow keys or WASD to play</p>
          <button class="snake-btn" id="snake-start-btn" data-en="Start Game" data-ro="Începe Jocul">Start Game</button>
        </div>
        <div class="snake-overlay hidden" id="snake-overlay-pause">
          <h3 data-en="Paused" data-ro="Pauză">Paused</h3>
          <p data-en="Press Space or click to resume" data-ro="Apasă Space sau click pt. reluare">Press Space or click to resume</p>
          <button class="snake-btn" id="snake-resume-btn" data-en="Resume" data-ro="Reia">Resume</button>
        </div>
        <div class="snake-overlay hidden" id="snake-overlay-end">
          <h3 data-en="Game Over" data-ro="Joc Terminat">Game Over</h3>
          <div class="snake-final-score" id="snake-final-score">0</div>
          <button class="snake-btn" id="snake-restart-btn" data-en="Play Again" data-ro="Joacă Din Nou">Play Again</button>
        </div>
      </div>
      <div class="snake-dpad">
        <button class="d-up" data-dir="up">&#9650;</button>
        <button class="d-down" data-dir="down">&#9660;</button>
        <button class="d-left" data-dir="left">&#9664;</button>
        <button class="d-right" data-dir="right">&#9654;</button>
      </div>
      <div class="snake-leaderboard">
        <div class="lb-header">
          <h4 data-en="Best Scores" data-ro="Cele Mai Bune Scoruri">Best Scores</h4>
          <button class="lb-clear-btn" id="snake-clear-lb" title="Clear leaderboard"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/><path d="M19 6l-1 14a2 2 0 01-2 2H8a2 2 0 01-2-2L5 6"/></svg></button>
        </div>
        <table>
          <thead><tr>
            <th data-en="#" data-ro="#">#</th>
            <th data-en="Score" data-ro="Scor">Score</th>
            <th data-en="Date" data-ro="Data">Date</th>
          </tr></thead>
          <tbody id="snake-lb-body"></tbody>
        </table>
      </div>
    </div>

    <!-- TRADING -->
    <div class="game-col">
      <div class="trade-panel" id="trade-wrap">
        <h3 data-en="SPY Day Trader" data-ro="SPY Day Trader">SPY Day Trader</h3>
        <div class="game-toolbar-btns" style="position:absolute;top:12px;right:12px;z-index:3;">
          <button class="game-toolbar-btn" id="game-settings-btn" title="Settings">&#9881;</button>
          <button class="game-toolbar-btn" id="trade-fullscreen-btn" title="Fullscreen"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 00-2 2v3"/><path d="M21 8V5a2 2 0 00-2-2h-3"/><path d="M3 16v3a2 2 0 002 2h3"/><path d="M16 21h3a2 2 0 002-2v-3"/></svg></button>
        </div>
        <div class="game-settings-modal hidden" id="game-settings-modal">
          <div class="game-settings-inner">
            <h4>Settings</h4>
            <div class="game-settings-row">
              <label>Data Source</label>
              <select class="game-settings-select" id="ts-source">
                <option value="real">Real (Yahoo)</option>
                <option value="simulated">Simulated</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>Duration</label>
              <select class="game-settings-select" id="ts-duration">
                <option value="10">10s</option>
                <option value="30" selected>30s</option>
                <option value="60">60s</option>
                <option value="300">300s</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>P&amp;L Display</label>
              <select class="game-settings-select" id="ts-pnlmode">
                <option value="total">Total</option>
                <option value="split" selected>Realized + Unrealized</option>
              </select>
            </div>
            <div class="game-settings-row">
              <label>Position Tint</label>
              <select class="game-settings-select" id="ts-postint">
                <option value="on" selected>On</option>
                <option value="off">Off</option>
              </select>
            </div>
            <button class="game-settings-close" id="ts-close">Close</button>
          </div>
        </div>
        <div class="trade-timer"><div class="trade-timer-fill" id="trade-timer-fill"></div></div>
        <div class="trade-info">
          <div><small data-en="Price" data-ro="Preț">Price</small><span id="trade-price">—</span></div>
          <div><small data-en="Position" data-ro="Poziție">Position</small><span id="trade-pos">0</span></div>
          <div id="trade-pnl-total"><small data-en="P&amp;L" data-ro="Profit">P&amp;L</small><span id="trade-pnl">$0.00</span></div>
          <div id="trade-pnl-realized" style="display:none"><small>Realized</small><span id="trade-rpnl">$0.00</span></div>
          <div id="trade-pnl-unrealized" style="display:none"><small>Unrealized</small><span id="trade-upnl">$0.00</span></div>
        </div>
        <div class="trade-position-bar">
          <small>-1000</small>
          <div class="trade-pos-dots">
            <div class="trade-pos-dot" data-i="-10"></div>
            <div class="trade-pos-dot" data-i="-9"></div>
            <div class="trade-pos-dot" data-i="-8"></div>
            <div class="trade-pos-dot" data-i="-7"></div>
            <div class="trade-pos-dot" data-i="-6"></div>
            <div class="trade-pos-dot" data-i="-5"></div>
            <div class="trade-pos-dot" data-i="-4"></div>
            <div class="trade-pos-dot" data-i="-3"></div>
            <div class="trade-pos-dot" data-i="-2"></div>
            <div class="trade-pos-dot" data-i="-1"></div>
            <div class="trade-pos-dot zero" data-i="0"></div>
            <div class="trade-pos-dot" data-i="1"></div>
            <div class="trade-pos-dot" data-i="2"></div>
            <div class="trade-pos-dot" data-i="3"></div>
            <div class="trade-pos-dot" data-i="4"></div>
            <div class="trade-pos-dot" data-i="5"></div>
            <div class="trade-pos-dot" data-i="6"></div>
            <div class="trade-pos-dot" data-i="7"></div>
            <div class="trade-pos-dot" data-i="8"></div>
            <div class="trade-pos-dot" data-i="9"></div>
            <div class="trade-pos-dot" data-i="10"></div>
          </div>
          <small>+1000</small>
        </div>
        <div class="trade-canvas-wrap">
          <canvas id="trade-canvas" width="400" height="220"></canvas>
          <div class="trade-overlay" id="trade-overlay-start">
            <h3 data-en="SPY Day Trader" data-ro="SPY Day Trader">SPY Day Trader</h3>
            <p data-en="Trade simulated SPY in 30 seconds." data-ro="Tranzacționează SPY simulat în 30 de secunde.">Trade simulated SPY in 30 seconds.</p>
            <p style="font-size:0.8rem;color:var(--muted);margin-bottom:14px" data-en="&#9650;/&#9660; or buttons to trade &bull; Space to pause" data-ro="&#9650;/&#9660; sau butoane pt. tranzacții &bull; Space pt. pauză">&#9650;/&#9660; or buttons to trade &bull; Space to pause</p>
            <button class="trade-btn start" id="trade-start-btn" data-en="Start Trading" data-ro="Începe Tranzacția">Start Trading</button>
          </div>
          <div class="trade-overlay hidden" id="trade-overlay-pause">
            <h3 data-en="Paused" data-ro="Pauză">Paused</h3>
            <p data-en="Press Space or click to resume" data-ro="Apasă Space sau click pt. reluare">Press Space or click to resume</p>
            <div style="display:flex;gap:8px">
              <button class="trade-btn start" id="trade-resume-btn" data-en="Resume" data-ro="Reia">Resume</button>
              <button class="trade-btn end" id="trade-end-btn" data-en="End Session" data-ro="Încheie Sesiunea">End Session</button>
            </div>
          </div>
          <div class="trade-overlay hidden" id="trade-overlay-end">
            <h3 data-en="Market Closed" data-ro="Piața Închisă">Market Closed</h3>
            <div class="trade-result" id="trade-result">$0.00</div>
            <p id="trade-vol-info" style="font-size:0.85rem;color:var(--muted);margin-bottom:4px"></p>
            <p id="trade-date-info" style="font-size:0.85rem;color:var(--muted);margin-bottom:10px"></p>
            <button class="trade-btn start" id="trade-restart-btn" data-en="Trade Again" data-ro="Tranzacționează Din Nou">Trade Again</button>
          </div>
        </div>
        <div class="trade-paused-badge" id="trade-paused-badge" data-en="&#9208; PAUSED" data-ro="&#9208; PAUZĂ">&#9208; PAUSED</div>
        <div class="trade-btns">
          <button class="trade-btn buy" id="trade-buy-btn" disabled data-en="Buy +100 (&#9650;)" data-ro="Cumpără +100 (&#9650;)">Buy +100 (&#9650;)</button>
          <button class="trade-btn sell" id="trade-sell-btn" disabled data-en="Sell -100 (&#9660;)" data-ro="Vinde -100 (&#9660;)">Sell -100 (&#9660;)</button>
        </div>
        <div class="trade-hint" data-en="&#9650;/&#9660; Buy &amp; Sell &bull; <kbd>Space</kbd> Pause" data-ro="&#9650;/&#9660; Cumpără &amp; Vinde &bull; <kbd>Space</kbd> Pauză">&#9650;/&#9660; Buy &amp; Sell &bull; <kbd>Space</kbd> Pause</div>
        <div class="trade-log" id="trade-log" style="display:none">
          <h4>Trade Log</h4>
          <div class="trade-log-scroll">
            <table>
              <thead><tr>
                <th>Time</th>
                <th>Side</th>
                <th>Qty</th>
                <th>Price</th>
                <th>R. P&amp;L</th>
              </tr></thead>
              <tbody id="trade-log-body">
                <tr><td colspan="5" style="color:var(--muted);text-align:center;padding:12px 0">No trades yet</td></tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="trade-lb" id="trade-lb">
          <div class="lb-header">
            <h4 data-en="Best Sessions" data-ro="Cele Mai Bune Sesiuni">Best Sessions</h4>
            <button class="lb-clear-btn" id="trade-clear-lb" title="Clear leaderboard"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/><path d="M19 6l-1 14a2 2 0 01-2 2H8a2 2 0 01-2-2L5 6"/></svg></button>
          </div>
          <table>
            <thead><tr>
              <th data-en="#" data-ro="#">#</th>
              <th data-en="P&amp;L" data-ro="Profit">P&amp;L</th>
              <th data-en="Vol" data-ro="Vol">Vol</th>
              <th data-en="Date" data-ro="Data">Date</th>
            </tr></thead>
            <tbody id="trade-lb-body"></tbody>
          </table>
        </div>
      </div>
    </div>

  </div>

  <!-- WHITEBOARD -->
  <div class="wb-wrap" id="wb-wrap">
    <div class="wb-toolbar" id="wb-toolbar">
      <span style="font-size:13px;font-weight:600;color:var(--ink);margin-right:6px" data-en="Whiteboard" data-ro="Tablă">Whiteboard</span>
      <div class="wb-sep"></div>
      <div class="wb-toolbar-group" id="wb-tools">
        <button class="wb-btn active" data-tool="pen" title="Pen (P)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg></button>
        <button class="wb-btn" data-tool="line" title="Line (L)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="5" y1="19" x2="19" y2="5"/></svg></button>
        <button class="wb-btn" data-tool="rect" title="Rectangle (R)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/></svg></button>
        <button class="wb-btn" data-tool="ellipse" title="Ellipse (E)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><ellipse cx="12" cy="12" rx="10" ry="7"/></svg></button>
        <button class="wb-btn" data-tool="arrow" title="Arrow (A)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="19" x2="19" y2="5"/><polyline points="10 5 19 5 19 14"/></svg></button>
        <button class="wb-btn" data-tool="highlighter" title="Highlighter (H)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.5 4.5l4 4L8 20H4v-4z"/><path d="M12.5 7.5l4 4"/></svg></button>
        <button class="wb-btn" data-tool="text" title="Text (T)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9.5" y1="20" x2="14.5" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg></button>
        <button class="wb-btn" data-tool="eraser" title="Eraser (X)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 20H7L3 16l9-9 8 8-4 4z"/><path d="M6.5 13.5l5 5"/></svg></button>
        <button class="wb-btn" data-tool="hand" title="Hand / Pan (G or Space+drag)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 11V6a2 2 0 00-4 0v1"/><path d="M14 10V4a2 2 0 00-4 0v6"/><path d="M10 10.5V5a2 2 0 00-4 0v9"/><path d="M18 11a2 2 0 014 0v3a8 8 0 01-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.66-3.66a2 2 0 012.83-2.83L7 15"/></svg></button>
      </div>
      <div class="wb-sep"></div>
      <div class="wb-toolbar-group" id="wb-colors">
        <button class="wb-color-btn active" data-color="#f5f7fa" style="background:#f5f7fa" title="White"></button>
        <button class="wb-color-btn" data-color="#ef4444" style="background:#ef4444" title="Red"></button>
        <button class="wb-color-btn" data-color="#fbbf24" style="background:#fbbf24" title="Yellow"></button>
        <button class="wb-color-btn" data-color="#34d399" style="background:#34d399" title="Green"></button>
        <button class="wb-color-btn" data-color="#4f8cff" style="background:#4f8cff" title="Blue"></button>
        <button class="wb-color-btn" data-color="#a855f7" style="background:#a855f7" title="Purple"></button>
        <input type="color" class="wb-color-picker" id="wb-custom-color" value="#ff6b6b" title="Custom color">
      </div>
      <div class="wb-sep"></div>
      <div class="wb-toolbar-group">
        <input type="range" class="wb-size-slider" id="wb-size" min="1" max="32" value="3">
        <span class="wb-size-label" id="wb-size-label">3</span>
      </div>
      <div class="wb-sep"></div>
      <div class="wb-toolbar-group">
        <span style="font-size:10px;color:var(--muted)">&#9681;</span>
        <input type="range" class="wb-opacity-slider" id="wb-opacity" min="10" max="100" value="100">
        <span class="wb-size-label" id="wb-opacity-label">100%</span>
      </div>
      <div class="wb-sep"></div>
      <label class="wb-fill-toggle" title="Fill shapes"><input type="checkbox" id="wb-fill-check"> Fill</label>
      <label class="wb-fill-toggle" title="Show grid"><input type="checkbox" id="wb-grid-check"> Grid</label>
      <div class="wb-toolbar-right">
        <button class="wb-btn" id="wb-undo-btn" title="Undo (Ctrl+Z)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 105.64-11.36L1 10"/></svg></button>
        <button class="wb-btn" id="wb-redo-btn" title="Redo (Ctrl+Y)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 11-5.64-11.36L23 10"/></svg></button>
        <button class="wb-btn" id="wb-clear-btn" title="Clear All"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/><path d="M19 6l-1 14a2 2 0 01-2 2H8a2 2 0 01-2-2L5 6"/></svg></button>
        <div class="wb-sep"></div>
        <button class="wb-btn" id="wb-download-btn" title="Save as PNG"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></button>
        <div class="wb-sep"></div>
        <button class="wb-btn wb-zoom-btn" id="wb-zoom-out" title="Zoom Out (Ctrl+-)"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
        <span class="wb-zoom-label" id="wb-zoom-label" title="Double-click to reset zoom">100%</span>
        <button class="wb-btn wb-zoom-btn" id="wb-zoom-in" title="Zoom In (Ctrl++)"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
        <div class="wb-sep"></div>
        <button class="wb-btn" id="wb-fullscreen-btn" title="Fullscreen"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 00-2 2v3"/><path d="M21 8V5a2 2 0 00-2-2h-3"/><path d="M3 16v3a2 2 0 002 2h3"/><path d="M16 21h3a2 2 0 002-2v-3"/></svg></button>
        <div class="wb-sep"></div>
        <div style="position:relative;display:flex;align-items:center;gap:3px">
          <button class="wb-btn wb-ai-btn" id="wb-ai-btn" title="AI Guess (right-click to change key)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l2.4 7.4H22l-6.2 4.5 2.4 7.4L12 16.8l-6.2 4.5 2.4-7.4L2 9.4h7.6z"/></svg></button>
          <button class="wb-btn wb-ai-btn" id="wb-ai-draw-btn" title="AI Draw (right-click to change key)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg></button>
          <div class="wb-ai-popover" id="wb-ai-popover">
            <label>OpenAI API Key</label>
            <input type="password" id="wb-ai-key" placeholder="sk-..." spellcheck="false" autocomplete="off">
            <div class="wb-ai-row">
              <button class="wb-ai-save" id="wb-ai-save">Save</button>
              <span class="wb-ai-status" id="wb-ai-status">Stored locally only</span>
            </div>
          </div>
          <div class="wb-ai-draw-popover" id="wb-ai-draw-popover">
            <label>Describe what to draw</label>
            <input type="text" id="wb-ai-draw-prompt" placeholder="e.g. a cat sitting on a fence" spellcheck="false" autocomplete="off">
            <div class="wb-ai-draw-row">
              <button class="wb-ai-draw-go" id="wb-ai-draw-go">Draw</button>
              <span class="wb-ai-draw-status" id="wb-ai-draw-status"></span>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="wb-canvas-area" id="wb-canvas-area">
      <canvas id="wb-canvas" width="1200" height="600"></canvas>
      <canvas id="wb-grid" class="wb-grid-canvas" width="1200" height="600"></canvas>
      <div class="wb-ai-guess" id="wb-ai-guess"><span class="wb-ai-icon">&#9733;</span><span id="wb-ai-guess-text"></span></div>
    </div>
  </div>

</section>

<footer class="reveal">
  © 2025 TATOMIR N. ALEX PFA. All rights reserved.
</footer>

<script src="data/spy_data.js"></script>
<script>
// Reveal animations
const observer = new IntersectionObserver(entries=>{
  entries.forEach(e=>{
    if(e.isIntersecting) e.target.classList.add("visible");
  });
},{threshold:0.15});
document.querySelectorAll('.reveal').forEach(el=>observer.observe(el));

// Language toggle
const toggle = document.getElementById('lang-toggle');
let lang = 'en';
toggle.addEventListener('click', ()=>{
  lang = lang === 'en' ? 'ro' : 'en';
  toggle.textContent = lang === 'en' ? 'RO' : 'EN';
  document.querySelectorAll('[data-en]').forEach(el=>{
    el.textContent = el.getAttribute(`data-${lang}`);
  });
});

// Snake Game
(function(){
  const canvas = document.getElementById('snake-canvas');
  const ctx = canvas.getContext('2d');
  let SIZE = 20;
  const COLS = canvas.width / SIZE;
  const ROWS = canvas.height / SIZE;
  const BOMB_LIFETIME = 8000;

  // Settings
  const SNAKE_DEFAULTS = { speed:'normal', gems:'normal', shrink:'normal', bombs:'normal', walls:'on' };
  function loadSnakeSettings(){ try { return Object.assign({}, SNAKE_DEFAULTS, JSON.parse(localStorage.getItem('snakeSettings'))); } catch(e){ return Object.assign({}, SNAKE_DEFAULTS); } }
  function saveSnakeSettings(s){ localStorage.setItem('snakeSettings', JSON.stringify(s)); }
  let snakeSettings = loadSnakeSettings();

  function getSpeedParams(){
    const map = { slow:[180,0.5,80], normal:[140,1,60], fast:[100,2,40] };
    const [base, step, min] = map[snakeSettings.speed] || map.normal;
    return { BASE_SPEED:base, SPEED_STEP:step, MIN_SPEED:min };
  }
  function getSpawnDelay(setting){
    const map = { rare:[8000,12000], normal:[4000,6000], frequent:[1500,3000] };
    return map[setting] || map.normal;
  }

  function applySnakeSettingsUI(){
    document.getElementById('ss-speed').value = snakeSettings.speed;
    document.getElementById('ss-gems').value = snakeSettings.gems;
    document.getElementById('ss-shrink').value = snakeSettings.shrink;
    document.getElementById('ss-bombs').value = snakeSettings.bombs;
    document.getElementById('ss-walls').value = snakeSettings.walls;
  }
  applySnakeSettingsUI();

  let snake, dir, dirQueue, food, score, highScore, speed, loop, running, paused;
  let gem, gemTimer, bombs, bombTimer, bombTimers;
  let shrinkGem, shrinkGemTimer;

  highScore = parseInt(localStorage.getItem('snakeHigh') || '0');
  document.getElementById('snake-high').textContent = highScore;

  function loadLB(){
    let lb = JSON.parse(localStorage.getItem('snakeLB') || '[]');
    // Migrate old formats to {score, date}
    if(lb.length && typeof lb[0] === 'object' && lb[0].name) lb = lb.map(e=>({score:e.score, date:null}));
    else if(lb.length && typeof lb[0] === 'number') lb = lb.map(e=>({score:e, date:null}));
    return lb;
  }
  function saveLB(lb){ localStorage.setItem('snakeLB', JSON.stringify(lb)); }
  function fmtDate(d){ if(!d) return '—'; const dt=new Date(d); return dt.toLocaleDateString('en-US',{month:'short',day:'numeric'})+' '+dt.toLocaleTimeString('en-US',{hour:'numeric',minute:'2-digit'}); }
  function renderLB(){
    const lb = loadLB();
    const tbody = document.getElementById('snake-lb-body');
    tbody.innerHTML = lb.length === 0
      ? '<tr><td colspan="3" style="color:var(--muted);text-align:center;padding:12px 0">—</td></tr>'
      : lb.map((e,i)=>`<tr><td>${i+1}</td><td>${e.score}</td><td style="color:var(--muted);font-size:11px">${fmtDate(e.date)}</td></tr>`).join('');
  }
  renderLB();

  function isFree(pos){
    if(snake.some(s=>s.x===pos.x&&s.y===pos.y)) return false;
    if(food&&food.x===pos.x&&food.y===pos.y) return false;
    if(gem&&gem.x===pos.x&&gem.y===pos.y) return false;
    if(shrinkGem&&shrinkGem.x===pos.x&&shrinkGem.y===pos.y) return false;
    if(bombs.some(b=>b.x===pos.x&&b.y===pos.y)) return false;
    return true;
  }
  function randFreePos(){
    let pos;
    do { pos={x:Math.floor(Math.random()*COLS),y:Math.floor(Math.random()*ROWS)}; } while(!isFree(pos));
    return pos;
  }
  function placeFood(){ food = randFreePos(); }

  function spawnGem(){
    gem = randFreePos();
    if(gemTimer) clearTimeout(gemTimer);
    gemTimer = setTimeout(()=>{ gem=null; scheduleGem(); }, 4000+Math.random()*2000);
  }
  function scheduleGem(){
    if(!running||paused) return;
    const [base,range] = getSpawnDelay(snakeSettings.gems);
    gemTimer = setTimeout(()=>{ if(running&&!paused) spawnGem(); }, base+Math.random()*range);
  }
  function isInFrontOfSnake(pos){
    if(!snake||!snake.length||!dir) return false;
    const head = snake[0];
    for(let i=1;i<=4;i++){
      let fx = head.x + dir.x * i;
      let fy = head.y + dir.y * i;
      if(snakeSettings.walls === 'off'){
        fx = ((fx % COLS) + COLS) % COLS;
        fy = ((fy % ROWS) + ROWS) % ROWS;
      }
      if(pos.x === fx && pos.y === fy) return true;
    }
    return false;
  }
  function randFreePosForBomb(){
    let pos, attempts = 0;
    do {
      pos = {x:Math.floor(Math.random()*COLS),y:Math.floor(Math.random()*ROWS)};
      attempts++;
    } while((!isFree(pos) || isInFrontOfSnake(pos)) && attempts < 200);
    return isFree(pos) ? pos : null;
  }
  function spawnBomb(){
    if(!running||paused) return;
    if(snakeSettings.bombs === 'off') return;
    if(bombs.length<3){
      const b = randFreePosForBomb();
      if(!b){ scheduleBomb(); return; }
      bombs.push(b);
      const timer = setTimeout(()=>{
        const idx = bombs.indexOf(b);
        if(idx !== -1) bombs.splice(idx, 1);
        const ti = bombTimers.indexOf(timer);
        if(ti !== -1) bombTimers.splice(ti, 1);
        if(running&&!paused) draw();
      }, BOMB_LIFETIME);
      bombTimers.push(timer);
    }
    scheduleBomb();
  }
  function scheduleBomb(){
    if(!running||paused||snakeSettings.bombs==='off') return;
    const [base,range] = getSpawnDelay(snakeSettings.bombs);
    bombTimer = setTimeout(()=>{ if(running&&!paused) spawnBomb(); }, base+Math.random()*range);
  }

  function spawnShrinkGem(){
    shrinkGem = randFreePos();
    if(shrinkGemTimer) clearTimeout(shrinkGemTimer);
    shrinkGemTimer = setTimeout(()=>{ shrinkGem=null; scheduleShrinkGem(); }, 3000+Math.random()*2000);
  }
  function scheduleShrinkGem(){
    if(!running||paused) return;
    const [base,range] = getSpawnDelay(snakeSettings.shrink);
    shrinkGemTimer = setTimeout(()=>{ if(running&&!paused) spawnShrinkGem(); }, base+Math.random()*range);
  }

  function clearAllTimers(){
    if(gemTimer) clearTimeout(gemTimer);
    if(bombTimer) clearTimeout(bombTimer);
    if(bombTimers) bombTimers.forEach(t=>clearTimeout(t));
    if(shrinkGemTimer) clearTimeout(shrinkGemTimer);
  }

  function togglePause(){
    if(!running) return;
    if(paused){
      paused = false;
      loop = setInterval(tick, speed);
      document.getElementById('snake-overlay-pause').classList.add('hidden');
      scheduleGem(); scheduleBomb(); scheduleShrinkGem();
    } else {
      paused = true;
      clearInterval(loop);
      if(gemTimer) clearTimeout(gemTimer);
      if(bombTimer) clearTimeout(bombTimer);
      document.getElementById('snake-overlay-pause').classList.remove('hidden');
    }
  }

  function startGame(){
    snakeSettings = loadSnakeSettings();
    const sp = getSpeedParams();
    snake = [{x:Math.floor(COLS/2), y:Math.floor(ROWS/2)}];
    dir = {x:1,y:0}; dirQueue = [];
    score = 0; speed = sp.BASE_SPEED; running = true; paused = false;
    gem = null; shrinkGem = null; bombs = []; bombTimers = [];
    clearAllTimers();
    document.getElementById('snake-score').textContent = 0;
    placeFood(); scheduleGem(); scheduleBomb(); scheduleShrinkGem();
    document.getElementById('snake-overlay-start').classList.add('hidden');
    document.getElementById('snake-overlay-end').classList.add('hidden');
    document.getElementById('snake-overlay-pause').classList.add('hidden');
    document.getElementById('snake-settings-modal').classList.add('hidden');
    if(loop) clearInterval(loop);
    loop = setInterval(tick, speed);
  }

  function tick(){
    if(dirQueue.length) dir = dirQueue.shift();
    const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};
    if(snakeSettings.walls === 'off'){
      if(head.x < 0) head.x = COLS - 1;
      else if(head.x >= COLS) head.x = 0;
      if(head.y < 0) head.y = ROWS - 1;
      else if(head.y >= ROWS) head.y = 0;
    } else {
      if(head.x<0||head.x>=COLS||head.y<0||head.y>=ROWS){ gameOver(); return; }
    }
    if(snake.some(s=>s.x===head.x&&s.y===head.y)){ gameOver(); return; }
    if(bombs.some(b=>b.x===head.x&&b.y===head.y)){ gameOver(); return; }
    snake.unshift(head);
    let ate = false;
    let ateGem = false;
    if(head.x===food.x&&head.y===food.y){ score++; ate = true; placeFood(); }
    if(gem&&head.x===gem.x&&head.y===gem.y){
      score += 3; ateGem = true; gem = null;
      if(gemTimer) clearTimeout(gemTimer);
      scheduleGem();
    }
    let ateShrink = false;
    if(shrinkGem&&head.x===shrinkGem.x&&head.y===shrinkGem.y){
      score += 2; ateShrink = true; shrinkGem = null;
      if(shrinkGemTimer) clearTimeout(shrinkGemTimer);
      scheduleShrinkGem();
      // Shrink: remove tail segments but keep at least 1
      const removeCount = Math.min(3, snake.length - 1);
      for(let r=0;r<removeCount;r++) snake.pop();
    }
    if(ate || ateGem || ateShrink){
      document.getElementById('snake-score').textContent = score;
      if(score>highScore){
        highScore = score;
        localStorage.setItem('snakeHigh', highScore);
        document.getElementById('snake-high').textContent = highScore;
      }
    }
    if(ate || ateGem){
      const sp = getSpeedParams();
      const newSpeed = Math.max(sp.MIN_SPEED, sp.BASE_SPEED - score * sp.SPEED_STEP);
      if(newSpeed !== speed){ speed = newSpeed; clearInterval(loop); loop = setInterval(tick, speed); }
    } else if(!ateShrink) { snake.pop(); }
    draw();
  }

  function draw(){
    ctx.fillStyle = '#0b0d10';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    for(let x=0;x<=COLS;x++){ctx.beginPath();ctx.moveTo(x*SIZE,0);ctx.lineTo(x*SIZE,canvas.height);ctx.stroke();}
    for(let y=0;y<=ROWS;y++){ctx.beginPath();ctx.moveTo(0,y*SIZE);ctx.lineTo(canvas.width,y*SIZE);ctx.stroke();}
    ctx.fillStyle = '#fbbf24';
    ctx.beginPath(); ctx.arc(food.x*SIZE+SIZE/2, food.y*SIZE+SIZE/2, SIZE/2-2, 0, Math.PI*2); ctx.fill();
    if(gem){
      const gx=gem.x*SIZE+SIZE/2, gy=gem.y*SIZE+SIZE/2, gr=SIZE/2-2;
      ctx.fillStyle='#34d399';
      ctx.beginPath(); ctx.moveTo(gx,gy-gr); ctx.lineTo(gx+gr,gy); ctx.lineTo(gx,gy+gr); ctx.lineTo(gx-gr,gy);
      ctx.closePath(); ctx.fill();
      ctx.shadowColor='#34d399'; ctx.shadowBlur=8; ctx.fill(); ctx.shadowBlur=0;
    }
    if(shrinkGem){
      const sx=shrinkGem.x*SIZE+SIZE/2, sy=shrinkGem.y*SIZE+SIZE/2, sr=SIZE/2-1;
      ctx.fillStyle='#a855f7';
      ctx.beginPath();
      for(let i=0;i<6;i++){const a=Math.PI/6+i*Math.PI/3;ctx.lineTo(sx+sr*Math.cos(a),sy+sr*Math.sin(a));}
      ctx.closePath(); ctx.fill();
      ctx.shadowColor='#a855f7'; ctx.shadowBlur=8; ctx.fill(); ctx.shadowBlur=0;
    }
    bombs.forEach(b=>{
      ctx.fillStyle='#ef4444';
      ctx.fillRect(b.x*SIZE+2, b.y*SIZE+2, SIZE-4, SIZE-4);
      ctx.strokeStyle='#0b0d10'; ctx.lineWidth=2;
      const bx=b.x*SIZE+SIZE/2, by=b.y*SIZE+SIZE/2;
      ctx.beginPath(); ctx.moveTo(bx-3,by-3); ctx.lineTo(bx+3,by+3); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(bx+3,by-3); ctx.lineTo(bx-3,by+3); ctx.stroke();
      ctx.lineWidth=1;
    });
    snake.forEach((s,i)=>{
      ctx.fillStyle = i===0 ? '#4f8cff' : 'rgba(79,140,255,0.65)';
      ctx.beginPath(); ctx.roundRect(s.x*SIZE+1, s.y*SIZE+1, SIZE-2, SIZE-2, 4); ctx.fill();
    });
  }
  ctx.fillStyle='#0b0d10';ctx.fillRect(0,0,canvas.width,canvas.height);

  function gameOver(){
    running = false; clearInterval(loop);
    clearAllTimers();
    document.getElementById('snake-final-score').textContent = score;
    document.getElementById('snake-overlay-end').classList.remove('hidden');
    // Save score to leaderboard
    const lb = loadLB(); lb.push({score, date: new Date().toISOString()});
    lb.sort((a,b)=>b.score-a.score); if(lb.length>5) lb.length=5;
    saveLB(lb); renderLB();
  }

  const DIR_MAP = {
    ArrowUp:{x:0,y:-1},ArrowDown:{x:0,y:1},ArrowLeft:{x:-1,y:0},ArrowRight:{x:1,y:0},
    w:{x:0,y:-1},s:{x:0,y:1},a:{x:-1,y:0},d:{x:1,y:0},
    W:{x:0,y:-1},S:{x:0,y:1},A:{x:-1,y:0},D:{x:1,y:0}
  };
  document.addEventListener('keydown', e=>{
    if((e.key===' '||e.key==='Escape') && running){ togglePause(); e.preventDefault(); return; }
    if(!running||paused) return;
    const d = DIR_MAP[e.key];
    if(d){
      const last = dirQueue.length ? dirQueue[dirQueue.length-1] : dir;
      if(d.x !== -last.x || d.y !== -last.y){ dirQueue.push(d); if(dirQueue.length>4) dirQueue.shift(); }
      e.preventDefault();
    }
  });

  document.querySelectorAll('.snake-dpad button').forEach(btn=>{
    const dirName = btn.dataset.dir;
    const map = {up:{x:0,y:-1},down:{x:0,y:1},left:{x:-1,y:0},right:{x:1,y:0}};
    btn.addEventListener('touchstart', e=>{ e.preventDefault(); if(!running||paused) return; const d=map[dirName]; const last=dirQueue.length?dirQueue[dirQueue.length-1]:dir; if(d.x!==-last.x||d.y!==-last.y){dirQueue.push(d);if(dirQueue.length>4)dirQueue.shift();} });
    btn.addEventListener('mousedown', ()=>{ if(!running||paused) return; const d=map[dirName]; const last=dirQueue.length?dirQueue[dirQueue.length-1]:dir; if(d.x!==-last.x||d.y!==-last.y){dirQueue.push(d);if(dirQueue.length>4)dirQueue.shift();} });
  });

  document.getElementById('snake-start-btn').addEventListener('click', startGame);
  document.getElementById('snake-restart-btn').addEventListener('click', startGame);
  document.getElementById('snake-resume-btn').addEventListener('click', togglePause);
  document.getElementById('snake-clear-lb').addEventListener('click', ()=>{
    if(confirm('Clear the snake leaderboard?')){
      localStorage.removeItem('snakeLB');
      renderLB();
    }
  });

  // Snake settings modal
  document.getElementById('snake-settings-btn').addEventListener('click', ()=>{
    if(running && !paused) togglePause();
    document.getElementById('snake-settings-modal').classList.remove('hidden');
  });
  document.getElementById('ss-close').addEventListener('click', ()=>{
    snakeSettings.speed = document.getElementById('ss-speed').value;
    snakeSettings.gems = document.getElementById('ss-gems').value;
    snakeSettings.shrink = document.getElementById('ss-shrink').value;
    snakeSettings.bombs = document.getElementById('ss-bombs').value;
    snakeSettings.walls = document.getElementById('ss-walls').value;
    saveSnakeSettings(snakeSettings);
    document.getElementById('snake-settings-modal').classList.add('hidden');
  });

  // Fullscreen
  document.getElementById('snake-fullscreen-btn').addEventListener('click', ()=>{
    const el = document.getElementById('snake-wrap');
    if(!document.fullscreenElement) el.requestFullscreen().catch(()=>{});
    else document.exitFullscreen();
  });
  document.addEventListener('fullscreenchange', ()=>{
    const wrap = document.getElementById('snake-wrap');
    if(document.fullscreenElement === wrap){
      const maxW = window.innerWidth;
      const maxH = window.innerHeight;
      SIZE = Math.floor(Math.min(maxW / COLS, maxH / ROWS));
      canvas.width = COLS * SIZE;
      canvas.height = ROWS * SIZE;
    } else {
      SIZE = 20;
      canvas.width = COLS * SIZE;
      canvas.height = ROWS * SIZE;
    }
    draw();
  });
})();

// Trading Game
(function(){
  const canvas = document.getElementById('trade-canvas');
  const ctx = canvas.getContext('2d');
  let W = canvas.width, H = canvas.height;
  const TICK = 100;
  const MULTIPLIER = 100;
  const MAX_POS = 10;

  // Settings
  const DEFAULT_SETTINGS = { dataSource: 'real', duration: 30, pnlMode: 'split', posTint: true };
  function loadSettings(){ try { return Object.assign({}, DEFAULT_SETTINGS, JSON.parse(localStorage.getItem('tradeSettings'))); } catch(e){ return Object.assign({}, DEFAULT_SETTINGS); } }
  function saveSettings(s){ localStorage.setItem('tradeSettings', JSON.stringify(s)); }
  let settings = loadSettings();
  let DURATION = settings.duration * 1000;
  let TOTAL_TICKS = DURATION / TICK;

  // Apply settings to UI
  function applySettingsUI(){
    document.getElementById('ts-source').value = settings.dataSource;
    document.getElementById('ts-duration').value = settings.duration;
    document.getElementById('ts-pnlmode').value = settings.pnlMode;
    document.getElementById('ts-postint').value = settings.posTint ? 'on' : 'off';
  }
  applySettingsUI();

  let prices, currentTick, position, pnl, running, paused, loop, tradingDate;
  let totalCost, avgPrice; // cost basis tracking
  let realizedPnl; // for split PnL mode
  let posHistory; // position at each tick for tinting
  let tradedVolume; // total $ volume traded

  function generateSimulatedPrices(){
    tradingDate = 'Simulated';
    const base = 450 + Math.random() * 150; // ~$450-$600
    const dailyVol = 0.01;
    const tickVol = dailyVol / Math.sqrt(TOTAL_TICKS);
    const pts = [base];
    for(let i = 1; i <= TOTAL_TICKS; i++){
      const ret = (Math.random() + Math.random() + Math.random() - 1.5) * tickVol;
      pts.push(pts[i-1] * (1 + ret));
    }
    return pts;
  }

  function fetchRealPrices(){
    if(settings.dataSource === 'simulated') return generateSimulatedPrices();
    // Pick a random trading day from the bundled data
    const idx = Math.floor(Math.random() * window.SPY_DATA.length);
    const [date, dayPrices] = window.SPY_DATA[idx];
    tradingDate = date;

    // Resample to TOTAL_TICKS+1 points via linear interpolation
    const resampled = [];
    for(let i = 0; i <= TOTAL_TICKS; i++){
      const t = i * (dayPrices.length - 1) / TOTAL_TICKS;
      const lo = Math.floor(t);
      const hi = Math.min(lo + 1, dayPrices.length - 1);
      const frac = t - lo;
      resampled.push(dayPrices[lo] * (1 - frac) + dayPrices[hi] * frac);
    }
    return resampled;
  }

  function loadTradeLB(){
    let lb = JSON.parse(localStorage.getItem('tradeLB')||'[]');
    // Migrate old formats
    if(lb.length && typeof lb[0] === 'number') lb = lb.map(e=>({pnl:e, date:null, vol:0}));
    else if(lb.length && typeof lb[0] === 'object' && lb[0].vol === undefined) lb = lb.map(e=>({...e, vol:0}));
    return lb;
  }
  function saveTradeLB(lb){ localStorage.setItem('tradeLB',JSON.stringify(lb)); }
  function fmtTradeDate(d){ if(!d) return '—'; const dt=new Date(d); return dt.toLocaleDateString('en-US',{month:'short',day:'numeric'})+' '+dt.toLocaleTimeString('en-US',{hour:'numeric',minute:'2-digit'}); }
  function fmtVol(v){
    if(!v) return '—';
    if(v>=1e6) return '$'+(v/1e6).toFixed(1)+'M';
    if(v>=1e3) return '$'+(v/1e3).toFixed(0)+'K';
    return '$'+v.toFixed(0);
  }
  function renderTradeLB(){
    const lb = loadTradeLB();
    const tbody = document.getElementById('trade-lb-body');
    tbody.innerHTML = lb.length===0
      ? '<tr><td colspan="4" style="color:var(--muted);text-align:center;padding:12px 0">—</td></tr>'
      : lb.map((e,i)=>{
        const cls = e.pnl>=0?'pnl-pos':'pnl-neg';
        const sign = e.pnl>=0?'+':'-';
        return `<tr><td>${i+1}</td><td class="${cls}">${sign}$${Math.abs(e.pnl).toFixed(2)}</td><td style="color:var(--muted);font-size:11px">${fmtVol(e.vol)}</td><td style="color:var(--muted);font-size:11px">${fmtTradeDate(e.date)}</td></tr>`;
      }).join('');
  }
  renderTradeLB();

  let tradeLog = [];
  function formatTradeTime(tick){
    if(settings.dataSource === 'simulated'){
      return (tick * TICK / 1000).toFixed(1) + 's';
    }
    // Map tick to market hours 9:30–16:00
    const frac = tick / TOTAL_TICKS;
    const hours = 9.5 + frac * 6.5;
    const h = Math.floor(hours);
    const m = Math.floor((hours - h) * 60);
    const h12 = h > 12 ? h - 12 : h;
    const ampm = h >= 12 ? 'pm' : 'am';
    return h12 + ':' + String(m).padStart(2, '0') + ampm;
  }
  function logTrade(side, qty, price, rpnl){
    const time = formatTradeTime(currentTick);
    tradedVolume += qty * price;
    tradeLog.push({ time, side, qty, price, rpnl });
    renderTradeLog();
  }
  function renderTradeLog(){
    const tbody = document.getElementById('trade-log-body');
    if(!tbody) return;
    if(tradeLog.length === 0){
      tbody.innerHTML = '<tr><td colspan="5" style="color:var(--muted);text-align:center;padding:12px 0">No trades yet</td></tr>';
      return;
    }
    tbody.innerHTML = tradeLog.slice().reverse().map(t=>{
      const sideColor = t.side==='BUY'?'#34d399':'#ef4444';
      const rpnlStr = t.rpnl !== 0
        ? `<span class="${t.rpnl>=0?'pnl-pos':'pnl-neg'}">${t.rpnl>=0?'+':'-'}$${Math.abs(t.rpnl).toFixed(2)}</span>`
        : '<span style="color:var(--muted)">—</span>';
      return `<tr><td>${t.time}</td><td style="color:${sideColor};font-weight:600">${t.side}</td><td>${t.qty}</td><td>$${t.price.toFixed(2)}</td><td>${rpnlStr}</td></tr>`;
    }).join('');
  }

  function updateAvgPrice(newPos, price){
    const oldPos = position;
    let tradeRpnl = 0;
    // Track realized P&L when reducing position
    if(oldPos !== 0){
      if(newPos === 0){
        tradeRpnl = oldPos * MULTIPLIER * (price - avgPrice);
      } else if(Math.sign(newPos) !== Math.sign(oldPos)){
        tradeRpnl = oldPos * MULTIPLIER * (price - avgPrice);
      } else if(Math.abs(newPos) < Math.abs(oldPos)){
        const closed = oldPos - newPos;
        tradeRpnl = closed * MULTIPLIER * (price - avgPrice);
      }
      realizedPnl += tradeRpnl;
    }

    if(newPos === 0){ totalCost = 0; avgPrice = 0; }
    else if(Math.sign(newPos) !== Math.sign(oldPos) && oldPos !== 0){
      totalCost = newPos * price; avgPrice = price;
    } else if(Math.abs(newPos) > Math.abs(oldPos)){
      totalCost += (newPos - oldPos) * price;
      avgPrice = totalCost / newPos;
    } else if(Math.abs(newPos) < Math.abs(oldPos)){
      // Reducing position: keep avgPrice, shrink totalCost
      totalCost = newPos * avgPrice;
    }
    return tradeRpnl;
  }

  function doBuy(){
    if(!running||paused||position>=MAX_POS) return;
    const price = prices[currentTick];
    const rpnl = updateAvgPrice(position+1, price);
    position++;
    posHistory[currentTick] = position;
    logTrade('BUY', MULTIPLIER, price, rpnl);
    updatePosDisplay();
    drawChart();
  }
  function doSell(){
    if(!running||paused||position<=-MAX_POS) return;
    const price = prices[currentTick];
    const rpnl = updateAvgPrice(position-1, price);
    position--;
    posHistory[currentTick] = position;
    logTrade('SELL', MULTIPLIER, price, rpnl);
    updatePosDisplay();
    drawChart();
  }

  function togglePause(){
    if(!running) return;
    if(paused){
      paused = false;
      loop = setInterval(tick, TICK);
      document.getElementById('trade-overlay-pause').classList.add('hidden');
      document.getElementById('trade-paused-badge').classList.remove('visible');
      document.getElementById('trade-buy-btn').disabled = false;
      document.getElementById('trade-sell-btn').disabled = false;
    } else {
      paused = true;
      clearInterval(loop);
      document.getElementById('trade-overlay-pause').classList.remove('hidden');
      document.getElementById('trade-paused-badge').classList.add('visible');
      document.getElementById('trade-buy-btn').disabled = true;
      document.getElementById('trade-sell-btn').disabled = true;
    }
  }

  function updatePosDisplay(){
    const display = position * MULTIPLIER;
    document.getElementById('trade-pos').textContent = (display>0?'+':'') + display;
    document.querySelectorAll('.trade-pos-dot').forEach(dot=>{
      const i = parseInt(dot.dataset.i);
      dot.classList.remove('long','short');
      if(position>0 && i>0 && i<=position) dot.classList.add('long');
      if(position<0 && i<0 && i>=position) dot.classList.add('short');
    });
  }

  function updatePnlDisplay(){
    const isSplit = settings.pnlMode === 'split';
    document.getElementById('trade-pnl-total').style.display = isSplit ? 'none' : '';
    document.getElementById('trade-pnl-realized').style.display = isSplit ? '' : 'none';
    document.getElementById('trade-pnl-unrealized').style.display = isSplit ? '' : 'none';

    if(isSplit){
      const unrealized = (running && position !== 0) ? position * MULTIPLIER * (prices[currentTick] - avgPrice) : 0;
      const rEl = document.getElementById('trade-rpnl');
      const uEl = document.getElementById('trade-upnl');
      rEl.textContent = `${realizedPnl>=0?'+':''}$${Math.abs(realizedPnl).toFixed(2)}`;
      rEl.className = realizedPnl>=0?'pnl-pos':'pnl-neg';
      uEl.textContent = `${unrealized>=0?'+':''}$${Math.abs(unrealized).toFixed(2)}`;
      uEl.className = unrealized>=0?'pnl-pos':'pnl-neg';
    } else {
      const el = document.getElementById('trade-pnl');
      const sign = pnl>=0?'+':'';
      el.textContent = `${sign}$${Math.abs(pnl).toFixed(2)}`;
      el.className = pnl>=0?'pnl-pos':'pnl-neg';
    }
  }

  function drawChart(){
    ctx.fillStyle='#0b0d10';
    ctx.fillRect(0,0,W,H);
    if(currentTick<1) return;
    const slice = prices.slice(0, currentTick+1);
    const minP = Math.min(...slice)-0.5;
    const maxP = Math.max(...slice)+0.5;
    const range = maxP-minP||1;
    const padT=18, padB=32, padL=6, padR=6;
    const cW=W-padL-padR, cH=H-padT-padB;

    // Position tint bands
    if(settings.posTint && posHistory){
      for(let i=0;i<=currentTick;i++){
        const p = posHistory[i] || 0;
        if(p === 0) continue;
        const alpha = Math.min(Math.abs(p) / MAX_POS, 1) * 0.12;
        ctx.fillStyle = p > 0 ? `rgba(52,211,153,${alpha})` : `rgba(239,68,68,${alpha})`;
        const x0 = padL + (i / TOTAL_TICKS) * cW;
        const x1 = padL + ((i + 1) / TOTAL_TICKS) * cW;
        ctx.fillRect(x0, padT, x1 - x0, cH);
      }
    }

    ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.lineWidth=1;
    for(let i=0;i<5;i++){const y=padT+cH*i/4;ctx.beginPath();ctx.moveTo(padL,y);ctx.lineTo(W-padR,y);ctx.stroke();}

    // Time labels on x-axis
    if(settings.dataSource === 'simulated'){
      ctx.fillStyle='#9aa3b2';ctx.font='9px Inter,sans-serif';ctx.textAlign='center';
      const totalSec = settings.duration;
      const step = totalSec <= 30 ? 5 : totalSec <= 60 ? 10 : 60;
      for(let s = step; s < totalSec; s += step){
        const frac = s / totalSec;
        const x = padL + frac * cW;
        ctx.beginPath();ctx.moveTo(x,padT);ctx.lineTo(x,padT+cH);ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.stroke();
        ctx.fillText(s + 's', x, padT+cH+12);
      }
    } else {
      const MARKET_START=9.5, MARKET_END=16;
      ctx.fillStyle='#9aa3b2';ctx.font='9px Inter,sans-serif';ctx.textAlign='center';
      for(let hr=10;hr<=15;hr++){
        const frac=(hr-MARKET_START)/(MARKET_END-MARKET_START);
        const x=padL+frac*cW;
        ctx.beginPath();ctx.moveTo(x,padT);ctx.lineTo(x,padT+cH);ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.stroke();
        const label=hr<=12?hr+'am':(hr-12)+'pm';
        ctx.fillText(label,x,padT+cH+12);
      }
    }

    ctx.strokeStyle='#4f8cff';ctx.lineWidth=2;ctx.beginPath();
    for(let i=0;i<=currentTick;i++){
      const x=padL+(i/TOTAL_TICKS)*cW;
      const y=padT+cH*(1-(slice[i]-minP)/range);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    const lastX=padL+(currentTick/TOTAL_TICKS)*cW;
    const lastY=padT+cH*(1-(slice[currentTick]-minP)/range);
    ctx.lineTo(lastX,padT+cH);ctx.lineTo(padL,padT+cH);ctx.closePath();
    ctx.fillStyle='rgba(79,140,255,0.08)';ctx.fill();

    // Average price horizontal line
    if(position !== 0 && avgPrice >= minP && avgPrice <= maxP){
      const avgY = padT + cH * (1 - (avgPrice - minP) / range);
      const color = position > 0 ? '#34d399' : '#ef4444';
      ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.setLineDash([4,4]);
      ctx.beginPath(); ctx.moveTo(padL, avgY); ctx.lineTo(W-padR, avgY); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = color; ctx.font = '9px Inter,sans-serif'; ctx.textAlign = 'right';
      ctx.fillText('avg $'+avgPrice.toFixed(2), W-padR, avgY-3);
    }

    ctx.fillStyle='#4f8cff';ctx.beginPath();ctx.arc(lastX,lastY,4,0,Math.PI*2);ctx.fill();

    ctx.fillStyle='#f5f7fa';ctx.font='11px Inter,sans-serif';ctx.textAlign='right';
    ctx.fillText('$'+slice[currentTick].toFixed(2),W-padR,padT-5);
    ctx.fillStyle='#9aa3b2';ctx.font='10px Inter,sans-serif';ctx.textAlign='left';
    ctx.fillText('$'+slice[0].toFixed(2),padL,padT+cH+24);
  }

  function tick(){
    if(currentTick>=TOTAL_TICKS){endGame();return;}
    const prevPrice = prices[currentTick];
    currentTick++;
    const newPrice = prices[currentTick];
    pnl += position * MULTIPLIER * (newPrice - prevPrice);
    posHistory[currentTick] = position;
    document.getElementById('trade-price').textContent = '$'+newPrice.toFixed(2);
    updatePnlDisplay();
    document.getElementById('trade-timer-fill').style.width = (currentTick/TOTAL_TICKS*100)+'%';
    drawChart();
  }

  function startGame(){
    settings = loadSettings();
    DURATION = settings.duration * 1000;
    TOTAL_TICKS = DURATION / TICK;

    prices = fetchRealPrices();

    currentTick = 0; position = 0; pnl = 0; running = true; paused = false;
    totalCost = 0; avgPrice = 0; realizedPnl = 0; tradedVolume = 0;
    posHistory = [0];
    tradeLog = [];
    document.getElementById('trade-log').style.display = '';
    document.getElementById('trade-lb').style.display = 'none';
    renderTradeLog();
    document.getElementById('trade-price').textContent = '$'+prices[0].toFixed(2);
    document.getElementById('trade-pos').textContent = '0';
    updatePnlDisplay();
    updatePosDisplay();
    document.getElementById('trade-timer-fill').style.width = '0%';
    document.getElementById('trade-overlay-start').classList.add('hidden');
    document.getElementById('trade-overlay-end').classList.add('hidden');
    document.getElementById('trade-overlay-pause').classList.add('hidden');
    document.getElementById('game-settings-modal').classList.add('hidden');
    document.getElementById('trade-paused-badge').classList.remove('visible');
    document.getElementById('trade-buy-btn').disabled = false;
    document.getElementById('trade-sell-btn').disabled = false;
    drawChart();
    if(loop) clearInterval(loop);
    loop = setInterval(tick, TICK);
  }

  function endGame(){
    running = false; paused = false;
    clearInterval(loop);
    document.getElementById('trade-buy-btn').disabled = true;
    document.getElementById('trade-sell-btn').disabled = true;
    document.getElementById('trade-overlay-pause').classList.add('hidden');
    document.getElementById('trade-paused-badge').classList.remove('visible');
    const el = document.getElementById('trade-result');
    const sign = pnl>=0?'+':'';
    el.textContent = `${sign}$${Math.abs(pnl).toFixed(2)}`;
    el.style.color = pnl>=0?'#34d399':'#ef4444';

    // Show date and chart link
    document.getElementById('trade-vol-info').textContent = 'Volume: ' + fmtVol(tradedVolume);
    const dateInfo = document.getElementById('trade-date-info');
    if(tradingDate === 'Simulated'){
      dateInfo.innerHTML = `Trading day: <strong>Simulated</strong>`;
    } else {
      const formattedDate = new Date(tradingDate + 'T12:00:00').toLocaleDateString('en-US', {
        year: 'numeric', month: 'short', day: 'numeric'
      });
      const d = new Date(tradingDate + 'T00:00:00');
      const p1 = Math.floor(d.getTime()/1000);
      const p2 = p1 + 86400;
      const yahooUrl = `https://finance.yahoo.com/quote/SPY/history/?period1=${p1}&period2=${p2}`;
      dateInfo.innerHTML = `Trading day: <strong>${formattedDate}</strong><br><a href="${yahooUrl}" target="_blank" rel="noopener" style="color:var(--accent);text-decoration:none;font-size:0.8rem">View on Yahoo Finance &rarr;</a>`;
    }

    // Show total PnL at game end regardless of mode
    document.getElementById('trade-pnl-total').style.display = '';
    document.getElementById('trade-pnl-realized').style.display = 'none';
    document.getElementById('trade-pnl-unrealized').style.display = 'none';
    const pnlEl = document.getElementById('trade-pnl');
    const pnlSign = pnl>=0?'+':'';
    pnlEl.textContent = `${pnlSign}$${Math.abs(pnl).toFixed(2)}`;
    pnlEl.className = pnl>=0?'pnl-pos':'pnl-neg';

    document.getElementById('trade-overlay-end').classList.remove('hidden');
    const lb = loadTradeLB();
    lb.push({pnl: parseFloat(pnl.toFixed(2)), vol: Math.round(tradedVolume), date: new Date().toISOString()});
    lb.sort((a,b)=>b.pnl-a.pnl);
    if(lb.length>5) lb.length=5;
    saveTradeLB(lb);
    renderTradeLB();
    document.getElementById('trade-log').style.display = 'none';
    document.getElementById('trade-lb').style.display = '';
  }

  // Settings modal
  document.getElementById('game-settings-btn').addEventListener('click', ()=>{
    if(running && !paused) togglePause();
    document.getElementById('game-settings-modal').classList.remove('hidden');
  });
  document.getElementById('ts-close').addEventListener('click', ()=>{
    settings.dataSource = document.getElementById('ts-source').value;
    settings.duration = parseInt(document.getElementById('ts-duration').value);
    settings.pnlMode = document.getElementById('ts-pnlmode').value;
    settings.posTint = document.getElementById('ts-postint').value === 'on';
    saveSettings(settings);
    // Apply PnL mode immediately if a game is running
    if(running) updatePnlDisplay();
    document.getElementById('game-settings-modal').classList.add('hidden');
  });
  document.getElementById('trade-clear-lb').addEventListener('click', ()=>{
    if(confirm('Clear the trading leaderboard?')){
      localStorage.removeItem('tradeLB');
      renderTradeLB();
    }
  });

  document.getElementById('trade-buy-btn').addEventListener('click', doBuy);
  document.getElementById('trade-sell-btn').addEventListener('click', doSell);
  document.getElementById('trade-start-btn').addEventListener('click', startGame);
  document.getElementById('trade-restart-btn').addEventListener('click', startGame);
  document.getElementById('trade-resume-btn').addEventListener('click', togglePause);
  document.getElementById('trade-end-btn').addEventListener('click', ()=>{ if(running) endGame(); });

  document.addEventListener('keydown', e=>{
    if((e.key===' '||e.key==='Escape') && running){ togglePause(); e.preventDefault(); return; }
    if(!running||paused) return;
    if(e.key==='ArrowUp'||e.key==='ArrowRight'){doBuy();e.preventDefault();}
    if(e.key==='ArrowDown'||e.key==='ArrowLeft'){doSell();e.preventDefault();}
  });

  ctx.fillStyle='#0b0d10';ctx.fillRect(0,0,W,H);

  // Fullscreen
  document.getElementById('trade-fullscreen-btn').addEventListener('click', ()=>{
    const el = document.getElementById('trade-wrap');
    if(!document.fullscreenElement) el.requestFullscreen().catch(()=>{});
    else document.exitFullscreen();
  });
  document.addEventListener('fullscreenchange', ()=>{
    const wrap = document.getElementById('trade-wrap');
    if(document.fullscreenElement === wrap){
      const maxW = Math.min(window.innerWidth - 48, 1200);
      W = maxW;
      H = Math.round(maxW * 0.55);
      canvas.width = W;
      canvas.height = H;
    } else {
      W = 400; H = 220;
      canvas.width = W;
      canvas.height = H;
    }
    drawChart();
  });
})();

// Whiteboard — object-based with infinite canvas (pan/zoom) & object eraser
(function(){
  const canvas = document.getElementById('wb-canvas');
  const ctx = canvas.getContext('2d');
  const gridCanvas = document.getElementById('wb-grid');
  const gridCtx = gridCanvas.getContext('2d');
  const area = document.getElementById('wb-canvas-area');
  const wrap = document.getElementById('wb-wrap');
  const BG = '#181b22';

  let W = canvas.width, H = canvas.height;
  let tool = 'pen';
  let color = '#f5f7fa';
  let lineWidth = 3;
  let opacity = 1;
  let fillShapes = false;
  let showGrid = false;
  let drawing = false;
  let shiftHeld = false;
  let spaceHeld = false;

  // --- Pan & Zoom state ---
  let panX = 0, panY = 0;
  let zoom = 1;
  const MIN_ZOOM = 0.1, MAX_ZOOM = 5;
  let isPanning = false;
  let panStartMouse = null;
  let panStartOffset = null;

  // --- Object store ---
  // Each object: {type, color, lineWidth, opacity, points?, x1,y1,x2,y2?, fill?, text?, fontSize?}
  let objects = [];
  let currentObj = null;   // stroke/shape being drawn
  let previewShape = null; // shape preview during drag

  // --- History (snapshots of objects array) ---
  let undoStack = [];
  let redoStack = [];
  const MAX_HISTORY = 40;

  function deepClone(arr){ return JSON.parse(JSON.stringify(arr)); }

  function saveState(){
    undoStack.push(deepClone(objects));
    if(undoStack.length > MAX_HISTORY) undoStack.shift();
    redoStack = [];
  }

  // --- Coordinate conversion ---
  function getScreenPos(e){
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * (W / rect.width),
      y: (e.clientY - rect.top) * (H / rect.height)
    };
  }
  function screenToWorld(sx, sy){
    return { x: (sx - panX) / zoom, y: (sy - panY) / zoom };
  }
  function getPos(e){
    const sp = getScreenPos(e);
    return screenToWorld(sp.x, sp.y);
  }

  // --- Color helpers ---
  function colorWithOpacity(c, a){
    const r = parseInt(c.slice(1,3),16);
    const g = parseInt(c.slice(3,5),16);
    const b = parseInt(c.slice(5,7),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  // --- Draw a single object to a context ---
  function drawObject(c, obj){
    c.save();
    if(obj.type === 'pen'){
      c.strokeStyle = colorWithOpacity(obj.color, obj.opacity);
      c.lineWidth = obj.lineWidth;
      c.lineCap = 'round'; c.lineJoin = 'round';
      if(obj.points.length === 1){
        c.beginPath();
        c.arc(obj.points[0].x, obj.points[0].y, obj.lineWidth/2, 0, Math.PI*2);
        c.fillStyle = colorWithOpacity(obj.color, obj.opacity);
        c.fill();
      } else {
        c.beginPath();
        c.moveTo(obj.points[0].x, obj.points[0].y);
        for(let i=1; i<obj.points.length; i++){
          const prev = obj.points[i-1], curr = obj.points[i];
          const mx = (prev.x+curr.x)/2, my = (prev.y+curr.y)/2;
          c.quadraticCurveTo(prev.x, prev.y, mx, my);
        }
        const last = obj.points[obj.points.length-1];
        c.lineTo(last.x, last.y);
        c.stroke();
      }
    } else if(obj.type === 'highlighter'){
      c.globalCompositeOperation = 'screen';
      c.globalAlpha = 0.15;
      c.strokeStyle = obj.color;
      c.lineWidth = obj.lineWidth * 6;
      c.lineCap = 'round'; c.lineJoin = 'round';
      if(obj.points.length === 1){
        c.beginPath();
        c.arc(obj.points[0].x, obj.points[0].y, obj.lineWidth*3, 0, Math.PI*2);
        c.fillStyle = obj.color; c.fill();
      } else {
        c.beginPath();
        c.moveTo(obj.points[0].x, obj.points[0].y);
        for(let i=1; i<obj.points.length; i++){
          const prev = obj.points[i-1], curr = obj.points[i];
          const mx = (prev.x+curr.x)/2, my = (prev.y+curr.y)/2;
          c.quadraticCurveTo(prev.x, prev.y, mx, my);
        }
        const last = obj.points[obj.points.length-1];
        c.lineTo(last.x, last.y);
        c.stroke();
      }
    } else if(obj.type === 'line'){
      c.globalAlpha = obj.opacity;
      c.strokeStyle = obj.color; c.lineWidth = obj.lineWidth;
      c.lineCap = 'round';
      c.beginPath(); c.moveTo(obj.x1,obj.y1); c.lineTo(obj.x2,obj.y2); c.stroke();
    } else if(obj.type === 'arrow'){
      c.globalAlpha = obj.opacity;
      c.strokeStyle = obj.color; c.fillStyle = obj.color;
      c.lineWidth = obj.lineWidth; c.lineCap = 'round'; c.lineJoin = 'round';
      const angle = Math.atan2(obj.y2-obj.y1, obj.x2-obj.x1);
      const headLen = Math.max(14, obj.lineWidth*5);
      const tipX = obj.x2 - headLen*0.3*Math.cos(angle);
      const tipY = obj.y2 - headLen*0.3*Math.sin(angle);
      c.beginPath(); c.moveTo(obj.x1,obj.y1); c.lineTo(tipX,tipY); c.stroke();
      c.beginPath(); c.moveTo(obj.x2,obj.y2);
      c.lineTo(obj.x2 - headLen*Math.cos(angle-Math.PI/7), obj.y2 - headLen*Math.sin(angle-Math.PI/7));
      c.lineTo(obj.x2 - headLen*Math.cos(angle+Math.PI/7), obj.y2 - headLen*Math.sin(angle+Math.PI/7));
      c.closePath(); c.fill();
    } else if(obj.type === 'rect'){
      c.globalAlpha = obj.opacity;
      c.strokeStyle = obj.color; c.fillStyle = obj.color;
      c.lineWidth = obj.lineWidth; c.lineCap = 'round'; c.lineJoin = 'round';
      const rx = Math.min(obj.x1,obj.x2), ry = Math.min(obj.y1,obj.y2);
      const rw = Math.abs(obj.x2-obj.x1), rh = Math.abs(obj.y2-obj.y1);
      if(obj.fill) c.fillRect(rx,ry,rw,rh);
      c.strokeRect(rx,ry,rw,rh);
    } else if(obj.type === 'ellipse'){
      c.globalAlpha = obj.opacity;
      c.strokeStyle = obj.color; c.fillStyle = obj.color;
      c.lineWidth = obj.lineWidth;
      const cx = (obj.x1+obj.x2)/2, cy = (obj.y1+obj.y2)/2;
      const rx = Math.abs(obj.x2-obj.x1)/2, ry = Math.abs(obj.y2-obj.y1)/2;
      c.beginPath(); c.ellipse(cx,cy,Math.max(0,rx),Math.max(0,ry),0,0,Math.PI*2);
      if(obj.fill) c.fill(); c.stroke();
    } else if(obj.type === 'text'){
      c.globalAlpha = obj.opacity;
      c.font = `${obj.fontSize}px Inter, sans-serif`;
      c.fillStyle = obj.color; c.textBaseline = 'top';
      const lines = obj.text.split('\n');
      const lineH = obj.fontSize * 1.3;
      lines.forEach((line,i)=>{ c.fillText(line, obj.x, obj.y + i*lineH); });
    }
    c.restore();
  }

  // --- Full render ---
  function render(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = BG;
    ctx.fillRect(0,0,W,H);
    ctx.setTransform(zoom,0,0,zoom,panX,panY);
    for(const obj of objects) drawObject(ctx, obj);
    if(currentObj) drawObject(ctx, currentObj);
    if(previewShape) drawObject(ctx, previewShape);
    ctx.setTransform(1,0,0,1,0,0);
  }

  function renderGrid(){
    gridCtx.setTransform(1,0,0,1,0,0);
    gridCtx.clearRect(0,0,W,H);
    if(!showGrid) return;
    const step = 24;
    gridCtx.setTransform(zoom,0,0,zoom,panX,panY);
    const x0 = Math.floor(-panX/zoom/step)*step;
    const y0 = Math.floor(-panY/zoom/step)*step;
    const x1 = Math.ceil((W-panX)/zoom/step)*step;
    const y1 = Math.ceil((H-panY)/zoom/step)*step;
    gridCtx.fillStyle = 'rgba(255,255,255,0.08)';
    for(let x=x0; x<=x1; x+=step){
      for(let y=y0; y<=y1; y+=step){
        gridCtx.beginPath();
        gridCtx.arc(x, y, 1/zoom, 0, Math.PI*2);
        gridCtx.fill();
      }
    }
    gridCtx.setTransform(1,0,0,1,0,0);
  }

  // Initial render
  render();
  saveState();

  // --- Zoom helpers ---
  function updateZoomLabel(){
    const el = document.getElementById('wb-zoom-label');
    if(el) el.textContent = Math.round(zoom*100) + '%';
  }

  function zoomAt(sx, sy, factor){
    const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom * factor));
    const scale = newZoom / zoom;
    panX = sx - (sx - panX) * scale;
    panY = sy - (sy - panY) * scale;
    zoom = newZoom;
    render(); renderGrid(); updateZoomLabel();
  }

  function zoomCenter(factor){
    zoomAt(W/2, H/2, factor);
  }

  function resetView(){
    panX = 0; panY = 0; zoom = 1;
    render(); renderGrid(); updateZoomLabel();
  }

  // --- Hit testing for object eraser ---
  function ptSegDistSq(px,py, ax,ay, bx,by){
    const dx=bx-ax, dy=by-ay, lenSq=dx*dx+dy*dy;
    if(lenSq===0) return (px-ax)**2+(py-ay)**2;
    let t = ((px-ax)*dx+(py-ay)*dy)/lenSq;
    t = Math.max(0,Math.min(1,t));
    const projX=ax+t*dx, projY=ay+t*dy;
    return (px-projX)**2+(py-projY)**2;
  }

  function hitTest(obj, wx, wy, radius){
    const rSq = radius*radius;
    if(obj.type === 'pen' || obj.type === 'highlighter'){
      const hw = obj.type==='highlighter' ? obj.lineWidth*3 : obj.lineWidth/2;
      const thr = (radius+hw)*(radius+hw);
      for(let i=0; i<obj.points.length; i++){
        const p = obj.points[i];
        if(i===0){
          if((wx-p.x)**2+(wy-p.y)**2 < thr) return true;
        } else {
          const q = obj.points[i-1];
          if(ptSegDistSq(wx,wy, q.x,q.y, p.x,p.y) < thr) return true;
        }
      }
      return false;
    }
    if(obj.type === 'line' || obj.type === 'arrow'){
      const thr = radius + obj.lineWidth/2;
      return ptSegDistSq(wx,wy, obj.x1,obj.y1, obj.x2,obj.y2) < thr*thr;
    }
    if(obj.type === 'rect'){
      const x1=Math.min(obj.x1,obj.x2), y1=Math.min(obj.y1,obj.y2);
      const x2=Math.max(obj.x1,obj.x2), y2=Math.max(obj.y1,obj.y2);
      if(obj.fill){
        return wx>=x1-radius && wx<=x2+radius && wy>=y1-radius && wy<=y2+radius;
      }
      const thr = radius+obj.lineWidth/2, tSq=thr*thr;
      return ptSegDistSq(wx,wy,x1,y1,x2,y1)<tSq || ptSegDistSq(wx,wy,x2,y1,x2,y2)<tSq ||
             ptSegDistSq(wx,wy,x2,y2,x1,y2)<tSq || ptSegDistSq(wx,wy,x1,y2,x1,y1)<tSq;
    }
    if(obj.type === 'ellipse'){
      const cx=(obj.x1+obj.x2)/2, cy=(obj.y1+obj.y2)/2;
      const rx=Math.abs(obj.x2-obj.x1)/2+radius, ry=Math.abs(obj.y2-obj.y1)/2+radius;
      if(rx===0||ry===0) return false;
      const nx=(wx-cx)/rx, ny=(wy-cy)/ry;
      if(nx*nx+ny*ny > 1) return false;
      if(obj.fill) return true;
      const irx=Math.max(0,Math.abs(obj.x2-obj.x1)/2-radius-obj.lineWidth);
      const iry=Math.max(0,Math.abs(obj.y2-obj.y1)/2-radius-obj.lineWidth);
      if(irx===0||iry===0) return true;
      const inx=(wx-cx)/irx, iny=(wy-cy)/iry;
      return inx*inx+iny*iny >= 1;
    }
    if(obj.type === 'text'){
      const lines = obj.text.split('\n');
      const lineH = obj.fontSize*1.3;
      const h = lines.length*lineH;
      const w = Math.max(...lines.map(l=>l.length*obj.fontSize*0.6));
      return wx>=obj.x-radius && wx<=obj.x+w+radius && wy>=obj.y-radius && wy<=obj.y+h+radius;
    }
    return false;
  }

  function eraseAt(wx, wy){
    const radius = Math.max(8, lineWidth*2) / zoom;
    let removed = false;
    for(let i=objects.length-1; i>=0; i--){
      if(hitTest(objects[i], wx, wy, radius)){
        objects.splice(i,1);
        removed = true;
      }
    }
    if(removed) render();
    return removed;
  }

  // --- Shift constraints ---
  function constrain(x1,y1,x2,y2){
    if(!shiftHeld) return {x2,y2};
    const dx=x2-x1, dy=y2-y1;
    if(tool==='line'||tool==='arrow'){
      const angle = Math.atan2(dy,dx);
      const snap = Math.round(angle/(Math.PI/4))*(Math.PI/4);
      const dist = Math.sqrt(dx*dx+dy*dy);
      return { x2: x1+dist*Math.cos(snap), y2: y1+dist*Math.sin(snap) };
    }
    if(tool==='rect'||tool==='ellipse'){
      const side = Math.max(Math.abs(dx),Math.abs(dy));
      return { x2: x1+side*Math.sign(dx||1), y2: y1+side*Math.sign(dy||1) };
    }
    return {x2,y2};
  }

  // --- Text tool ---
  let activeTextInput = null;
  let textDragStart = null;  // {cx, cy} in CSS coords relative to area
  let textDragPreview = null; // preview div during drag

  function commitText(){
    if(!activeTextInput) return;
    const txt = activeTextInput.value.trim();
    if(txt){
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      const scaleY = H / rect.height;
      const box = activeTextInput.getBoundingClientRect();
      const sx = (box.left - rect.left) * scaleX;
      const sy = (box.top - rect.top) * scaleY;
      const wpos = screenToWorld(sx, sy);
      const fontSize = parseFloat(activeTextInput.style.fontSize) * scaleX / zoom;
      objects.push({
        type:'text', x: wpos.x + 4/zoom, y: wpos.y + 2/zoom,
        text: txt, fontSize, color, opacity
      });
      saveState();
      render();
    }
    activeTextInput.remove();
    activeTextInput = null;
  }

  function createTextArea(left, top, width, height, fontSize){
    commitText();
    const ta = document.createElement('textarea');
    ta.className = 'wb-text-input';
    ta.style.left = left + 'px';
    ta.style.top = top + 'px';
    ta.style.fontSize = fontSize + 'px';
    ta.style.color = colorWithOpacity(color, opacity);
    const isFixed = width != null;
    let currentFontSize = fontSize;
    const minFontSize = 8;
    if(isFixed){
      ta.style.width = width + 'px';
      ta.style.height = height + 'px';
    } else {
      ta.rows = 1;
    }
    area.appendChild(ta);
    activeTextInput = ta;
    let ready = false;
    setTimeout(()=>{ ta.focus(); ready = true; }, 50);

    function autoFit(){
      if(isFixed){
        // Shrink font until text fits, grow back if possible
        while(ta.scrollHeight > ta.clientHeight && currentFontSize > minFontSize){
          currentFontSize = Math.max(minFontSize, currentFontSize - 1);
          ta.style.fontSize = currentFontSize + 'px';
        }
        // Try growing back if there's room
        while(currentFontSize < fontSize){
          ta.style.fontSize = (currentFontSize + 1) + 'px';
          if(ta.scrollHeight > ta.clientHeight){
            ta.style.fontSize = currentFontSize + 'px';
            break;
          }
          currentFontSize++;
        }
      } else {
        ta.style.height = 'auto';
        ta.style.height = ta.scrollHeight + 'px';
      }
    }

    ta.addEventListener('input', autoFit);
    ta.addEventListener('keydown', (ev)=>{
      ev.stopPropagation();
      if(ev.key === 'Escape'){ commitText(); }
      if(ev.key === 'Enter' && !ev.shiftKey){ ev.preventDefault(); commitText(); }
    });
    ta.addEventListener('blur', ()=>{ if(ready) setTimeout(commitText, 100); });
  }

  function startTextDrag(e){
    commitText();
    const rect = canvas.getBoundingClientRect();
    textDragStart = { cx: e.clientX - rect.left, cy: e.clientY - rect.top };
    // Create preview box
    textDragPreview = document.createElement('div');
    textDragPreview.style.cssText = `position:absolute;border:1px dashed rgba(79,140,255,0.6);pointer-events:none;z-index:5;
      left:${textDragStart.cx}px;top:${textDragStart.cy}px;width:0;height:0;`;
    area.appendChild(textDragPreview);
  }

  function moveTextDrag(e){
    if(!textDragPreview || !textDragStart) return;
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const left = Math.min(textDragStart.cx, cx);
    const top = Math.min(textDragStart.cy, cy);
    const w = Math.abs(cx - textDragStart.cx);
    const h = Math.abs(cy - textDragStart.cy);
    textDragPreview.style.left = left + 'px';
    textDragPreview.style.top = top + 'px';
    textDragPreview.style.width = w + 'px';
    textDragPreview.style.height = h + 'px';
  }

  function endTextDrag(e){
    if(!textDragStart) return;
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const left = Math.min(textDragStart.cx, cx);
    const top = Math.min(textDragStart.cy, cy);
    const w = Math.abs(cx - textDragStart.cx);
    const h = Math.abs(cy - textDragStart.cy);
    if(textDragPreview){ textDragPreview.remove(); textDragPreview = null; }
    const MIN_DRAG = 20;
    if(w > MIN_DRAG && h > MIN_DRAG){
      // Font size proportional to box height (~60% of height for single line)
      const fontSize = Math.max(12, Math.min(200, Math.round(h * 0.6)));
      createTextArea(left, top, w, h, fontSize);
    } else {
      const cssSize = Math.max(14, lineWidth * 5);
      createTextArea(textDragStart.cx, textDragStart.cy, null, null, cssSize);
    }
    textDragStart = null;
  }

  // --- Pointer events ---
  let startWX, startWY;
  let eraserDirty = false;

  function shouldPan(e){
    return tool === 'hand' || spaceHeld || e.button === 1;
  }

  function onPointerDown(e){
    // Pan: hand tool, space+drag, or middle mouse
    if(shouldPan(e)){
      isPanning = true;
      panStartMouse = getScreenPos(e);
      panStartOffset = { x: panX, y: panY };
      area.classList.add('panning-active');
      e.preventDefault();
      return;
    }
    if(e.button && e.button !== 0) return;
    if(tool === 'text'){ startTextDrag(e); e.preventDefault(); return; }
    e.preventDefault();
    drawing = true;
    const pos = getPos(e);
    startWX = pos.x; startWY = pos.y;

    if(tool === 'pen'){
      currentObj = { type:'pen', points:[{x:pos.x,y:pos.y}], color, lineWidth, opacity };
    } else if(tool === 'highlighter'){
      currentObj = { type:'highlighter', points:[{x:pos.x,y:pos.y}], color, lineWidth };
    } else if(tool === 'eraser'){
      eraserDirty = false;
      if(eraseAt(pos.x, pos.y)) eraserDirty = true;
    }
    // shapes: startWX/startWY recorded, preview on move
  }

  function onPointerMove(e){
    if(isPanning){
      const sp = getScreenPos(e);
      panX = panStartOffset.x + (sp.x - panStartMouse.x);
      panY = panStartOffset.y + (sp.y - panStartMouse.y);
      render(); renderGrid(); updateZoomLabel();
      return;
    }
    if(textDragStart){ moveTextDrag(e); return; }
    if(!drawing) return;
    e.preventDefault();
    const pos = getPos(e);

    if(tool === 'pen' || tool === 'highlighter'){
      currentObj.points.push({x:pos.x, y:pos.y});
      render();
    } else if(tool === 'eraser'){
      if(eraseAt(pos.x, pos.y)) eraserDirty = true;
    } else {
      // Shape preview
      const c = constrain(startWX, startWY, pos.x, pos.y);
      previewShape = {
        type: tool, x1:startWX, y1:startWY, x2:c.x2, y2:c.y2,
        color, lineWidth, opacity, fill:fillShapes
      };
      render();
    }
  }

  function onPointerUp(e){
    if(isPanning){
      isPanning = false;
      area.classList.remove('panning-active');
      updateCursor();
      return;
    }
    if(textDragStart){ endTextDrag(e); return; }
    if(!drawing) return;
    drawing = false;
    const pos = getPos(e);

    if(tool === 'pen' || tool === 'highlighter'){
      if(currentObj){
        objects.push(currentObj);
        currentObj = null;
        saveState(); render();
      }
    } else if(tool === 'eraser'){
      if(eraserDirty) saveState();
    } else {
      // Finalize shape
      const c = constrain(startWX, startWY, pos.x, pos.y);
      objects.push({
        type:tool, x1:startWX, y1:startWY, x2:c.x2, y2:c.y2,
        color, lineWidth, opacity, fill:fillShapes
      });
      previewShape = null;
      saveState(); render();
    }
  }

  // Pointer capture for smooth drawing
  canvas.addEventListener('pointerdown', (e)=>{
    canvas.setPointerCapture(e.pointerId);
    onPointerDown(e);
  });
  canvas.addEventListener('pointermove', onPointerMove);
  canvas.addEventListener('pointerup', (e)=>{
    canvas.releasePointerCapture(e.pointerId);
    onPointerUp(e);
  });
  canvas.addEventListener('lostpointercapture', (e)=>{ if(drawing||isPanning||textDragStart) onPointerUp(e); });
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); }, {passive:false});
  canvas.addEventListener('touchmove', e=>{ e.preventDefault(); }, {passive:false});

  // --- Scroll wheel zoom / trackpad pan ---
  area.addEventListener('wheel', (e)=>{
    e.preventDefault();
    if(e.ctrlKey || e.metaKey){
      // Pinch-to-zoom (trackpad) or Ctrl+scroll
      const sp = getScreenPos(e);
      const factor = e.deltaY < 0 ? 1.08 : 1/1.08;
      zoomAt(sp.x, sp.y, factor);
    } else {
      // Two-finger scroll → pan
      panX -= e.deltaX;
      panY -= e.deltaY;
      render(); renderGrid(); updateZoomLabel();
    }
  }, {passive:false});

  // --- Cursors ---
  function updateCursor(){
    area.classList.remove('panning','panning-active');
    if(tool === 'hand'){
      area.style.cursor = 'grab';
      area.classList.add('panning');
    } else if(tool === 'eraser'){
      const sz = Math.max(8, lineWidth * 4);
      const half = Math.round(sz / 2);
      const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${sz}' height='${sz}'><circle cx='${half}' cy='${half}' r='${half-1}' fill='none' stroke='white' stroke-width='1.5'/></svg>`;
      area.style.cursor = `url("data:image/svg+xml,${encodeURIComponent(svg)}") ${half} ${half}, cell`;
    } else if(tool === 'pen' || tool === 'highlighter'){
      const sz = tool === 'highlighter' ? Math.max(8, lineWidth * 6) : Math.max(6, lineWidth);
      const half = Math.round(sz / 2);
      const svgSz = sz + 4;
      const c = svgSz / 2;
      const r = half;
      const encoded = color.replace('#','%23');
      const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${svgSz}' height='${svgSz}'><circle cx='${c}' cy='${c}' r='${r}' fill='${encoded}' opacity='${tool==="highlighter"?0.4:opacity}'/><circle cx='${c}' cy='${c}' r='${r}' fill='none' stroke='white' stroke-width='0.5' opacity='0.6'/></svg>`;
      area.style.cursor = `url("data:image/svg+xml,${encodeURIComponent(svg)}") ${c} ${c}, crosshair`;
    } else if(tool === 'text'){
      area.style.cursor = 'text';
    } else {
      area.style.cursor = 'crosshair';
    }
  }
  updateCursor();

  // --- Tool selection ---
  document.querySelectorAll('#wb-tools .wb-btn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      commitText();
      document.querySelectorAll('#wb-tools .wb-btn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      tool = btn.dataset.tool;
      updateCursor();
    });
  });

  // --- Color selection ---
  document.querySelectorAll('#wb-colors .wb-color-btn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      document.querySelectorAll('#wb-colors .wb-color-btn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      color = btn.dataset.color;
      document.getElementById('wb-custom-color').classList.remove('active');
      updateCursor();
    });
  });
  const customColor = document.getElementById('wb-custom-color');
  customColor.addEventListener('input', ()=>{
    color = customColor.value;
    document.querySelectorAll('#wb-colors .wb-color-btn').forEach(b=>b.classList.remove('active'));
    updateCursor();
  });

  // --- Size slider ---
  const sizeSlider = document.getElementById('wb-size');
  const sizeLabel = document.getElementById('wb-size-label');
  sizeSlider.addEventListener('input', ()=>{
    lineWidth = parseInt(sizeSlider.value);
    sizeLabel.textContent = lineWidth;
    updateCursor();
  });

  // --- Opacity slider ---
  const opacitySlider = document.getElementById('wb-opacity');
  const opacityLabel = document.getElementById('wb-opacity-label');
  opacitySlider.addEventListener('input', ()=>{
    opacity = parseInt(opacitySlider.value) / 100;
    opacityLabel.textContent = parseInt(opacitySlider.value) + '%';
    updateCursor();
  });

  // Fill toggle
  document.getElementById('wb-fill-check').addEventListener('change', (e)=>{
    fillShapes = e.target.checked;
  });

  // Grid toggle
  document.getElementById('wb-grid-check').addEventListener('change', (e)=>{
    showGrid = e.target.checked;
    gridCanvas.classList.toggle('visible', showGrid);
    renderGrid();
  });

  // --- Undo / Redo ---
  function undo(){
    commitText();
    if(undoStack.length <= 1) return;
    redoStack.push(undoStack.pop());
    objects = deepClone(undoStack[undoStack.length-1]);
    render();
  }
  function redo(){
    if(redoStack.length === 0) return;
    const state = redoStack.pop();
    undoStack.push(state);
    objects = deepClone(state);
    render();
  }
  document.getElementById('wb-undo-btn').addEventListener('click', undo);
  document.getElementById('wb-redo-btn').addEventListener('click', redo);

  // Clear
  document.getElementById('wb-clear-btn').addEventListener('click', ()=>{
    commitText();
    if(!confirm('Clear the whiteboard?')) return;
    objects = [];
    saveState(); render();
  });

  // Download — renders all objects to a tight bounding box PNG
  document.getElementById('wb-download-btn').addEventListener('click', ()=>{
    // Find bounding box of all objects
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    function expandPt(x,y){ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; }
    function expandObj(obj){
      const pad = obj.lineWidth ? obj.lineWidth*4 : 20;
      if(obj.points){
        obj.points.forEach(p=>{ expandPt(p.x-pad,p.y-pad); expandPt(p.x+pad,p.y+pad); });
      } else if(obj.type==='text'){
        const lines = obj.text.split('\n');
        const lineH = obj.fontSize*1.3;
        const h = lines.length*lineH;
        const w = Math.max(...lines.map(l=>l.length*obj.fontSize*0.6));
        expandPt(obj.x-pad,obj.y-pad); expandPt(obj.x+w+pad,obj.y+h+pad);
      } else {
        expandPt(Math.min(obj.x1,obj.x2)-pad, Math.min(obj.y1,obj.y2)-pad);
        expandPt(Math.max(obj.x1,obj.x2)+pad, Math.max(obj.y1,obj.y2)+pad);
      }
    }
    if(objects.length === 0){
      // Export current viewport
      const link = document.createElement('a');
      link.download = 'whiteboard.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
      return;
    }
    objects.forEach(expandObj);
    const margin = 20;
    minX -= margin; minY -= margin; maxX += margin; maxY += margin;
    const expW = Math.ceil(maxX-minX), expH = Math.ceil(maxY-minY);
    const offscreen = document.createElement('canvas');
    offscreen.width = expW; offscreen.height = expH;
    const oCtx = offscreen.getContext('2d');
    oCtx.fillStyle = BG;
    oCtx.fillRect(0,0,expW,expH);
    oCtx.translate(-minX, -minY);
    for(const obj of objects) drawObject(oCtx, obj);
    const link = document.createElement('a');
    link.download = 'whiteboard.png';
    link.href = offscreen.toDataURL('image/png');
    link.click();
  });

  // --- Zoom buttons ---
  document.getElementById('wb-zoom-in').addEventListener('click', ()=> zoomCenter(1.25));
  document.getElementById('wb-zoom-out').addEventListener('click', ()=> zoomCenter(1/1.25));
  document.getElementById('wb-zoom-label').addEventListener('dblclick', resetView);

  // --- Fullscreen ---
  document.getElementById('wb-fullscreen-btn').addEventListener('click', ()=>{
    if(!document.fullscreenElement) wrap.requestFullscreen().catch(()=>{});
    else document.exitFullscreen();
  });

  document.addEventListener('fullscreenchange', ()=>{
    if(document.fullscreenElement === wrap){
      W = window.innerWidth;
      H = window.innerHeight - document.getElementById('wb-toolbar').offsetHeight;
    } else {
      W = 1200; H = 600;
    }
    canvas.width = W; canvas.height = H;
    gridCanvas.width = W; gridCanvas.height = H;
    render(); renderGrid();
  });

  // --- Shift & Space key tracking ---
  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Shift') shiftHeld = true;
    if(e.key === ' ' && !e.repeat && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'INPUT'){
      e.preventDefault();
      spaceHeld = true;
      if(!isPanning) area.style.cursor = 'grab';
    }
  });
  document.addEventListener('keyup', (e)=>{
    if(e.key === 'Shift') shiftHeld = false;
    if(e.key === ' '){
      spaceHeld = false;
      if(!isPanning) updateCursor();
    }
  });

  // --- Keyboard shortcuts ---
  document.addEventListener('keydown', (e)=>{
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
    if((e.ctrlKey||e.metaKey) && e.key === 'z' && !e.shiftKey){ e.preventDefault(); undo(); }
    if((e.ctrlKey||e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))){ e.preventDefault(); redo(); }
    if((e.ctrlKey||e.metaKey) && (e.key === '=' || e.key === '+')){ e.preventDefault(); zoomCenter(1.25); }
    if((e.ctrlKey||e.metaKey) && e.key === '-'){ e.preventDefault(); zoomCenter(1/1.25); }
    if((e.ctrlKey||e.metaKey) && e.key === '0'){ e.preventDefault(); resetView(); }
    if(e.ctrlKey || e.metaKey) return;
    const keyMap = {p:'pen', l:'line', r:'rect', e:'ellipse', a:'arrow', h:'highlighter', t:'text', x:'eraser', g:'hand'};
    if(keyMap[e.key]) document.querySelector(`#wb-tools .wb-btn[data-tool="${keyMap[e.key]}"]`).click();
  });

  // --- AI Live Guess ---
  let aiKey = localStorage.getItem('wb-ai-key') || '';
  let aiAbort = null;
  const aiBtnEl = document.getElementById('wb-ai-btn');
  const aiPopover = document.getElementById('wb-ai-popover');
  const aiKeyInput = document.getElementById('wb-ai-key');
  const aiSaveBtn = document.getElementById('wb-ai-save');
  const aiStatusEl = document.getElementById('wb-ai-status');
  const aiGuessEl = document.getElementById('wb-ai-guess');
  const aiGuessText = document.getElementById('wb-ai-guess-text');

  if(aiKey) aiKeyInput.value = aiKey.slice(0,3) + '...' + aiKey.slice(-4);

  function showKeyPopover(){
    const dp = document.getElementById('wb-ai-draw-popover');
    if(dp) dp.classList.remove('visible');
    aiPopover.classList.toggle('visible');
    if(aiPopover.classList.contains('visible')){
      aiKeyInput.value = '';
      aiKeyInput.focus();
    }
  }

  aiBtnEl.addEventListener('click', ()=>{
    if(!aiKey){ showKeyPopover(); return; }
    doGuess();
  });

  // Right-click on either AI button to change API key
  aiBtnEl.addEventListener('contextmenu', (e)=>{ e.preventDefault(); showKeyPopover(); });


  aiSaveBtn.addEventListener('click', ()=>{
    const key = aiKeyInput.value.trim();
    if(!key || key.length < 10){
      aiStatusEl.textContent = 'Enter a valid key';
      aiStatusEl.style.color = '#ef4444';
      return;
    }
    aiKey = key;
    localStorage.setItem('wb-ai-key', aiKey);
    aiStatusEl.textContent = 'Saved!';
    aiStatusEl.style.color = '#34d399';
    aiKeyInput.value = aiKey.slice(0,3) + '...' + aiKey.slice(-4);
    setTimeout(()=>{
      aiPopover.classList.remove('visible');
      aiStatusEl.textContent = 'Stored locally only';
      aiStatusEl.style.color = '';
    }, 400);
  });

  aiKeyInput.addEventListener('keydown', (ev)=>{
    ev.stopPropagation(); // prevent whiteboard shortcuts
    if(ev.key === 'Enter') aiSaveBtn.click();
    if(ev.key === 'Escape') aiPopover.classList.remove('visible');
  });

  // Close popover when clicking outside
  document.addEventListener('pointerdown', (ev)=>{
    if(aiPopover.classList.contains('visible') &&
       !aiPopover.contains(ev.target) && ev.target !== aiBtnEl &&
       ev.target !== document.getElementById('wb-ai-draw-btn')){
      aiPopover.classList.remove('visible');
    }
  });

  function showGuess(text, loading){
    aiGuessText.textContent = text;
    aiGuessEl.classList.add('visible');
    aiGuessEl.classList.toggle('loading', !!loading);
  }
  function hideGuess(){
    aiGuessEl.classList.remove('visible','loading');
  }

  // Capture canvas for API
  function captureForAI(){
    const sz = 512;
    const off = document.createElement('canvas');
    off.width = sz; off.height = sz;
    const oCtx = off.getContext('2d');
    oCtx.fillStyle = BG;
    oCtx.fillRect(0,0,sz,sz);
    if(objects.length === 0) return null;
    // Find bounding box
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    function expand(obj){
      const pad = obj.lineWidth ? obj.lineWidth*4 : 20;
      if(obj.points) obj.points.forEach(p=>{
        if(p.x-pad<minX)minX=p.x-pad; if(p.y-pad<minY)minY=p.y-pad;
        if(p.x+pad>maxX)maxX=p.x+pad; if(p.y+pad>maxY)maxY=p.y+pad;
      });
      else if(obj.type==='text'){
        const lines=obj.text.split('\n'), lh=obj.fontSize*1.3;
        const h=lines.length*lh, w=Math.max(...lines.map(l=>l.length*obj.fontSize*0.6));
        if(obj.x-pad<minX)minX=obj.x-pad; if(obj.y-pad<minY)minY=obj.y-pad;
        if(obj.x+w+pad>maxX)maxX=obj.x+w+pad; if(obj.y+h+pad>maxY)maxY=obj.y+h+pad;
      } else {
        const x0=Math.min(obj.x1,obj.x2)-pad, y0=Math.min(obj.y1,obj.y2)-pad;
        const x1=Math.max(obj.x1,obj.x2)+pad, y1=Math.max(obj.y1,obj.y2)+pad;
        if(x0<minX)minX=x0; if(y0<minY)minY=y0; if(x1>maxX)maxX=x1; if(y1>maxY)maxY=y1;
      }
    }
    objects.forEach(expand);
    const bw=maxX-minX, bh=maxY-minY;
    if(bw<=0||bh<=0) return null;
    const scale = Math.min(sz/bw, sz/bh) * 0.9;
    const offX = (sz - bw*scale)/2 - minX*scale;
    const offY = (sz - bh*scale)/2 - minY*scale;
    oCtx.setTransform(scale,0,0,scale,offX,offY);
    for(const obj of objects) drawObject(oCtx, obj);
    return off.toDataURL('image/png');
  }

  async function doGuess(){
    if(!aiKey || objects.length === 0){ hideGuess(); return; }
    const dataUrl = captureForAI();
    if(!dataUrl){ hideGuess(); return; }
    showGuess('Sending request...', true);
    if(aiAbort) aiAbort.abort();
    aiAbort = new AbortController();
    try {
      const resp = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${aiKey}`
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [{
            role: 'user',
            content: [
              { type: 'text', text: 'This is a whiteboard sketch on a dark background. What is being drawn? Reply with ONLY a short guess (1-5 words), like "a cat", "house with tree", "smiley face". Nothing else.' },
              { type: 'image_url', image_url: { url: dataUrl, detail: 'low' } }
            ]
          }],
          max_tokens: 20
        }),
        signal: aiAbort.signal
      });
      const data = await resp.json();
      if(data.error){
        showGuess('API error: ' + (data.error.message || 'unknown').slice(0,40), false);
        setTimeout(hideGuess, 5000);
        return;
      }
      const guess = data.choices?.[0]?.message?.content?.trim() || '?';
      let costStr = '';
      if(data.usage){
        // gpt-4o-mini: $0.15/1M input, $0.60/1M output
        const inCost = (data.usage.prompt_tokens || 0) * 0.15 / 1e6;
        const outCost = (data.usage.completion_tokens || 0) * 0.60 / 1e6;
        const totalCost = inCost + outCost;
        const tokens = data.usage.total_tokens;
        costStr = ` (${tokens} tok, $${totalCost.toFixed(5)})`;
      }
      showGuess(guess + costStr, false);
    } catch(err){
      if(err.name === 'AbortError') return;
      showGuess('Connection error', false);
      setTimeout(hideGuess, 5000);
    }
  }

  // --- AI Draw ---
  const aiDrawBtn = document.getElementById('wb-ai-draw-btn');
  const aiDrawPopover = document.getElementById('wb-ai-draw-popover');
  const aiDrawPrompt = document.getElementById('wb-ai-draw-prompt');
  const aiDrawGo = document.getElementById('wb-ai-draw-go');
  const aiDrawStatus = document.getElementById('wb-ai-draw-status');
  let aiDrawAbort = null;

  aiDrawBtn.addEventListener('click', ()=>{
    if(!aiKey){ showKeyPopover(); return; }
    aiPopover.classList.remove('visible');
    aiDrawPopover.classList.toggle('visible');
    if(aiDrawPopover.classList.contains('visible')){
      aiDrawPrompt.focus();
    }
  });

  aiDrawBtn.addEventListener('contextmenu', (e)=>{ e.preventDefault(); showKeyPopover(); });

  aiDrawPrompt.addEventListener('keydown', (ev)=>{
    ev.stopPropagation();
    if(ev.key === 'Enter') aiDrawGo.click();
    if(ev.key === 'Escape') aiDrawPopover.classList.remove('visible');
  });

  // Close popover when clicking outside
  document.addEventListener('pointerdown', (ev)=>{
    if(aiDrawPopover.classList.contains('visible') &&
       !aiDrawPopover.contains(ev.target) && ev.target !== aiDrawBtn){
      aiDrawPopover.classList.remove('visible');
    }
  });

  // Convert SVG string to pen strokes using browser's SVG parser
  function svgToStrokes(svgText){
    const strokes = [];
    const parser = new DOMParser();
    if(!svgText.trim().startsWith('<svg')) svgText = `<svg xmlns="http://www.w3.org/2000/svg">${svgText}</svg>`;
    const doc = parser.parseFromString(svgText, 'image/svg+xml');
    const svg = doc.querySelector('svg');
    if(!svg) return strokes;

    // Inject SVG into DOM temporarily so getPointAtLength works
    svg.style.position = 'absolute';
    svg.style.left = '-9999px';
    svg.style.top = '-9999px';
    document.body.appendChild(svg);

    const vb = svg.getAttribute('viewBox');
    let svgW = 200, svgH = 200;
    if(vb){
      const parts = vb.split(/[\s,]+/).map(Number);
      if(parts.length >= 4){ svgW = parts[2]; svgH = parts[3]; }
    } else {
      svgW = parseFloat(svg.getAttribute('width')) || 200;
      svgH = parseFloat(svg.getAttribute('height')) || 200;
    }

    // Walk up parents to resolve inherited stroke/fill/stroke-width
    function resolveAttr(el, attr){
      let node = el;
      while(node && node !== svg){
        const v = node.getAttribute(attr);
        if(v) return v;
        node = node.parentElement;
      }
      return null;
    }

    function getColor(el){
      const stroke = resolveAttr(el, 'stroke');
      const fill = resolveAttr(el, 'fill');
      if(stroke && stroke !== 'none') return stroke;
      if(fill && fill !== 'none') return fill;
      return '#f5f7fa';
    }

    function getWidth(el){
      const sw = parseFloat(resolveAttr(el, 'stroke-width'));
      return sw > 0 ? sw : 2;
    }

    function toPath(el){
      const tag = el.tagName.toLowerCase();
      if(tag === 'path') return el.getAttribute('d');
      if(tag === 'line'){
        return `M${el.getAttribute('x1')||0},${el.getAttribute('y1')||0}L${el.getAttribute('x2')||0},${el.getAttribute('y2')||0}`;
      }
      if(tag === 'polyline' || tag === 'polygon'){
        const pts = (el.getAttribute('points')||'').trim().split(/[\s,]+/);
        let d = '';
        for(let i=0;i<pts.length-1;i+=2) d += (i===0?'M':'L') + pts[i]+','+pts[i+1];
        if(tag === 'polygon') d += 'Z';
        return d;
      }
      if(tag === 'circle'){
        const cx=+(el.getAttribute('cx')||0), cy=+(el.getAttribute('cy')||0), r=+(el.getAttribute('r')||0);
        if(r<=0) return null;
        return `M${cx-r},${cy}A${r},${r},0,1,1,${cx+r},${cy}A${r},${r},0,1,1,${cx-r},${cy}Z`;
      }
      if(tag === 'ellipse'){
        const cx=+(el.getAttribute('cx')||0), cy=+(el.getAttribute('cy')||0);
        const rx=+(el.getAttribute('rx')||0), ry=+(el.getAttribute('ry')||0);
        if(rx<=0||ry<=0) return null;
        return `M${cx-rx},${cy}A${rx},${ry},0,1,1,${cx+rx},${cy}A${rx},${ry},0,1,1,${cx-rx},${cy}Z`;
      }
      if(tag === 'rect'){
        const x=+(el.getAttribute('x')||0), y=+(el.getAttribute('y')||0);
        const w=+(el.getAttribute('width')||0), h=+(el.getAttribute('height')||0);
        if(w<=0||h<=0) return null;
        return `M${x},${y}L${x+w},${y}L${x+w},${y+h}L${x},${y+h}Z`;
      }
      return null;
    }

    // Process all drawable elements (including inside <g> groups)
    const elements = svg.querySelectorAll('path, line, polyline, polygon, circle, ellipse, rect');
    elements.forEach(el => {
      const c = getColor(el);
      const w = getWidth(el);
      const d = toPath(el);
      if(!d) return;

      // Create a temporary path element in the live SVG for sampling
      const pathEl = document.createElementNS('http://www.w3.org/2000/svg','path');
      pathEl.setAttribute('d', d);
      svg.appendChild(pathEl);

      try {
        const len = pathEl.getTotalLength();
        if(len > 0){
          const numPts = Math.max(12, Math.min(120, Math.round(len / 1.5)));
          const points = [];
          for(let i=0; i<=numPts; i++){
            const p = pathEl.getPointAtLength(i * len / numPts);
            points.push({x: p.x, y: p.y});
          }
          strokes.push({ points, color: c, width: w, svgW, svgH });
        }
      } catch(e){}
      svg.removeChild(pathEl);
    });

    document.body.removeChild(svg);
    return strokes;
  }

  aiDrawGo.addEventListener('click', async ()=>{
    const prompt = aiDrawPrompt.value.trim();
    if(!prompt){ aiDrawStatus.textContent = 'Enter a prompt'; aiDrawStatus.style.color = '#ef4444'; return; }
    if(!aiKey){ showKeyPopover(); return; }

    aiDrawPopover.classList.remove('visible');
    showGuess('Sending request...', true);
    aiDrawGo.disabled = true;

    if(aiDrawAbort) aiDrawAbort.abort();
    aiDrawAbort = new AbortController();

    try {
      const resp = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${aiKey}`
        },
        body: JSON.stringify({
          model: 'gpt-4o',
          messages: [{
            role: 'system',
            content: `You are an expert SVG artist. You create beautiful, detailed SVG illustrations. Output ONLY the SVG markup, nothing else.

Requirements:
- Use viewBox="0 0 200 200". Fill the viewBox — the drawing should span most of the 200x200 area.
- Use <path> with cubic bezier curves (C command) for smooth organic shapes. Use <circle>, <ellipse>, <rect>, <line> for geometric parts.
- Use bright colors visible on dark background (#181b22). Never use black, #000, or very dark colors.
- Set stroke, stroke-width, and fill on each element. Use fill="none" for outlines only.
- <g> groups are OK for organizing. Do NOT use <text>, <image>, <use>, <defs>, <style>, <clipPath>, <filter>, transforms, or CSS.
- Create detailed, realistic illustrations — NOT stick figures or simple shapes.

Example — a star:
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
<polygon points="100,10 120,75 190,75 135,115 155,180 100,145 45,180 65,115 10,75 80,75" fill="#facc15" stroke="#fbbf24" stroke-width="2"/>
</svg>`
          },{
            role: 'user',
            content: `Draw: ${prompt}`
          }],
          max_tokens: 4096,
          temperature: 0.7
        }),
        signal: aiDrawAbort.signal
      });

      const data = await resp.json();
      if(data.error){
        showGuess('API error: ' + (data.error.message || 'unknown').slice(0, 40), false);
        setTimeout(hideGuess, 5000);
        aiDrawGo.disabled = false;
        return;
      }

      let raw = data.choices?.[0]?.message?.content?.trim() || '';
      // Strip markdown fences if present
      raw = raw.replace(/^```(?:xml|svg|html)?\s*/i, '').replace(/\s*```$/,'');

      // Extract SVG tag if surrounded by other text
      const svgMatch = raw.match(/<svg[\s\S]*<\/svg>/i);
      if(svgMatch) raw = svgMatch[0];

      const strokes = svgToStrokes(raw);

      if(strokes.length === 0){
        showGuess('No drawable elements found', false);
        setTimeout(hideGuess, 5000);
        aiDrawGo.disabled = false;
        return;
      }

      // Cost info (gpt-4o: $2.50/1M input, $10/1M output)
      let costStr = '';
      if(data.usage){
        const inCost = (data.usage.prompt_tokens || 0) * 2.50 / 1e6;
        const outCost = (data.usage.completion_tokens || 0) * 10.0 / 1e6;
        const totalCost = inCost + outCost;
        costStr = ` (${data.usage.total_tokens} tok, $${totalCost.toFixed(4)})`;
      }

      // Compute scale & offset to fill ~85% of visible viewport
      const vw = W / zoom;
      const vh = H / zoom;
      const svgW = strokes[0].svgW;
      const svgH = strokes[0].svgH;
      const targetW = vw * 0.85;
      const targetH = vh * 0.85;
      const scale = Math.min(targetW / svgW, targetH / svgH);
      const viewX0 = -panX / zoom;
      const viewY0 = -panY / zoom;
      const offsetX = viewX0 + (vw - svgW * scale) / 2;
      const offsetY = viewY0 + (vh - svgH * scale) / 2;

      // Add strokes with animation
      saveState();
      let strokeIdx = 0;
      function addNextStroke(){
        if(strokeIdx >= strokes.length){
          showGuess(`Done! ${strokes.length} strokes${costStr}`, false);
          aiDrawGo.disabled = false;
          saveState();
          return;
        }
        const s = strokes[strokeIdx];
        const pts = s.points.map(p => ({
          x: p.x * scale + offsetX,
          y: p.y * scale + offsetY
        }));
        if(pts.length > 0){
          objects.push({
            type: 'pen',
            points: pts,
            color: s.color || color,
            lineWidth: Math.max(1, s.width * scale),
            opacity: 1
          });
          render();
        }
        strokeIdx++;
        setTimeout(addNextStroke, 30);
      }

      showGuess('Drawing...', true);
      addNextStroke();

    } catch(err){
      if(err.name === 'AbortError') return;
      showGuess('Connection error', false);
      setTimeout(hideGuess, 5000);
      aiDrawGo.disabled = false;
    }
  });

})();
</script>

</body>
</html>
